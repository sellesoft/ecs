/*
 *  An Asset is any information loaded from disk, with the exception of 
 *  SourceDataFiles.
 *
 *  TODO(sushi) rework the ref counting RAII stuff we're doing as its kinda
 *              annoying and its implementation is extremely complex.
 */

$ local cmn = require "common"
$ local metadata = require "reflect.Metadata"

#include "iro/Common.h"
#include "iro/Unicode.h"

@lpp.import "reflect/rtr.lh"

using namespace iro;

struct AssetMgr;
struct SourceData;

/* ============================================================================
 *  The header of any Asset loaded via the AssetMgr.
 */
struct Asset 
{
  u64 hash = 0;

  static u64 getAVLKey(const Asset& asset) { return asset.hash; }

  // Note that this String is owned by this Asset, so only point to it 
  // if you know that pointer will be used only during the lifetime of the 
  // Asset it was retrieved from.
  String name;

  // A Asset's position in the linked pool. This kinda sucks really bad.
  // TODO(sushi) manually implement a better linked list solution here.
  void* node;

  void* data = nullptr;
  u64   size = 0;
};

/* ============================================================================
 */
@metadata.ref
struct AssetLink
{
  // The name of the Asset this link references.
  String name = nil;

  // A pointer to the Asset, or nullptr if the link is broken.
  // TODO(sushi) this makes this a triple-pointer, which sucks. We should 
  //             try and reduce that later on. Ideally, though, we could 
  //             have a super fancy setup where in release this is a direct
  //             pointer.
  @metadata.hidden
  Asset* asset = nullptr; 

  static AssetLink invalid() { return {}; }

  b8 isValid() const { return notnil(name) && asset != nullptr; }

  void invalidate() { *this = invalid(); }

  Asset* tryGetAsset() { return isValid()? asset : nullptr; }
  const Asset* tryGetAsset() const { return isValid()? asset : nullptr; }

  Asset* getAsset() const { assert(isValid()); return asset; }
};

/* ============================================================================
 */
template<typename T>
struct TypedAssetLink : AssetLink
{
  T* operator ->() { return (T*)getAsset()->data; }

  T& operator*() { return *(T*)getAsset()->data; }
  const T& operator*() const { return *(T*)getAsset()->data; }

  T& get() { return *(T*)getAsset()->data; }
  const T& get() const { return *(T*)getAsset()->data; }

  T* tryGet()
  {
    if (Asset* asset = tryGetAsset())
      return (T*)asset->data;
    return nullptr;
  }

  const T* tryGet() const
  {
    if (const Asset* asset = tryGetAsset())
      return (T*)asset->data;
    return nullptr;
  }
};
