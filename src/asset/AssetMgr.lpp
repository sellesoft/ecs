$ local cmn = require "common"

@@lpp.import "asset/AssetMgr.lh"

#include "iro/memory/Memory.h"
#include "iro/fs/File.h"
#include "iro/fs/fs.h"

@log.import

/* ----------------------------------------------------------------------------
 */
b8 AssetMgr::init(mem::Allocator* allocator, String data_mount)
{
  this->allocator = allocator;
  this->data_mount = data_mount;

  if (!map.init(allocator))
    return @log.error(asset, "failed to init asset map\n");

  if (!pool.init(allocator))
    return @log.error(asset, "failed to init asset pool\n");

  return true;
}

/* ----------------------------------------------------------------------------
 */
void AssetMgr::deinit()
{
// TODO(sushi) properly clean up assets. Currently we lose a lot of them,
//             specifically when loading gfx resource defs because they 
//             do not store the loaded source asset data used to find the 
//             asset desired. I'm not going to do this now because I plan to
//             rework how all of that works soon.
$ if false then
  if (!map.isEmpty())
  {
    @log.error(asset, "AssetMgr::deinit called but Assets still exist!\n",
          "  Currently allocated resources are: \n");
    for (Asset& asset : map)
    {
      @log.error(asset, "    ", asset.name, "\n");
    }

    assert(!"AssetMgr::deinit called while Assets are still active!");
  }
$ end
  
  pool.deinit();
  map.deinit();
}

/* ----------------------------------------------------------------------------
 */
String AssetMgr::formAssetPath(
    fs::PathBuffer* buffer, 
    String name, 
    String type) const
{
  io::formatv(buffer, data_mount, '/', name, '.', type);
  return String(*buffer);
}

/* ----------------------------------------------------------------------------
 */
Asset* AssetMgr::allocateAsset(String name)
{
  u64 name_hash = name.hash();
  assert(map.find(name_hash) == nullptr && 
    "a Asset has already been allocated with the given name");

  AssetPool::Node* node = pool.pushTail();

  Asset* asset = node->data;

  asset->node = node;
  asset->hash = name_hash;
  asset->name = name.allocateCopy(allocator);

  map.insert(asset);

  return asset;
}

/* ----------------------------------------------------------------------------
 */
Asset* AssetMgr::loadAssetFromDisk(String name, String type)
{
  using namespace fs;
  
  PathBuffer path_buffer;
  String path = formAssetPath(&path_buffer, name, type);

  u64 name_hash = path.hash();
  if (Asset* existing = map.find(name_hash))
  {
    @log.debug(asset, "asset '", path, "' already loaded\n");
    return existing;
  }

  @log.debug(asset, "loading asset '", path, "' from disk\n");

  if (!path::exists(path))
  {
    @log.error(asset, "no asset exists at path '", path, "'\n");
    return nullptr;
  }

  auto file = File::from(path, OpenFlag::Read);
  if (isnil(file))
  {
    @log.error(asset, "failed to open asset file at '", path, "'\n");
    return nullptr;
  }

  Asset* asset = allocateAsset(path);
  if (asset == nullptr)
  {
    @log.error(asset, "failed to allocate asset '", path, "'\n");
    return nullptr;
  }

  Stat stat;
  fs::stat(path, &stat);

  asset->size = stat.byte_size;
  asset->data = allocator->allocate(asset->size);

  assert(asset->size == file.read({(u8*)asset->data, asset->size}));

  return asset;
}

/* ----------------------------------------------------------------------------
 */
Asset* AssetMgr::reloadAsset(String name, String type)
{
  using namespace fs;

  PathBuffer path_buffer;
  String path = formAssetPath(&path_buffer, name, type);

  u64 name_hash = path.hash();
  
  Asset* asset = map.find(name_hash);
  if (asset == nullptr)
  {
    @log.error(asset, "attempt to reload asset ", name, '.', type, " but it is not "
          "known to the AssetMgr\n");
    return nullptr;
  }

  auto file = File::from(path, OpenFlag::Read);
  if (isnil(file))
  {
    @log.error(asset, "failed to open asset file at '", path, "'\n");
    return nullptr;
  }

  Stat stat;
  fs::stat(path, &stat);

  allocator->free(asset->data);

  asset->size = stat.byte_size;
  asset->data = allocator->allocate(asset->size);

  assert(asset->size == file.read({(u8*)asset->data, asset->size}));

  return asset;
}

/* ----------------------------------------------------------------------------
 */
Asset* AssetMgr::tryReloadAsset(String name, String type)
{
  if (nullptr != findAsset(name, type))
    return reloadAsset(name, type);
  return nullptr;
}

/* ----------------------------------------------------------------------------
 */
void AssetMgr::unloadAsset(Asset* asset)
{
// NOTE(sushi) disabling because something is currently broken in the AVL
//             type that causes this to crash and I don't want to deal with it
//             right now. Just want to get proper closing of the engine to 
//             work and I'm gonna be reworking all of this pretty soon anyways.
$ if false then
  INFO("unloading ", asset->name, '\n');

  map.remove(asset);

  allocator->free(asset->data);
  asset->size = 0;
  asset->name = nil;
  asset->hash = 0;

  pool.remove((AssetPool::Node*)asset->node);
$ end
}

/* ----------------------------------------------------------------------------
 */
Asset* AssetMgr::findAsset(String path) const
{
  return map.find(path.hash());
}

/* ----------------------------------------------------------------------------
 */
Asset* AssetMgr::findAsset(String name, String type) const
{
  iro::fs::PathBuffer path_buffer;
  return findAsset(formAssetPath(&path_buffer, name, type));
}
