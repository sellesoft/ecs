/*
 *  Represents some packed data storable on disk.
 */

$ require "common"

@@lpp.import "core/OffsetPtr.lh"
@@lpp.import "asset/CompiledDataInterfaces.lh"
@@lpp.import "reflect/TypeId.lh"

#include "iro/Common.h"
#include "iro/containers/SmallArray.h"
#include "iro/Unicode.h"

struct Asset;
struct Ref;
struct SourceData;

/* ============================================================================
 *  Note that this structure reprensents the header of the compiled data 
 *  as written to disk.
 */
struct CompiledData
{
  rtr::TypeId type;

  enum class PointerState
  {
    Offset,
    Absolute,
  };

  PointerState pointer_state;

  OffsetSlice<u8> root;
  OffsetSlice<u8> data;
  OffsetSlice<u8> strings;

  struct CompileParams
  {
    // The type to compile the provided data into.
    rtr::TypeId type;
    
    // A pointer to the data to compile.
    // TODO(sushi) change this to Bytes and assert if size does not match.
    void* dataptr;

    // Where the compiled data should be output to.
    // TODO(sushi) we should support something like an IO* here, but for now 
    //             this is simpler and I believe our only usecase. I would 
    //             rather wait until iro's IO model is rewritten or otherwise
    //             improved before trying to use that here.
    String output_path;
  };

  static b8 compile(const CompileParams& params);

  // TODO(sushi) it kinda blows that we need to pass an allocator in here. 
  //             Really, the size needed to load some CompiledData is the 
  //             size of the file on disk, but that's not totally clear 
  //             and its just easier to handle that stuff internally.
  //             Maybe add a thing to get the required size later (which
  //             also sucks cause that would be checking something on disk
  //             to do so).
  static CompiledData* load(String path, mem::Allocator* allocator);

  // Gets the loaded data as the specified C++ type. Note that currently there 
  // are no safety checks for if the provided 'T' actually matches the type the 
  // data was compiled for. 
  // TODO(sushi) implement those checks.
  // NOTE(sushi) the checks in question are kinda difficult to properly handle
  //             since this is templated, and C++ loses information in
  //             templates. This should be changed to be a macro instead 
  //             which takes the typename, transforms it to a typeid, checks
  //             that it matches 'type' and then casts the root pointer.
  //             Specifically, if we tried to use a typedef here and had 
  //             checks that would get the typeid from T, it would return
  //             the typeid of the typedef'd type, not the desired type, which
  //             would break. Not that it would necessarily be wrong (the 
  //             data would be the same), but we would want to make sure that 
  //             if a type is compiled as typedef B A;, and we ask for A, 
  //             we are going to only allow getting compiled data of type A,
  //             NOT B.
  // NOTE(sushi) I have just discovered that we can actually use rtr::TypeId
  //             as a template argument... Though I suppose we can't really 
  //             utilize that here cause we can't determine what the return
  //             type should be unless we have an in-header mapping of 
  //             typeids to their types. Don't really want to start generating
  //             code like that in headers. Just make it a macro.
  template<typename T>
  T* getRootAs() const
  {
    return (T*)root.getSlice().ptr;
  }
  
  // Fixes all pointers in the loaded data to absolute addresses.
  void fixPointers(); 

  // TODO(sushi) rework this to just take a callback for each Ref, or at least
  //             add an option to get them that way, I think that usage would
  //             be more common as atm I can't think of any reason we'd want
  //             to store these off.
  struct DataRef
  {
    rtr::TypeId type;
    void* ptr;
    String target;
  };

  typedef SmallArray<DataRef, 16> Refs;

  void getRefs(Refs* refs);
};
