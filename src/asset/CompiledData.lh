/*
 *  Represents some packed data storable on disk.
 */

$ require "common"

@@lpp.import "core/OffsetPtr.lh"
@@lpp.import "asset/CompiledDataInterfaces.lh"
@@lpp.import "reflect/TypeId.lh"

#include "iro/Common.h"
#include "iro/containers/SmallArray.h"
#include "iro/Unicode.h"

struct Asset;
struct Ref;
struct SourceData;

/* ============================================================================
 *  Note that this structure reprensents the header of the compiled data 
 *  as written to disk.
 */
struct CompiledData
{
  rtr::TypeId type;

  enum class PointerState
  {
    Offset,
    Absolute,
  };

  PointerState pointer_state;

  OffsetSlice<u8> root;
  OffsetSlice<u8> data;
  OffsetSlice<u8> strings;

  struct CompileParams
  {
    // The type to compile the provided data into.
    rtr::TypeId type;
    
    // A pointer to the data to compile.
    // TODO(sushi) change this to Bytes and assert if size does not match.
    void* dataptr;

    // Where the compiled data should be output to.
    // TODO(sushi) we should support something like an IO* here, but for now 
    //             this is simpler and I believe our only usecase. I would 
    //             rather wait until iro's IO model is rewritten or otherwise
    //             improved before trying to use that here.
    String output_path;
  };

  static b8 compile(const CompileParams& params);

  static CompiledData* load(String path, mem::Allocator* allocator);

  // Gets the loaded data as the specified C++ type. Note that currently there 
  // are no safety checks for if the provided 'T' actually matches the type the 
  // data was compiled for. 
  // TODO(sushi) implement those checks.
  // NOTE(sushi) the checks in question are kinda difficult to properly handle
  //             since this is templated, and C++ loses information in
  //             templates. This should be changed to be a macro instead 
  //             which takes the typename, transforms it to a typeid, checks
  //             that it matches 'type' and then casts the root pointer.
  template<typename T>
  T* getRootAs() const
  {
    return (T*)root.getSlice().ptr;
  }
  
  // Fixes all pointers in the loaded data to absolute addresses.
  void fixPointers(); 

  // TODO(sushi) rework this to just take a callback for each Ref, or at least
  //             add an option to get them that way, I think that usage would
  //             be more common as atm I can't think of any reason we'd want
  //             to store these off.
  struct DataRef
  {
    rtr::TypeId type;
    void* ptr;
    String target;
  };

  typedef SmallArray<DataRef, 16> Refs;

  void getRefs(Refs* refs);
};

