$ local cmn = require "common"
$ local ast = require "reflect.ast"
$ local clog = require "iro.Logger" ("linker", Verbosity.Debug)

$$$ 
local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/**/*.defs.lh",
  "src/**/*.comp.lh",
  "src/**/*.resource.lh",
}

local ResourceLink = astctx:lookupTypeDecl "gfx::ResourceLink"
local CompiledDataLink = astctx:lookupDecl "CompiledDataLink"
local AssetLink = astctx:lookupDecl "AssetLink"

ast.dumpout(astctx:lookupDecl "EditorSkinDefLink")

local link_decls = cmn.List {}
local link_decls_found = {}

local function recordLinkDecl(decl)
  if decl:is(ast.Template) then
    return
  end

  if not link_decls_found[decl.type.name] then
    link_decls_found[decl.type.name] = true
    link_decls:push(decl)
  end
  decl.metadata.is_link = true
end

local decls_with_links = cmn.List {}
local decls_with_links_found = {}

local function recordDeclWithLinks(decl, has_link_fields)
  if not decls_with_links_found[decl.type.name] then
    decls_with_links_found[decl.type.name] = true
    decls_with_links:push(decl)
  end

  decl.metadata.has_links = true
  decl.metadata.has_link_fields = 
    decl.metadata.has_link_fields or has_link_fields
end

local function searchForLinks(decl)
  if decl:is(ast.TypedefDecl) then
    if decl:findMetadata "ref" then
      recordLinkDecl(decl)
    end
  elseif decl:is(ast.Record) then
    if decl:findMetadata "ref" then
      recordLinkDecl(decl)
    end

    for field in decl:allFields() do
      local type = field.type
      if type:is(ast.Elaborated) then
        type = type.subtype
      end

      if type:is(ast.TypedefType) then
        local typedef_decl = type.decl
        if typedef_decl:findMetadata "ref" then
          typedef_decl.metadata.is_used_link = true
        end
        type = typedef_decl.subtype:desugar()
      end

      if type:is(ast.TagType) and type.decl:is(ast.Record) then
        local field_type_decl = type.decl
        if field_type_decl:findMetadata "ref" then
          recordDeclWithLinks(decl, true)
          field_type_decl.metadata.is_used_link = true
          field.metadata.has_links = true
          field.metadata.is_link = true
        elseif field_type_decl:is(ast.TemplateSpec) then
          local specname = field_type_decl.qname 
          if specname == "reflect::Array" then
            local subtype = field_type_decl.args[1]:desugar()
            if subtype:is(ast.TagType) and subtype.decl:is(ast.Record) then
              searchForLinks(subtype.decl)
              if subtype.decl.metadata.has_links then
                recordDeclWithLinks(field_type_decl, false)
                recordDeclWithLinks(decl, false)
                field.metadata.has_links = true
              end
            end
          end
        else
          searchForLinks(field_type_decl)
          if field_type_decl.metadata.has_links then
            recordDeclWithLinks(decl, false)
            field.metadata.has_links = true
          end
        end
      end
    end
  end
end

for decl in astctx.type_decls:each() do
  searchForLinks(decl)
end

-- Remove link decls that are unused.
local used_link_decls = cmn.List {}
for decl in link_decls:each() do
  if decl.qname ~= "AssetLink" and decl.qname ~= "gfx::ResourceLink" then
    used_link_decls:push(decl)
  end

  -- if decl.metadata.is_used_link then
  --   used_link_decls:push(decl)
  -- end
end
link_decls = used_link_decls

-- for decl in decls_with_links:each() do
--   ast.dumpout(decl)
-- end
--
-- for decl in link_decls:each() do
--   ast.dumpout(decl)
-- end

$$$
@@imported:get

@@lpp.import "graphics/ResourceMgr.lh"
@@lpp.import "asset/AssetMgr.lh"

@log.ger(linker, Debug)

/* ============================================================================
 */
struct Linker
{

  gfx::ResourceMgr& resource_mgr;
  AssetMgr& asset_mgr;

$ local putDeclLinker 
$ local putTypeLinker

$ -- * ------------------------------------------------------------------------

$ local function recordPlaced(decl)
$   decl.user = decl.user or {}
$   decl.user.linker_placed = true
$ end

$ -- * ------------------------------------------------------------------------

$ local function getDeclLinkerName(decl)
$   return "link_"..decl:formCSafeName()
$ end

$ -- * ------------------------------------------------------------------------

$ local function getTypeLinkerName(type)
$   if type:is(ast.Elaborated) then
$     type = type.subtype
$   end
$
$   if type:is(ast.TypedefType) then
$     return (getDeclLinkerName(type.decl))
$   end
$  
$   type = type:desugar()
$   if type:is(ast.TagType) then
$     return (getDeclLinkerName(type.decl))
$   else
$     error("unhandled type passed to getTypeLinkerName: "..
$           tostring(type)..'\n')
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ local function getDeclLinkerSig(decl)
$   return getDeclLinkerName(decl).."("..decl.type.name.."* data)"
$ end

$ -- * ------------------------------------------------------------------------

$ local function declareDeclLinker(decl)
$   recordPlaced(decl)
$   return "b8 "..getDeclLinkerSig(decl)
$ end

$ -- * ------------------------------------------------------------------------

$ local function maybeCallFieldLinker(field, record)
$   if not field.metadata.has_links then return end
    if (!$(getTypeLinkerName(field.type))(&data->$(field.name)))
      return ERROR("failed to link field $(field.name) of $(record.qname)\n");
$ end

$ local function putStructLinker(decl)
  /* --------------------------------------------------------------------------
   */
  $(declareDeclLinker(decl))
  {
$   for field in decl:allFields() do
$     maybeCallFieldLinker(field, decl)
$   end
    return true;
  }
$ end

$ local function putArrayLinker(decl)
$   local subtype = decl.args[1]
  /* --------------------------------------------------------------------------
   */
  $(declareDeclLinker(decl))
  {
    u32 elem_idx = 0;
    for (auto& elem : *data)
    {
      if (!$(getTypeLinkerName(subtype))(&elem))
        return ERROR("failed to link element ", elem_idx, " of array\n");

      elem_idx += 1;
    }

    return true;
  }
$ end

$ for decl in decls_with_links:each() do
$   if decl:is(ast.TemplateSpec) and 
$      decl.specialized.qname == "reflect::Array" then
$     putArrayLinker(decl)
$   else
$     putStructLinker(decl)
$   end
$ end

$ local function putCompiledDataLinker(decl)
  /* --------------------------------------------------------------------------
   */
  $(declareDeclLinker(decl))
  {
    // Compiled data.
$   local link_type = decl.metadata.links
$   if not link_type then
$      clog:warn("compiled asset link type ", decl.qname, " does not specify ",
$                "what asset type it links\n")
    WARN("cannot link $(decl.type.name) because it does not specify what "
         "asset type it links\n");
$   else
    // Load the CompiledData as an Asset.
    data->asset = asset_mgr.loadAssetFromDisk(data->name, "$(link_type)"_str);

    if (data->asset == nullptr)
      return ERROR("failed to link compiled data '", data->name, "' of type "
                   "$(link_type)\n");

    // Get the CompiledData.
    CompiledData* compiled = &data->get();

    // Fix its pointers.
    compiled->fixPointers();

    // Link any embedded links.
    for (CompiledData::Ref& ref : compiled->refs.getSlice())
    {
      if (!linkByTypeId(ref.type, ref.ptr.get()))
        return ERROR("failed to link embedded link in compiled data\n");
    }
$   end
    return true;
  }
$ end

$ local function putAssetLinker(decl)
  /* --------------------------------------------------------------------------
   */
  $(declareDeclLinker(decl))
  {
    // Generic asset.
$   local link_type = decl.metadata.links
$   if not link_type then
$     clog:warn("asset link type ", decl.qname, " does not specify what ",
$               "asset type it links\n")
    WARN("unable to link asset type $(decl.qname) because it did not specify "
         "metadata.links\n");
$   else
    
    if (isnil(data->name))
      return true; // nothing to link.

    data->asset = asset_mgr.loadAssetFromDisk(data->name, "$(link_type)"_str);

    if (data->asset == nullptr)
      return ERROR(
        "failed to link asset '", data->name, "' of type $(link_type)\n");
$   end

    return true;
  }
$ end

$ local function putResourceLinker(decl)
$   local function getResourceType(decl)
$     if decl:is(ast.TemplateSpec) then
$       if decl.specialized.qname == "gfx::TypedResourceLink" then
$         return decl.args[1]
$       end
$     end
$     if decl.base then
$       return getResourceType(decl.base)
$     end
$   end
$   local resource_type = getResourceType(decl)
$   if not resource_type then
$     error("failed to find resource type from "..decl.qname)
$   end
$   local resource_decl = resource_type.decl
$   local rname = resource_decl.name
$   local rtname = resource_decl.type.name
  /* --------------------------------------------------------------------------
   */
  $(declareDeclLinker(decl))
  {
    if (isnil(data->name))
      return true; // nothing to link.

    // Resource.
    // Ask the ResourceMgr to create the resource or give us it if it already
    // exists.
    // TODO(sushi) check if it already exists.
    data->resource = resource_mgr.getOrCreate$(rname)(data->name);

    auto* r = ($(rtname)*)data->resource;

    // Set nested links to reference what the data wants.
$ for field in resource_decl:allFields() do
$   if field.metadata.is_link then
    r->$(field.name).name = data->name;
$   end
$ end
    
    // Link any internals the Resource may have.
    if (!$(getTypeLinkerName(resource_type))(r))
      return ERROR("failed to link resource $(rname)\n");

    // Ask the resource manager to load the resource.
    if (!resource_mgr.load$(rname)(r))
      return ERROR("failed to load resource $(rname)\n");

    return true;
  }
$ end

$ for decl in link_decls:each() do
$   local real_decl = decl
$   if decl:is(ast.TypedefDecl) then
$     decl = decl.subtype:desugar().decl
$   end
$   if decl:isDerivedFrom(CompiledDataLink) then
$     putCompiledDataLinker(real_decl)
$   elseif decl:isDerivedFrom(AssetLink) then
$     putAssetLinker(real_decl)
$   elseif decl:isDerivedFrom(ResourceLink) then
$     putResourceLinker(real_decl)
$   end
$ end

  /* --------------------------------------------------------------------------
   */
  b8 linkByTypeId(rtr::TypeId type, void* data)
  {
    switch (type.val)
    {
$ for decl in link_decls:each() do
    case "$(decl.type.name)"_typeid_val:
      return $(getDeclLinkerName(decl))(($(decl.type.name)*)data);
$ end
$ for decl in decls_with_links:each() do
    case "$(decl.type.name)"_typeid_val:
      return $(getDeclLinkerName(decl))(($(decl.type.name)*)data);
$ end
    }
    return true;
  }
};


/* ----------------------------------------------------------------------------
 *  Generate the actual function used through the interface.
 *  Currently only accessible via runtime typing. Can improve later.
 *
 *  Note that currently, any type that isn't recognized as needing to be linked
 *  just falls through and returns true.
 */
b8 linkData(
    rtr::TypeId type, 
    void* data, 
    gfx::ResourceMgr& resource_mgr, 
    AssetMgr& asset_mgr)
{
  Linker linker = { .asset_mgr = asset_mgr, .resource_mgr = resource_mgr };

  return linker.linkByTypeId(type, data);
}
