/*
 *  A 'rule' for telling the build system how to build an asset of some type.
 *  
 *  Rules provide the build system with an interface (IRule) which provides
 *  callbacks the build system will use when it needs information about 
 *  a certain Target. Currently this is just when the build system needs 
 *  to know the prerequisites of a Target as well as when it wants to actually
 *  build it.
 *
 *  Rules may specify several asset types that they output. The first type 
 *  specified is considered the Rule's 'primary' output. Any type specified 
 *  after that (delimited by a ';') is considered the type of a secondary 
 *  asset that will be generated by a Rule. For now, IRule::build will only be 
 *  passed the Target representing its primary output.
 *
 *  The reason we do this, as opposed to just completely ignoring secondary 
 *  outputs, is that the build system still needs to be aware of what will
 *  build a Target that may be linked to by another one. The only current 
 *  example as of writing is fonts, which need to output the font's data as 
 *  well as the font's texture. 
 *
 *  TODO(sushi) explain this more clearly later once I have a better 
 *              understanding of why this is necessary. Its currently this 
 *              way because it makes it work, but I'm not totally sure if 
 *              there's a way to avoid it.
 */

$ require "common"

#include "iro/Common.h"

// TODO(sushi) dont like importing this, we should change TargetSet to 
//             something else passed into getPrereqs later, as mentioned 
//             below, so we don't need to import this. I mean, we don't have 
//             to in general, but, whatever.
@lpp.import "build/Target.lh"

namespace build
{

struct Target;
struct Result;
struct BuildSystem;

/* ============================================================================
 *  Params structs for build rule functions to make adding/removing/changing 
 *  params less of an annoyance.
 */
struct RuleParams_GetPrereqs
{
  Target* target;
  BuildSystem* build_system;
  TargetSet* prereqs;
  Result* result;
};

struct RuleParams_Build
{
  Target* target;
  BuildSystem* build_system;
  Result* result;
};

/* ============================================================================
 *  The interface used by the build system to ask a build rule for information 
 *  about a Target, or to build it.
 *
 *  The BuildResult parameter is used by the build system 
 *  
 *  NOTE(sushi) currently, I'm setting this up to pass the BuildSystem and 
 *              Target as const primarily under the idea that these will be 
 *              called in a multithreaded fashion and will be expected to 
 *              output data separate to the BuildSystem and Target itself.
 *              A problem I'm expecting with this is new Target creation. 
 *              Those are kinda heavy-weight right now, and when the build
 *              system was experimental, we just created them directly 
 *              with the BuildSystem. With multithreading that will be much 
 *              more difficult, and its likely that we will need to extract
 *              lighter weight representations of Targets to create actual 
 *              targets from when we are sure its thread-safe to (eg. 
 *              TargetInfo).
 *              Not sure yet, though, maybe a better solution will become 
 *              more apparent as I pull this stuff into the actual codebase.
 *              ACTUALLY, they aren't const yet, but they maybe should be.
 */
struct IRule
{
  // Called when the build system needs to know what the given Target depends 
  // on. 
  void (*getPrereqs)(const RuleParams_GetPrereqs& params);
  
  // Called once the build system has determined that all prerequites of the
  // given Target are satisified, and that it itself needs built.
  void (*build)(const RuleParams_Build& params);
};

/* ============================================================================
 *  A Rule that provides the build system with an interface for dealing with 
 *  some target.
 */
struct Rule
{
  // The output types of this rule. The first type specified is considered 
  // the 'primary' output, while any additional types (delimited by ';') 
  // are considered secondary. See above for why this matters.
  String types;

  // This rule's interface.
  IRule interface;
};

}
