/*
 *  Core definitions for ecs' logging infrastructure.
 */

$ require "common"

#ifndef _ecs_logging_core_h
#define _ecs_logging_core_h

#include "iro/Common.h"
#include "iro/Unicode.h"
#include "iro/time/Time.h"
#include "iro/print.h"
#include "iro/io/SmallBuffer.h"

namespace logging
{

/* ============================================================================
 */
enum class Verbosity
{
  Trace,
  Debug,
  Info,
  Notice,
  Warn,
  Error,
  Fatal
};

/* ============================================================================
 */
struct Category
{
  // The name of this category. Must be unique, as this is how it is referred
  // to in UI and console commands and such.
  iro::String name;
  
  // The current verbosity setting of this category. Initialized to a default
  // value where it is defined and adjustable at runtime through UI and 
  // console commands.
  Verbosity verbosity;

  u64 line_len;

  b8 need_prefix = true;
};

/* ============================================================================
 *  Data representing a log 'entry'. These are passed to Destinations when the
 *  verbosity of the Entry is above or equal to that of the Category that 
 *  it was logged through
 */
struct Entry
{
  // The Category this Entry was logged through.
  const Category* category;

  // The Verbosity of this Entry.
  Verbosity verbosity;

  // The fully formed message.
  iro::String message;

  iro::TimePoint timestamp = {};

  // TODO(sushi) perhaps some kinda data field. Not needed at the moment.
};

/* ============================================================================
 */
struct Channel
{
  virtual void log(const Entry& entry) = 0;

  void log(Category* cat, Verbosity v, auto&&... args)
  {
    Entry entry;
    entry.timestamp = iro::TimePoint::now();
    entry.category = cat;
    entry.verbosity = v;

    iro::io::SmallBuffer<512> message_buffer;
    iro::io::formatv(&message_buffer, args...);

    entry.message = iro::String(message_buffer);
    
    log(entry);
  }

  void info(Category* cat, auto&&... args)
  {
    log(cat, Verbosity::Info, args...);
  }

  void notice(Category* cat, auto&&... args)
  {
    log(cat, Verbosity::Notice, args...);
  }

  void error(Category* cat, auto&&... args)
  {
    log(cat, Verbosity::Error, args...);
  }

  void warn(Category* cat, auto&&... args)
  {
    log(cat, Verbosity::Warn, args...);
  }
};

/* ============================================================================
 */
struct GlobalChannel : Channel
{
  void log(const Entry& entry) override
  {
    iro::println(entry.message);
  }
};

/* ============================================================================
 */
struct State
{
  // An OWNED view of all categories.
  iro::Slice<Category> categories; 

  GlobalChannel chan;
};

// Gets the global log state.
State* get();

}

#endif
