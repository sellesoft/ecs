$ require "common"

@lpp.import "editor/Editor.lh"

#include "iro/StringFuncs.h"

@lpp.import "Profiling.lh"

namespace editor
{

/* ----------------------------------------------------------------------------
 */
b8 Console::init(Editor& editor)
{
  this->editor = &editor;

  // TODO(sushi) if we never wind up changing how this Console gets commands 
  //             then remove this and just get it through editor.
  this->cmd_bus = &editor.cmd_bus;

  text_field.edit.setBuffer(
  {
    .ptr = command_buffer.arr,
    .len = &command_buffer.len,
    .space = s32(command_buffer.capacity()),
  });

  if (!entries.init())
    return false;

  if (!string_buffer.init())
    return false;

  cmd_bus->registerCommand<Console>("Editor.Console.open"_str, this,
    [](Console& self, event::CommandArgs)
    {
      self.is_open = true;
    });

  cmd_bus->registerCommand<Console>("Editor.Console.close"_str, this,
    [](Console& self, event::CommandArgs)
    {
      self.is_open = false;
    });

  cmd_bus->registerCommand<Console>("Editor.Console.toggle"_str, this,
    [](Console& self, event::CommandArgs)
    {
      self.is_open = !self.is_open;
    });

  return true;
}

/* ----------------------------------------------------------------------------
 */
void Console::deinit()
{
  entries.destroy();
  string_buffer.deinit();
}

/* ----------------------------------------------------------------------------
 */
static Color getVTColor(s32 c, const EditorConsoleSkin& skin)
{
  switch (c)
  {
  case 30: return skin.term_colors.black;
  case 90: return skin.term_colors.gray;
  case 31: return skin.term_colors.red;
  case 32: return skin.term_colors.green;
  case 33: return skin.term_colors.yellow;
  case 34: return skin.term_colors.blue;
  case 35: return skin.term_colors.magenta;
  case 36: return skin.term_colors.cyan;
  case 0:
  case 37: return skin.term_colors.white;
  }

  return 0xdeaddead;
}

/* ----------------------------------------------------------------------------
 */
static Color getVerbColor(logging::Verbosity v, const EditorConsoleSkin& skin)
{
  switch (v)
  {
$ local function c(x)
  case logging::Verbosity::$(x): return skin.verbosity_colors.$(x:lower());
$ end
  @c(Trace)
  @c(Debug)
  @c(Info)
  @c(Notice)
  @c(Warn)
  @c(Error)
  @c(Fatal)
$ c = nil
  }
  return 0xdeaddead;
}

/* ----------------------------------------------------------------------------
 */
static String getVerbString(logging::Verbosity v)
{
  switch (v)
  {
$ local function c(x)
  case logging::Verbosity::$(x): return "$(x:lower())"_str;
$ end
  @c(Trace)
  @c(Debug)
  @c(Info)
  @c(Notice)
  @c(Warn)
  @c(Error)
  @c(Fatal)
$ c = nil
  }
  return "???"_str;
}

/* ----------------------------------------------------------------------------
 */
static f32 putEntryPrefix(
    ui::UI& ui,
    vec2f pos,
    f32 verb_width,
    f32 cat_width,
    ConsoleEntry& entry,
    const EditorConsoleSkin& skin)
{
  vec2f size = {};
  ui::TextSkin text_skin = skin.history_text;

  io::SmallBuffer<128> timestamp_buffer;
  io::format(&timestamp_buffer, 
    LocalDate(entry.timestamp,
    "[%y-%m-%d %H:%M:%S]"));

  vec2f timestamp_size = ui.putText(
    Rect::from(0.f, pos.y, 999.f, 999.f),
    String(timestamp_buffer),
    text_skin);

  using enum logging::Verbosity;

  String verb_text = getVerbString(entry.verbosity);
  Color verb_color = getVerbColor(entry.verbosity, skin);

  f32 verb_pos_x = pos.x + timestamp_size.x + 5.f;

  text_skin.color = verb_color;
  vec2f verb_size = ui.putText(
    Rect::from(verb_pos_x, pos.y, 999.f, 999.f),
    verb_text,
    text_skin);

  entry.verbosity_width = verb_size.x;

  f32 cat_pos_x = verb_pos_x + verb_width + 10.f;

  text_skin.color = skin.category_color;
  vec2f cat_size = ui.putText(
    Rect::from(cat_pos_x, pos.y, 999.f, 999.f),
    entry.category->name,
    text_skin);

  entry.category_width = cat_size.x;

  return cat_pos_x + cat_width;
}

/* ----------------------------------------------------------------------------
 */
static void putEntries(
    ui::UI& ui,
    f32 verb_width,
    f32 cat_width,
    Slice<ConsoleEntry> entries,
    const EditorConsoleSkin& skin)
{
  f32 y = 0.f;
  for (ConsoleEntry& entry : entries)
  {
    auto pos = vec2f(0.f, y);

    entry.seen = true;

    // Text skin (color, for now) resets at every entry to prevent 
    // colors from falling through.
    ui::TextSkin text_skin = skin.history_text;
    f32 height = 0.f;

    f32 prefix_width = putEntryPrefix(
      ui, 
      pos, 
      verb_width,
      cat_width,
      entry, 
      skin);

    pos.x += prefix_width + 10.f;

    // Parse the string for terminal codes. Can be extended later. Maybe 
    // we can replace the color stuff with our own rich formatting.
    
    String::Pair chunks = entry.message.splitAtFirst('\e');
    for (;;)
    {
      vec2f chunk_size = 
        ui.putText(
          Rect::from(pos.x, y, ui.getWidth(), 999.f), 
          chunks.first, 
          text_skin);

      pos.x += chunk_size.x;
      height = max(height, chunk_size.y);

      if (isnil(chunks.second))
        break;

      if (chunks.second.startsWith("["_str))
      {
        String coded = chunks.second;

        coded.advance(); // past '['

        s32 num = atoi((char*)coded.ptr);

        text_skin.color = getVTColor(num, skin);

        while (isDecDigit(coded.current()) && !coded.isEmpty())
          coded.advance();

        coded.advance(); // past 'm', probably.
        
        chunks = coded.splitAtFirst('\e');
      }
      else
      {
        chunks = chunks.second.splitAtFirst('\e');
      }
    }

    y += height;
  }
}

/* ----------------------------------------------------------------------------
 */
void Console::placeUI(ui::UI& ui, const EditorSkinDef& editor_skin)
{
  ZoneScopedN("editor::Console::placeUI");

  const EditorConsoleSkin& skin = editor_skin.console;

  f32 bar_height = skin.command_field_height;

  Rect bar_bounds = {};
  bar_bounds.x = 0.f;
  bar_bounds.y = ui.getHeight() - bar_height;
  bar_bounds.w = ui.getWidth();
  bar_bounds.h = bar_height;

  ui::TextFieldResult result = 
    ui.putTextField(
      "console-input"_fid,
      bar_bounds,
      &text_field,
      skin.command_field);

  using enum ui::TextFieldFlag;

  if (result.test(Commit))
  {
    String input = text_field.edit.asStr();

    editor->log.info("> ", input);

    if (input == "help"_str)
    {
      for (event::Command& cmd : cmd_bus->commands)
        editor->log.info("| ", cmd.name);
    }
    else
    {
      switch (cmd_bus->exec(input))
      {
      case event::ExecResult::UnknownCommand:
        editor->log.error("unknown command");
        break;
      }
    }

    text_field.edit.clear();
  }

  if (ui.frame_input.wasKeyPressed(Key::Backquote))
    is_open = !is_open;

  if (is_open)
  {
    Rect box_bounds = {};
    box_bounds.x = 0.f;
    box_bounds.y = ui.getHeight() - bar_height - skin.history_height;
    box_bounds.w = ui.getWidth();
    box_bounds.h = skin.history_height;

    ui.beginGroup(box_bounds);
    {
      ui.putItem(ui.getBounds(), skin.history_background);

      ui.beginScrollGroup(
        "console-scroll"_fid, 
        ui.getBounds().contracted(10.f),
        editor_skin.scroll_bar);

      b8 new_entry = false;
      f32 max_verb_width = 0.f;
      f32 max_cat_width = 0.f;
      for (ConsoleEntry& entry : entries)
      {
        max_verb_width = max(max_verb_width, entry.verbosity_width);
        max_cat_width = max(max_cat_width, entry.category_width);
        if (!entry.seen)
        {
          new_entry = true;
          entry.seen = true;
        }
      }

      putEntries(
        ui, 
        max_verb_width,
        max_cat_width,
        entries.asSlice(), 
        skin);

      ui.endScrollGroup(editor_skin.scroll_bar, new_entry);
    }
    ui.endGroup();
  } // if (is_open)
}

}
