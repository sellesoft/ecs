$ require "common"

#include "iro/Common.h"
#include "iro/Unicode.h"
#include "iro/concurrent/Thread.h"

@lpp.import "editor/docs/DocMgr.lh"
@lpp.import "editor/Skin.defs.lh"
@lpp.import "editor/MenuBar.lh"
@lpp.import "editor/FileWatcherThread.lh"
@lpp.import "editor/FileExplorer.lh"
@lpp.import "editor/docs/ClientInstance.lh"
@lpp.import "editor/Console.lh"

@lpp.import "event/CommandBus.lh"

@lpp.import "ui/UI.lh"
@lpp.import "ui/debug.lh"
@lpp.import "input/InputMgr.lh"
@lpp.import "window/Window.lh"
@lpp.import "graphics/RenderPass.lh"
@lpp.import "build/BuildSystem.lh"
@lpp.import "graphics/Texture.resource.lh"
@lpp.import "asset/AssetMgr.lh"

@lpp.import "graphics/vk.lh"

#include "iro/os/FileWatcher.h"
#include "iro/containers/StackArray.h"

struct BroadcastEventBus;

namespace editor
{

struct BuildThread;
struct FileWatcherThread;

/* ============================================================================
 */
struct EditorLog : logging::Channel
{
  Editor* editor;

  b8 init(Editor* editor) 
  {
    this->editor = editor;
    return true;
  }

  void log(const logging::Entry& entry) override;

  void info(auto&&... args) 
  { 
    logging::Channel::info(&logging::cat_editor, args...); 
  }

  b8 error(auto&&... args) 
  { 
    logging::Channel::error(&logging::cat_editor, args...); 
    return false;
  }

  void warn(auto&&... args)
  {
    logging::Channel::warn(&logging::cat_editor, args...);
  }
};

/* ============================================================================
 */
enum class CursorState
{
  Normal,
  ResizeH,
  ResizeV,
  Cross,
  Grab,
};

/* ============================================================================
 */
struct Editor
{
  EditorLog log;

  InputMgr input;
  Window window;

  // TODO(sushi) the graphics stuff will probably need to moved up a layer, 
  //             somehow.. considering that the debug system shouldn't 
  //             be considered a part of the Editor.
  gfx::Vulkan* vk;
  gfx::ResourceMgr resource_mgr;

  AssetMgr asset_mgr;

  ui::UI ui;

  ui::DebugUI debug_ui;

  b8 debug_ui_enabled;

  EditorSkinDefLink l_skin;
  gfx::TextureLink l_white_texture;
  gfx::TextureLink l_null_texture;

  build::BuildSystem build_system;
  BuildThread* build_thread;

  iro::os::FileWatcher file_watcher;
  FileWatcherThread* watcher_thread;

  // Set when the Editor finishes initializing.
  TimePoint start_time;

  // Marks when the Editor last started a frame.
  TimePoint frame_mark_time;

  DocMgr doc_mgr;

  Console console;

  event::CommandBus cmd_bus;

  // UI elements.
  MenuBar menu_bar;
  FileExplorer file_explorer;

  CursorState cursor_state;

  // The directory the editor started in.
  fs::PathBuffer root_dir;

  BroadcastEventBus* event_bus;

  struct InitParams
  {
    Engine& engine;
    BroadcastEventBus& eventbus;
  };

  b8 init(const InitParams& params);
  void deinit();

  void putUI();

  struct UpdateParams
  {
    BroadcastEventBus& eventbus;
  };
  struct UpdateResult
  {
    // No more calls to update() should occur and the Editor should be 
    // deinitialized.
    b8 should_deinit = false;
  };
  UpdateResult update(const UpdateParams& params);

  b8 render(this Editor& self);

  b8 wantHotReload();

  // Helpers for saving and loading a SourceDataFile from .ecs-cache.
  b8 cacheSourceDataFile(SourceDataFile& file, String path);
  b8 loadCachedSourceDataFile(SourceDataFile* file, String path);
  
  enum class BuildRequestResult
  {
    Failed,
    Success,
  };

  struct BuildRequest
  {
    template<typename T>
    using Callback = void (*)(T, String name, String type, BuildRequestResult);

    fs::PathBuffer name;
    fs::PathBuffer type;

    void* requester;
    Callback<void*> cb;
  };

  Array<BuildRequest> pending_build_requests;
  Array<BuildRequest> active_build_requests;

  template<typename TRequester>
  b8 requestBuild(
      String name, 
      String type,
      TRequester* requester,
      BuildRequest::Callback<TRequester&> callback)
  {
    BuildRequest* req = pending_build_requests.push();

    if (name.len != io::format(&req->name, name))
    {
      log.error("name passed to Editor::requestBuild is too long: ", name);
      pending_build_requests.pop();
      return false;
    }

    if (type.len != io::format(&req->type, type))
    {
      log.error("type passed to Editor::requestBuild is too long: ", type);
      pending_build_requests.pop();
      return false;
    }

    req->requester = requester;
    req->cb = (BuildRequest::Callback<void*>)callback;

    log.info("build requested: '", name, "'");
    return true;
  }

  reflect::Linker getLinker()
  {
    return 
    {
      .resource_mgr = resource_mgr,
      .asset_mgr = asset_mgr,
    };
  }
};

}
