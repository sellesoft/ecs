$ require "common"

#include "iro/fs/fs.h"
#include "iro/fs/File.h"

#include "iro/concurrent/Atomic.h"
#include "iro/concurrent/ConditionVar.h"
#include "iro/concurrent/Mutex.h"

@@lpp.import "editor/Editor.lh"

@@lpp.import "Engine.lh"

@@lpp.import "graphics/RenderTarget.lh"
@@lpp.import "graphics/Texture.defs.lh"
@@lpp.import "graphics/Shader.defs.lh"
@@lpp.import "graphics/Font.defs.lh"

@@lpp.import "asset/CompiledData.lh"

@@lpp.import "build/BuildSystem.lh"

@@lpp.import "reflect/RTR.lh"
@@lpp.import "asset/Linker.lh"

@log.ger(editor, Info)

struct BuildThread
{
  enum class State
  {
    Idle,
    RequestBuild,
    Building,

    BuildSuccess,
    BuildFailed,
  };

  conc::Thread thread;
  conc::Atomic<State> state;
  conc::ConditionVar signal;
  conc::Mutex mutex;
  conc::Atomic<b8> terminate;

  // Cleared before each build.
  // This should not be accessed until the thread is idle.
  build::TargetList built_targets;

  build::BuildSystem* build_system;

  /* --------------------------------------------------------------------------
   */
  b8 init(build::BuildSystem* build_system)
  {
    this->build_system = build_system;

    state.storeRelaxed(State::Idle);
    terminate.storeRelaxed(false);

    signal = conc::ConditionVar::create();
    mutex = conc::Mutex::create();

    built_targets.init();

    thread = conc::Thread::create(this, [](void* opaque) -> void*
    {
      ((BuildThread*)opaque)->worker();
      return nullptr;
    });

    return true;
  }

  /* --------------------------------------------------------------------------
   */
  b8 isIdle() const
  {
    return state.loadSeqCst() == State::Idle;
  }

  /* --------------------------------------------------------------------------
   */
  void requestBuild()
  {
    assert(isIdle());
    built_targets.clear();
    state.storeSeqCst(State::RequestBuild);
    signal.signalOne();
  }

  /* --------------------------------------------------------------------------
   */
  b8 isBuilding() const
  {
    return state.loadSeqCst() == State::Building;
  }

  /* --------------------------------------------------------------------------
   */
  b8 hasResult() const
  {
    State current = state.loadSeqCst();
    return current == State::BuildSuccess || current == State::BuildFailed;
  }

  /* --------------------------------------------------------------------------
   */
  b8 consumeResult()
  {
    State result = state.loadSeqCst();
    assert(result == State::BuildSuccess || result == State::BuildFailed);
    state.storeSeqCst(State::Idle);
    return result == State::BuildSuccess;
  }

  /* --------------------------------------------------------------------------
   */
  void worker()
  {
    for (;;)
    {
      // Sleep until the thread's state is set to RequestBuild or until
      // termination is requested.
      mutex.lock();
      while (state.loadSeqCst() != State::RequestBuild && 
             !terminate.loadSeqCst())
      {
        signal.wait(mutex);
      }
      mutex.unlock();

      if (terminate.loadSeqCst())
        break;

      // If we didn't wake up due to a termination request, then we have to 
      // be in the RequestBuild state.
      assert(state.loadSeqCst() == State::RequestBuild);

      state.storeSeqCst(State::Building);

      b8 success = build_system->build(&built_targets);

      state.storeSeqCst(success? State::BuildSuccess : State::BuildFailed);
    }
  }
};

/* ----------------------------------------------------------------------------
 */
b8 Editor::init(const InitParams& params)
{
  if (!asset_mgr.init(&mem::stl_allocator, "_data"_str))
    return ERROR("failed to initialize AssetMgr\n");

  if (!input.init())
    return ERROR("failed to initialize InputMgr\n");

  if (!Window::initializeBackend())
    return ERROR("failed to initialize Window backend\n");

  if (!window.init(params.engine, "ecs editor"_str, input))
    return ERROR("failed to initialize Window\n");
    
  gfx::Renderer::InitParams renderer_params = 
  {
    .window = window,
    .allocator = mem::stl_allocator,
  };

  if (!renderer.init(renderer_params))
    return ERROR("failed to initialize Renderer\n");

  if (!resource_mgr.init(renderer.vk))
    return ERROR("failed to initialize ResourceMgr\n");

  build::Rule build_rules[] = 
  {
    gfx::getTextureBuildRule(),
    gfx::getShaderBuildRule(),
    gfx::getFontBuildRule(),
    CompiledData::getBuildRule(),
  };

  build::PathBuffer cwd_buffer;
  cwd_buffer.len = fs::cwd(cwd_buffer.asBytesBuffer());
  if (cwd_buffer.len == 0)
    return ERROR("failed to get current working directory\n");
  String cwd = String(cwd_buffer);

  build::PathBuffer compiled_dir_buffer;
  io::formatv(&compiled_dir_buffer, cwd, "/_data"_str);

  build::PathBuffer trash_dir_buffer;
  io::formatv(&trash_dir_buffer, cwd, "/_trash"_str);

  build::BuildSystem::InitParams build_system_params = 
  {
    .source_mount = cwd,
    .compiled_mount = String(compiled_dir_buffer),
    .trash_mount = String(trash_dir_buffer),
    .rules = makeSlice(build_rules),
  };

  if (!build_system.init(build_system_params))
    return ERROR("failed to initialize build system\n");

  build_system.loadAssetList("src/editor/Editor.asset_list"_str);
  build_system.loadAssetList("src/ui/UI.asset_list"_str);

  if (!build_system.build())
    return ERROR("failed to build required Editor assets\n");

  l_skin.name = "assets/skins/Editor"_str;

  linkData(
    "EditorSkinDefLink"_typeid, 
    &l_skin, 
    resource_mgr, 
    asset_mgr);

  l_white_texture.name = "assets/textures/white"_str;

  linkData(
    "gfx::TextureLink"_typeid,
    &l_white_texture,
    resource_mgr,
    asset_mgr);

  l_test_texture.name = "assets/floors/tiles/LightGray"_str;

  linkData(
    "gfx::TextureLink"_typeid,
    &l_test_texture,
    resource_mgr,
    asset_mgr);

  ui::UI::InitParams ui_params = 
  {
    .renderer = renderer,
    .resource_mgr = resource_mgr,
    .asset_mgr = asset_mgr,
    .viewport = Rect::from(0,0,window.size.x,window.size.y),
    .white_texture = l_white_texture.getHandle(),
  };

  if (!ui.init(ui_params))
    return ERROR("failed to init UI\n");

  build_thread = mem::stl_allocator.construct<BuildThread>();
  build_thread->init(&build_system);

  start_time = TimePoint::monotonic();

  return true;
}

/* ----------------------------------------------------------------------------
 */
void Editor::deinit()
{
  // Wait until the device isn't doing anything to avoid errors.
  renderer.waitForDeviceIdle();

  renderer.deinit(&mem::stl_allocator);
  window.deinit();
  input.deinit();

  asset_mgr.deinit();

  build_system.deinit();
}

/* ----------------------------------------------------------------------------
 */
Editor::UpdateResult Editor::update(const UpdateParams& params)
{
  UpdateResult result = {};

  f32 delta = (TimePoint::monotonic() - frame_mark_time).toSeconds();
  frame_mark_time = TimePoint::monotonic();

  static TimePoint last_print = TimePoint::monotonic();

  TimePoint now = TimePoint::monotonic();
  if ((now - last_print).toMilliseconds() < 10)
    return result;

  // Prepare input state for this frame.
  input.update();

  Window::UpdateResult window_result = window.update(input);

  if (window_result.closed)
  {
    result.should_deinit = true;
    return result;
  }

  if (window_result.size_changed)
    renderer.onWindowResized(vec2u(window.size));

  InputState ui_input;
  input.cloneInputState(&ui_input);

  static io::Memory mem;
  if (!mem.isOpen())
    mem.open();

  ui::UI::FrameParams ui_frame_params = 
  {
    .input = ui_input,
    .viewport = Rect::from(vec2f(0,0), vec2f(window.size)),
  };

  static u32 depth_limit = 1;

  ui.beginFrame(ui_frame_params);
  {
    const EditorSkinDef& skin = *l_skin;

    f32 time = (TimePoint::monotonic() - start_time).toSeconds();

    Rect button_bounds = {};
    button_bounds.w = 50;
    button_bounds.h = 100;

    button_bounds.x = 10.f;
      // (cos(time) + 1) / 2.f * (window.size.x - button_bounds.w);

    button_bounds.y = 10.f;
      // (sin(time) + 1) / 2.f * (window.size.y - button_bounds.h);

    if (ui.putButton(
          "test"_fid,
          button_bounds,
          "+ depth"_str,
          skin.button))
    {
      depth_limit += 1;
    }

    if (ui.putButton(
          "-depth"_fid,
          {button_bounds.x + button_bounds.w, button_bounds.y, 
           button_bounds.w, button_bounds.h},
          "- depth"_str,
          skin.button))
    {
      if (depth_limit > 1)
        depth_limit -= 1;
    }

    if (build_thread->isBuilding())
    {
      ui.putText(Rect::from(0,0,10,10), "building..."_str, skin.text);
    }

    ui.putQuad(
      {110.f, 10.f, 100.f, 100.f}, 
      l_test_texture.getHandle(),
      0xffffffff);

    ui.beginScrollGroup(
      "ui_print"_fid, {10.f, 110.f, 500.f, 500.f}, skin.scroll_bar);
    ui.putTextItem({0.f, 0.f, 0.f, 0.f}, String(mem), skin.button.normal);
    ui.endScrollGroup(skin.scroll_bar);

    static ui::TextFieldState text_field_state;

    ui.putTextField("text_test"_fid, {300.f, 10.f, 100.f, 15.f}, 
      {buffer, &buffer_len, 255}, skin.text_field);

    io::StaticBuffer<64> fps_buffer;
    io::format(&fps_buffer, 1.f / delta);
    ui.putText(Rect::from(440.f, 10.f, 10.f, 10.f), String(fps_buffer), 
      skin.text);
  }

  mem.clear();
  rtr::prettyPrint(&mem, *this,
    { .disable_color = true, .deref_ptrs = true, .depth_limit = depth_limit });

  ui.endFrame();

  if (!window_result.size_changed && renderer.beginFrame())
  {
    gfx::RenderTarget swapchain_target;
    if (!renderer.getSwapchainRenderTarget(&swapchain_target))
      ERROR("failed to get swapchain render target\n");

    if (renderer.beginRenderPass(
          {0,0}, 
          vec2u(window.size), 
          swapchain_target,
          0x000000ff))
    {
      ui.render(renderer, Rect::from({0,0}, vec2f(window.size)));
      renderer.endRenderPass();
    }

    renderer.endFrame();

    if (!renderer.submitQueue())
      ERROR("failed to submit queue\n");

    if (!renderer.present())
      ERROR("failed to present frame\n");
  }

  if (input.real_state.wasKeyPressed(Key::B))
  {
    INFO("---------------------------------------------------\n",
         "  build requested by keybind...\n");

    if (build_thread->isIdle())
      build_thread->requestBuild();
  }

  if (build_thread->hasResult())
  {
    if (build_thread->consumeResult())
    {
      renderer.waitForDeviceIdle();

      for (build::Target& built : build_thread->built_targets)
      {
        INFO("reloading ", built, "...\n");
        if (Asset* asset = asset_mgr.tryReloadAsset(built.name, built.type))
        {
          if (built.kind == build::TargetKind::CompiledData)
          {
            auto* compiled = (CompiledData*)asset->data;
            compiled->fixPointers();

            INFO("relinking ", built, "...\n");
            
            linkData(
              compiled->type,
              compiled->data.ptr.get(),
              resource_mgr,
              asset_mgr);
          }

          resource_mgr.notifyAssetChanged(built.name, built.type);
        }
      }
    }
  }

  return result;
}
