$ require "common"

#include "iro/fs/fs.h"
#include "iro/fs/File.h"

#include "iro/concurrent/Atomic.h"
#include "iro/concurrent/ConditionVar.h"
#include "iro/concurrent/Mutex.h"
#include "iro/print.h"

@lpp.import "editor/Editor.lh"
@lpp.import "editor/Editor.events.lh"

@lpp.import "ui/debug.lh"

@lpp.import "Engine.lh"

@lpp.import "graphics/RenderTarget.lh"
@lpp.import "graphics/Texture.defs.lh"
@lpp.import "graphics/Shader.defs.lh"
@lpp.import "graphics/Font.defs.lh"

@lpp.import "reflect/CompiledData.lh"

@lpp.import "build/BuildSystem.lh"

@lpp.import "reflect/rtr.lh"
@lpp.import "reflect/Linker.lh"

@lpp.import "Profiling.lh"

@log.import

$ local function logerr(...) return log.error("editor", ...) end
$ local function loginfo(...) return log.info("editor", ...) end

namespace editor
{

/* ============================================================================
 */
struct BuildThread
{
  enum class State
  {
    Idle,
    RequestBuild,
    Building,

    BuildSuccess,
    BuildFailed,
  };

  conc::Thread thread;
  conc::Atomic<State> state;
  conc::ConditionVar signal;
  conc::Mutex mutex;
  conc::Atomic<b8> terminate;

  // Cleared before each build.
  // This should not be accessed until the thread is idle.
  build::TargetList built_targets;

  build::BuildSystem* build_system;

  /* --------------------------------------------------------------------------
   */
  b8 init(build::BuildSystem* build_system)
  {
    this->build_system = build_system;

    state.storeRelaxed(State::Idle);
    terminate.storeRelaxed(false);

    signal = conc::ConditionVar::create();
    mutex = conc::Mutex::create();

    built_targets.init();

    thread = conc::Thread::create(this, [](void* opaque) -> void*
    {
      ((BuildThread*)opaque)->worker();
      return nullptr;
    });

    return true;
  }

  /* --------------------------------------------------------------------------
   */
  void deinit()
  {
    terminate.storeSeqCst(true);
    signal.signalOne();
    thread.join();

    built_targets.deinit();
    thread = nil;
    signal.destroy();
    mutex.destroy();
  }

  /* --------------------------------------------------------------------------
   */
  b8 isIdle() const
  {
    return state.loadSeqCst() == State::Idle;
  }

  /* --------------------------------------------------------------------------
   */
  void requestBuild()
  {
    assert(isIdle());
    built_targets.clear();
    state.storeSeqCst(State::RequestBuild);
    signal.signalOne();
  }

  /* --------------------------------------------------------------------------
   */
  b8 isBuilding() const
  {
    return state.loadSeqCst() == State::Building;
  }

  /* --------------------------------------------------------------------------
   */
  b8 hasResult() const
  {
    State current = state.loadSeqCst();
    return current == State::BuildSuccess || current == State::BuildFailed;
  }

  /* --------------------------------------------------------------------------
   */
  b8 consumeResult()
  {
    State result = state.loadSeqCst();
    assert(result == State::BuildSuccess || result == State::BuildFailed);
    state.storeSeqCst(State::Idle);
    return result == State::BuildSuccess;
  }

  /* --------------------------------------------------------------------------
   */
  void worker()
  {
    for (;;)
    {
      // Sleep until the thread's state is set to RequestBuild or until
      // termination is requested.
      mutex.lock();
      while (state.loadSeqCst() != State::RequestBuild && 
             !terminate.loadSeqCst())
      {
        signal.wait(mutex);
      }
      mutex.unlock();

      if (terminate.loadSeqCst())
        break;

      // If we didn't wake up due to a termination request, then we have to 
      // be in the RequestBuild state.
      assert(state.loadSeqCst() == State::RequestBuild);

      state.storeSeqCst(State::Building);

      b8 success = build_system->build(&built_targets);

      state.storeSeqCst(success? State::BuildSuccess : State::BuildFailed);
    }
  }
};

/* ----------------------------------------------------------------------------
 */
void EditorLog::log(const logging::Entry& entry)
{
  editor->console.pushEntry(entry);
  logging::get()->chan.log(entry);
}

/* ----------------------------------------------------------------------------
 */
b8 Editor::init(const InitParams& params)
{
$ local function initSubSystem(name, code)
  {
    auto start = TimePoint::monotonic();
    b8 success = false;

    $(code)

    if (!success)
      return log.error("failed to initialize $(name)"_str);

    log.info("initialized ", tcolor::magenta, "$(name)", tcolor::reset, 
             " in ", 
             tcolor::green, WithUnits(TimePoint::monotonic() - start), 
             tcolor::reset);
  }
$ end

  if (!log.init(this))
    return false;

  @initSubSystem(CommandBus,
  {
    success = cmd_bus.init();
  })

  @initSubSystem(Console,
  {
    success = console.init(*this);
  })

  @initSubSystem(AssetMgr,
  {
    success = asset_mgr.init(&mem::stl_allocator, "_data"_str);
  });

  @initSubSystem(Input,
  {
    success = input.init();
  })

  @initSubSystem(Window backend,
  {
    success = Window::initializeBackend();
  })

  @initSubSystem(Window,
  {
    success = window.init(params.engine, "ecs editor"_str, input);
  })

  // window.hideCursor();

  @initSubSystem(Vulkan,
  {
    gfx::vk::CreateParams vk_create_params = 
    {
      .allocator = &mem::stl_allocator,
      .window = window,
    };

    vk = gfx::vk::create(vk_create_params);

    success = vk != nullptr;
  })

  @initSubSystem(gfx::ResourceMgr,
  {
    success = resource_mgr.init(vk);
  })

  fs::PathBuffer cwd_buffer;
  cwd_buffer.len = fs::cwd(cwd_buffer.asBytesBuffer());
  if (cwd_buffer.len == 0)
    return log.error("failed to get current working directory");
  String cwd = String(cwd_buffer);

  @initSubSystem(BuildSystem,
  {
    build::Rule build_rules[] = 
    {
      gfx::getTextureBuildRule(),
      gfx::getShaderBuildRule(),
      gfx::getFontBuildRule(),
      reflect::CompiledData::getBuildRule(),
    };

    fs::PathBuffer compiled_dir_buffer;
    io::formatv(&compiled_dir_buffer, cwd, "/_data"_str);

    fs::PathBuffer trash_dir_buffer;
    io::formatv(&trash_dir_buffer, cwd, "/_trash"_str);

    build::BuildSystem::InitParams build_system_params = 
    {
      .source_mount = cwd,
      .compiled_mount = String(compiled_dir_buffer),
      .trash_mount = String(trash_dir_buffer),
      .rules = makeSlice(build_rules),
      .log = &log,
    };

    success = build_system.init(build_system_params);
  })

  log.info("loading and building asset lists...");

  build_system.loadAssetList("src/editor/Editor.asset_list"_str);
  build_system.loadAssetList("src/ui/UI.asset_list"_str);

  if (!build_system.build())
    return log.error("failed to build required Editor assets");

  log.info("linking Editor skin def...");

  reflect::Linker linker = { resource_mgr, asset_mgr };

  linker.link(
    "EditorSkinDefLink"_typeid,
    "assets/skins/Editor"_str,
    &l_skin);

  linker.link(
    "gfx::TextureLink"_typeid,
    "assets/textures/white"_str,
    &l_white_texture);

  ui::UI::InitParams ui_params = 
  {
    .vk = *vk,
    .linker = linker,
    .viewport = Rect::from(0,0,window.size.x,window.size.y),
    .white_texture = l_white_texture.getHandle(),
  };

  @initSubSystem(UI,
  {
    success = ui.init(ui_params);
  })

  @initSubSystem(UI (debug),
  {
    success = debug_ui.init(ui_params);
  })

  log.info("starting build thread...");

  build_thread = mem::stl_allocator.construct<BuildThread>();
  build_thread->init(&build_system);

  log.info("starting file watcher thread...");

  if (!file_watcher.init())
    return log.error("failed to initialize file watcher");

  fs::PathBuffer assets_path;
  io::formatv(&assets_path, cwd, "/assets");

  file_watcher.addWatch(
  {
    .path = String(assets_path),
    .events = os::WatchEventFlags::all(),
    .recursive = true,
  });

  watcher_thread = mem::stl_allocator.construct<FileWatcherThread>();
  watcher_thread->init(&file_watcher);

  menu_bar.init(this, params.eventbus);

  MenuBarTab::Option test_opts[] = 
  {
    { "A"_str, "print A"_str },
    { "B"_str, "print B"_str },
    { "C"_str, "print C"_str },
  };

  menu_bar.registerTab("test"_str, makeSlice(test_opts));

  cmd_bus.registerCommand<Editor>("print"_str, this,
    [](Editor& self, event::CommandArgs args)
    {
      println(args[0]); 
    });

  doc_mgr.init(*this);

  file_explorer.onAllocated();
  file_explorer.changeDir(cwd);

  start_time = TimePoint::monotonic();

  return true;
}

/* ----------------------------------------------------------------------------
 */
void Editor::deinit()
{
  // Wait until the device isn't doing anything to avoid errors.
  gfx::vk::waitForDeviceIdle(vk);

  doc_mgr.deinit();
  menu_bar.deinit();
  cmd_bus.deinit();
  console.deinit();

  ui.deinit(*vk);

  window.deinit();
  input.deinit();

  resource_mgr.deinit();
  asset_mgr.deinit();

  build_thread->deinit();
  build_system.deinit();
  mem::stl_allocator.free(build_thread);

  watcher_thread->deinit();
  file_watcher.deinit();
  mem::stl_allocator.free(watcher_thread);

  gfx::vk::destroy(vk, &mem::stl_allocator);
}

/* ----------------------------------------------------------------------------
 */
b8 Editor::render(this Editor& self)
{
  ZoneScopedN("Editor::render");

  using namespace gfx;

  // This failing does not necessarily indicate an error, it could be due to
  // the swapchain being out of date. If it is an error, Vulkan will print
  // something.
  if (!vk::beginFrame(self.vk))
    return false;

  self.doc_mgr.render(*self.vk);

  RenderTarget swapchain_target;
  if (!vk::getSwapchainRenderTarget(self.vk, &swapchain_target))
    return self.log.error("failed to get swapchain render target");

  RenderPass pass;
  if (!gfx::vk::beginRenderPass(
        self.vk,
        &pass,
        swapchain_target,
        {0, 0},
        vec2u(self.window.size),
        0x000000ff))
    return false;

  self.ui.render(pass, Rect::from({0,0}, vec2f(self.window.size)));
  self.debug_ui.render(pass, Rect::from({0,0}, vec2f(self.window.size)));

  vk::endRenderPass(self.vk);

  vk::endFrame(self.vk);

  if (!vk::submitQueue(self.vk))
    return self.log.error("failed to submit queue");

  if (!vk::present(self.vk))
    return self.log.error("failed to present frame");

  return true;
}


/* ----------------------------------------------------------------------------
 */
Editor::UpdateResult Editor::update(const UpdateParams& params)
{
  FrameMark;

  ZoneScopedN("Editor::update");

  UpdateResult result = {};

  f32 delta = (TimePoint::monotonic() - frame_mark_time).toSeconds();
  frame_mark_time = TimePoint::monotonic();

  // Prepare input state for this frame.
  input.update();

  Window::UpdateResult window_result = window.update(input);

  if (window_result.closed)
  {
    result.should_deinit = true;
    return result;
  }

  if (window_result.size_changed)
    gfx::vk::onWindowResized(vk);

  if (input.real_state.wasKeyPressed(Key::V))
  {
    if (input.real_state.isKeyDown(Key::LCtrl))
      cmd_bus.exec("Editor.DocMgr.open ClientInstance vl"_str);
    else
      cmd_bus.exec("Editor.DocMgr.open ClientInstance vr"_str);
  }
  if (input.real_state.wasKeyPressed(Key::H))
  {
    if (input.real_state.isKeyDown(Key::LCtrl))
      cmd_bus.exec("Editor.DocMgr.open ClientInstance ht"_str);
    else
      cmd_bus.exec("Editor.DocMgr.open ClientInstance hb"_str);
  }

  {
    ZoneScopedN("Doc update");
    doc_mgr.update();
  }

  InputState ui_input;
  input.cloneInputState(&ui_input);

  Rect ui_viewport = Rect::from(vec2f(0,0), vec2f(window.size));

  ui::UI::FrameParams ui_frame_params = 
  {
    .input = ui_input,
    .viewport = ui_viewport,
  };

  ui.beginFrame(ui_frame_params);
  {
    ZoneScopedN("Editor::update UI");

    cursor_state = CursorState::Normal;

    const EditorSkinDef& skin = *l_skin;
  
    Rect doc_bounds = {};
    doc_bounds.x = 0.f;
    doc_bounds.y = skin.menu_bar.height;
    doc_bounds.w = ui.getWidth();
    doc_bounds.h = 
      ui.getHeight() - 
      (skin.menu_bar.height + skin.console.command_field_height);

    // Place all open documents.
    ui.beginGroup(doc_bounds);
    doc_mgr.placeUI(ui, skin);
    ui.endGroup();
  
    // Place the console and menu bar over everything.
    console.placeUI(ui, skin);
    menu_bar.placeUI(ui, skin);

    ui.pushLayer(
      "cursor-layer"_fid, 
      ui.getBounds(), 
      ui::LayerFlag::TopMost,
      ui::GroupScissor::None);
    {
      ui::ItemSkin cursor_skin;
      cursor_skin.texture = skin.cursor.texture;
      cursor_skin.color = 0xffffffff;

      vec2f cursor_pos = input.real_state.getCursorPos();

      switch (cursor_state)
      {
$ local function c(x, y) 
      case CursorState::$(x): 
        cursor_skin.uv = skin.cursor.$(y).uv;
        cursor_pos -= vec2f(skin.cursor.$(y).hot_spot);
        break;
$ end
      @c(Normal, normal);
      @c(ResizeH, resize_h);
      @c(ResizeV, resize_v);
      @c(Cross, cross);
      @c(Grab, grab);
      }

      ui.putItem(
        Rect::from(cursor_pos.x, cursor_pos.y, 16, 16), 
        cursor_skin);
    }
    ui.popLayer();
  }
  ui.endFrame();

  // debug_ui.debug(ui, ui_input, ui_viewport);

  if (!window_result.size_changed)
    render();

  if (input.real_state.wasKeyPressed(Key::B) &&
      input.real_state.isKeyDown(Key::LCtrl))
  {
    log.info("---------------------------------------------------\n",
             "  build requested by keybind...");

    if (build_thread->isIdle())
      build_thread->requestBuild();
  }

  if (build_thread->hasResult())
  {
    if (build_thread->consumeResult())
    {
      gfx::vk::waitForDeviceIdle(vk);

      b8 asset_reloaded = false;
      for (build::Target& built : build_thread->built_targets)
      {
        log.info("reloading ", built, "...");
        if (Asset* asset = asset_mgr.tryReloadAsset(built.name, built.type))
        {
          asset_reloaded = true;
          if (built.kind == build::TargetKind::CompiledData)
          {
            auto* compiled = (reflect::CompiledData*)asset->data;
            compiled->fixPointers();

            log.info("relinking ", built, "...");
            
            reflect::linkData(
              compiled->type,
              compiled->data.ptr.get(),
              resource_mgr,
              asset_mgr);
          }

          resource_mgr.notifyAssetChanged(built.name, built.type);
        }
      }

      if (asset_reloaded)
        reflect::linkData(
          "EditorSkinDefLink"_typeid, 
          &l_skin, 
          resource_mgr, 
          asset_mgr);
    }
  }

  if (watcher_thread->readyToConsume())
  {
    for (auto& ev : watcher_thread->consumeEvents())
    {
      using EKind = FileWatcherThread::Event::Kind;

      switch (ev.kind)
      {
      case EKind::Created:
        params.eventbus.raise<FileCreatedEvent>({ .path = ev.path0 });
        break;
      case EKind::Modified:
        params.eventbus.raise<FileModifiedEvent>({ .path = ev.path0 });
        break;
      }
    }
  }

  if (input.real_state.wasKeyPressed(Key::O))
    doc_mgr.cacheDocState();

  if (input.real_state.wasKeyPressed(Key::I))
    doc_mgr.loadCachedDocState();

  return result;
}

/* ----------------------------------------------------------------------------
 */
b8 Editor::wantHotReload()
{
  if (input.real_state.wasKeyPressed(Key::R) && 
      input.real_state.isKeyDown(Key::RCtrl))
    return true;

  return false;
}

/* ----------------------------------------------------------------------------
 */
b8 Editor::cacheSourceDataFile(SourceDataFile& sfile, String path)
{
  if (!fs::path::exists(".ecs-cache"_str))
    fs::mkdir(".ecs-cache"_str, false);

  if (!fs::path::isDirectory(".ecs-cache"_str))
    return log.error("'.ecs-cache' already exists and is not a directory");

  fs::PathBuffer cache_path_buffer;
  io::formatv(&cache_path_buffer, ".ecs-cache/", path);

  auto file = fs::File::createForTruncatedWriting(String(cache_path_buffer));
  if (isnil(file))
    return log.error(
      "failed to open file at '", String(cache_path_buffer), "' to cache "
      "source data file\n");

  sfile.dump(&file);

  file.close();

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 Editor::loadCachedSourceDataFile(SourceDataFile* sfile, String path)
{
  fs::PathBuffer cache_path_buffer;
  io::formatv(&cache_path_buffer, ".ecs-cache/", path);

  // If the cached file doesn't exist, quickly return false. If the file is 
  // needed then the caller should log an error.
  if (!fs::path::exists(String(cache_path_buffer)))
    return false;

  if (!SourceDataFile::from(sfile, String(cache_path_buffer)))
    return log.error(
      "failed to load cached source data file from '", path, "'");

  return true;
}

}
