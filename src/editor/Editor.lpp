$ require "common"

#include "iro/fs/fs.h"
#include "iro/fs/File.h"

@@lpp.import "editor/Editor.lh"

@@lpp.import "Engine.lh"

@@lpp.import "graphics/RenderTarget.lh"
@@lpp.import "graphics/Texture.defs.lh"
@@lpp.import "graphics/Shader.defs.lh"
@@lpp.import "graphics/Font.defs.lh"

@@lpp.import "asset/CompiledData.lh"

@@lpp.import "build/BuildSystem.lh"

@@lpp.import "reflect/RTR.lh"

@log.ger(editor, Info)

/* ----------------------------------------------------------------------------
 */
b8 Editor::init(const InitParams& params)
{
  if (!input.init())
    return ERROR("failed to initialize InputMgr\n");

  if (!Window::initializeBackend())
    return ERROR("failed to initialize Window backend\n");

  if (!window.init(params.engine, "ecs editor"_str, input))
    return ERROR("failed to initialize Window\n");
    
  gfx::Renderer::InitParams renderer_params = 
  {
    .window = window,
    .allocator = mem::stl_allocator,
  };

  if (!renderer.init(renderer_params))
    return ERROR("failed to initialize Renderer\n");

  build::Rule build_rules[] = 
  {
    gfx::getTextureBuildRule(),
    gfx::getShaderBuildRule(),
    gfx::getFontBuildRule(),
    CompiledData::getBuildRule(),
  };

  build::PathBuffer cwd_buffer;
  cwd_buffer.len = fs::cwd(cwd_buffer.asBytesBuffer());
  if (cwd_buffer.len == 0)
    return ERROR("failed to get current working directory\n");
  String cwd = String(cwd_buffer);

  build::PathBuffer compiled_dir_buffer;
  io::formatv(&compiled_dir_buffer, cwd, "/_data"_str);

  build::BuildSystem::InitParams build_system_params = 
  {
    .source_mount = cwd,
    .compiled_mount = String(compiled_dir_buffer),
    .rules = makeSlice(build_rules),
  };

  if (!build_system.init(build_system_params))
    return ERROR("failed to initialize build system\n");

  build_system.buildAssetList("src/editor/Editor.asset_list"_str);
  build_system.buildAssetList("src/ui/UI.asset_list"_str);

  Asset* asset = params.engine.assetmgr.loadAssetFromDisk(
      "_data/assets/skins/Editor.skin.data"_str);

  rtr::prettyPrint(*asset);

  return true;
}

/* ----------------------------------------------------------------------------
 */
void Editor::deinit()
{
  // Wait until the device isn't doing anything to avoid errors.
  renderer.waitForDeviceIdle();

  renderer.deinit(&mem::stl_allocator);
  window.deinit();
  input.deinit();

  build_system.deinit();
}

/* ----------------------------------------------------------------------------
 */
Editor::UpdateResult Editor::update(const UpdateParams& params)
{
  UpdateResult result = {};

  static TimePoint last_print = TimePoint::monotonic();

  TimePoint now = TimePoint::monotonic();
  if ((now - last_print).toMilliseconds() < 10)
    return result;

  // Prepare input state for this frame.
  input.update();

  Window::UpdateResult window_result = window.update(input);

  if (window_result.closed)
  {
    result.should_deinit = true;
    return result;
  }

  if (window_result.size_changed)
    renderer.onWindowResized(vec2u(window.size));

  if (!window_result.size_changed && renderer.beginFrame())
  {
    gfx::RenderTarget swapchain_target;
    if (!renderer.getSwapchainRenderTarget(&swapchain_target))
      ERROR("failed to get swapchain render target\n");

    if (renderer.beginRenderPass(
          {0,0}, 
          vec2u(window.size), 
          swapchain_target,
          0x000000ff))
    {
      
      renderer.endRenderPass();
    }

    renderer.endFrame();

    if (!renderer.submitQueue())
      ERROR("failed to submit queue\n");

    if (!renderer.present())
      ERROR("failed to present frame\n");
  }

  if (input.real_state.wasKeyPressed(Key::B))
    build_system.build();

  return result;
}
