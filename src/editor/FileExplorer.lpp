$ require "common"

@lpp.import "editor/FileExplorer.lh"
@lpp.import "editor/Skin.defs.lh"
@lpp.import "ui/UI.lh"

#include "iro/fs/fs.h"
#include "iro/fs/Dir.h"
#include "iro/sort.h"

#include "string.h"

@log.import

namespace editor
{

/* ----------------------------------------------------------------------------
 */
b8 FileExplorer::init()
{
  fs::PathBuffer cwd_buffer;
  cwd_buffer.len = fs::cwd(cwd_buffer.asBytesBuffer());
  if (cwd_buffer.len == 0)
    return @log.error(editor, "FileExplorer failed to get cwd on init\n");

  changeDir(String(cwd_buffer));

  return true;
}

/* ----------------------------------------------------------------------------
 */
static s32 entrySort(const DirEntry& l, const DirEntry& r)
{
  // Directories come before files.
  if (l.kind < r.kind)
    return 1;
  if (l.kind > r.kind)
    return -1;

  // TODO(sushi) natural sorting for numbers.

  return strcmp((char*)l.name.arr, (char*)r.name.arr);
}

/* ----------------------------------------------------------------------------
 */
void FileExplorer::changeDir(String path) 
{
  if (!fs::path::exists(path))
  {
    @log.warn(editor, 
      "attempt to set FileExplorer to non-existant dir '", path, "'\n");
    return;
  }

  if (!fs::path::isDirectory(path))
  {
    @log.warn(editor, 
      "FileExplorer::changeDir: '", path, "' is not a directory\n");
    return;
  }

  entries.clear();
  String cd = fs::path::canonicalize(&current_dir, path);

  fs::Dir hcd = fs::Dir::open(cd);
  if (isnil(hcd))
  {
    @log.error(editor, "FileExplorer::changeDir: "
          "failed to open dir '", cd, "' for entry caching\n");
    return;
  }
  defer { hcd.close(); };

  for (;;)
  {
    fs::PathBuffer entry_name;
    entry_name.len = hcd.next(entry_name.asBytesBuffer());
    if (entry_name.len == 0)
      break;

    if (entry_name.len == -1)
    {
      @log.error(editor, 
        "FileExplorer::changeDir encountered an error while "
        "caching dir entries\n");
      return;
    }

    fs::PathBuffer full_path;
    io::formatv(&full_path, String(current_dir), '/', String(entry_name));

    DirEntry* ent = entries.push();
    io::format(&ent->name, String(entry_name));

    if (fs::path::isRegularFile(String(full_path)))
      ent->kind = DirEntry::Kind::File;
    else if (fs::path::isDirectory(String(full_path)))
      ent->kind = DirEntry::Kind::Directory;
    else
      ent->kind = DirEntry::Kind::Unknown;
  }

  quickSort(entries.begin(), entries.end(), entrySort);
}

/* ----------------------------------------------------------------------------
 */
void FileExplorer::placeUI(ui::UI& ui, const EditorSkinDef& skin)
{
  f32 y = 0.f;

  ui.beginScrollGroup(
    "file-explorer-scroll"_fid, ui.getBounds(), skin.scroll_bar);

  for (DirEntry& ent : entries)
  {
    Rect entry_bounds = Rect::from(
      0.f, y, ui.getWidth(), 15.f);

    if (String(ent.name) == "."_str)
      continue;

    const ui::ButtonSkin* button_skin = ent.kind == DirEntry::Kind::Directory
      ? &skin.filex.dir_button
      : &skin.filex.file_button;

    if (ui.putButton(
          ui.generateIdFromPointer(&ent),
          entry_bounds, 
          String(ent.name), 
          *button_skin))
    {
      if (ent.kind == DirEntry::Kind::Directory)
      {
        fs::PathBuffer full_path;
        io::formatv(&full_path, String(current_dir), '/', String(ent.name));

        changeDir(String(full_path));
      }
    }

    y += 15.f;
  }

  ui.endScrollGroup(skin.scroll_bar);
}


}
