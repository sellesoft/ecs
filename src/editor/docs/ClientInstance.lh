/*
 *  An instance of a game client owned by the Editor. 
 *  
 *  The idea is that the Editor will be able to create multiple of these
 *  to easily simulate multiple Clients being connected to a Server.
 */

$ require "common"

@lpp.import "editor/Doc.lh"
@lpp.import "game/client/Client.lh"
@lpp.import "graphics/Texture.lh"
@lpp.import "input/InputState.lh"

#include "iro/concurrent/Mutex.h"
#include "iro/concurrent/Thread.h"
#include "iro/concurrent/ConditionVar.h"
#include "iro/concurrent/Atomic.h"

struct WindowResized;

namespace gfx
{
struct Vulkan;
struct RenderPass;
}

namespace editor
{

struct ServerInstance;
struct ClientInstance;

/* ============================================================================
 */
struct ClientThread
{
  enum class State
  {
    Idle,

    Running,
    Paused,

    Updating,

    Stopping,
  };

  Client client;
  vec2f viewport_size;
  InputState input;

  conc::Thread thread;
  conc::Atomic<State> state;
  conc::ConditionVar signal;
  conc::Mutex mutex;
  conc::Atomic<b8> terminate;
  conc::Atomic<b8> new_frame;

  conc::Mutex update_mutex;

  b8 init(ClientInstance& cli);
  void deinit(ClientInstance& cli);

  void resetClient(ClientInstance& cli);

  void pause();
  void unpause();

  b8 render(gfx::Vulkan& vk, gfx::RenderTarget& target);

  void worker();

  b8 isPaused() const
  {
    return state.loadSeqCst() == State::Paused;
  }
};

/* ============================================================================
 */
/// An [[editor_document]] that controls an instance of a game client.
struct ClientInstance : Doc
{
  using S = ClientInstance;

  ClientThread thread;

  ServerInstance* connected_server;

  net::MessageBuffer offline_packet_out;
  net::MessageBuffer offline_packet_in;

  gfx::Texture client_render;
  vec2u client_render_size;
  vec2f ui_size;

  void onOpen() override { init(); }
  void onClose() override { deinit(); }

  b8 init(this S& self);
  void deinit();

  b8 resetClient(this ClientInstance& self);

  void update() override;
  void render(gfx::Vulkan& vk) override;

  void placeUI(ui::UI& ui, const EditorSkinDef& skin) override;

  void notifyAssetChanged(String name, String type);
};

}
