$ require "common"

#include "iro/print.h"

@lpp.import "editor/docs/ClientInstance.lh"
@lpp.import "editor/docs/ServerInstance.lh"

@lpp.import "editor/Editor.lh"
@lpp.import "graphics/vk.lh"
@lpp.import "window/Window.events.lh"

@lpp.import "Profiling.lh"

@log.import

namespace editor
{

/* ----------------------------------------------------------------------------
 */
static b8 handleOfflinePacketSend(
    ClientInstance& self, 
    net::Source source,
    void* data,
    u16 len)
{
  if (self.connected_server == nullptr)
    return false;

  self.offline_packet_out.clear();
  self.offline_packet_out.write((u8*)data, len);

  @log.info(editor, "client send packet: ", data, ' ', len, '\n');
  return true;
}

/* ----------------------------------------------------------------------------
 */
static b8 handleOfflinePacketGet(
    ClientInstance& self, 
    net::Source source,
    net::Fragment& fragment)
{
  if (self.offline_packet_in.len == 0)
    return false;

  mem::copy(
    fragment.arr, 
    self.offline_packet_in.arr, 
    self.offline_packet_in.len);
  fragment.len = self.offline_packet_in.len;

  @log.info(editor, "client got a packet of size ", fragment.len, '\n');

  self.offline_packet_in.clear();

  return true;
}

/* ----------------------------------------------------------------------------
 */
static b8 initClient(ClientInstance& self)
{
  reflect::Linker linker = 
  { 
    .resource_mgr = self.editor->resource_mgr,
    .asset_mgr = self.editor->asset_mgr,
  };

  Client::InitParams client_params = 
  {
    .vk = *self.editor->vk,
    .linker = linker,
  };

  if (!self.thread.client.init(client_params))
    return @log.error(editor, "failed to initialize a client instance\n");

  self.thread.client.netmgr.registerOfflinePacketHandler(
    &self,
    handleOfflinePacketSend,
    handleOfflinePacketGet);

  self.thread.client.connectToServer(net::Address::createOffline());

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 ClientThread::init(ClientInstance& cli)
{
  if (!initClient(cli))
    return false;

  state.storeRelaxed(State::Idle);
  terminate.storeRelaxed(false);
  new_frame.storeRelaxed(false);

  signal = conc::ConditionVar::create();
  mutex = conc::Mutex::create();

  update_mutex = conc::Mutex::create();

  thread = conc::Thread::create(this, [](void* opaque) -> void*
  {
    ((ClientThread*)opaque)->worker();
    return nullptr;
  });

  return true;
}

/* ----------------------------------------------------------------------------
 */
void ClientThread::deinit(ClientInstance& cli)
{
  terminate.storeSeqCst(true);
  pause();
  signal.signalOne();
  thread.join();

  thread = nil;
  signal.destroy();
  mutex.destroy();

  client.deinit(*cli.editor->vk);
}

/* ----------------------------------------------------------------------------
 */
void ClientThread::pause()
{
  if (state.loadSeqCst() != State::Paused)
    state.storeSeqCst(State::Paused);
}

/* ----------------------------------------------------------------------------
 */
void ClientThread::unpause()
{
  if (state.loadSeqCst() != State::Running)
  {
    state.storeSeqCst(State::Running);
    signal.signalOne();
  }
}

/* ----------------------------------------------------------------------------
 */
void ClientThread::resetClient(ClientInstance& cli)
{
  update_mutex.lock();
  defer { update_mutex.unlock(); };

  client.deinit(*cli.editor->vk);

  if (!initClient(cli))
  {
    state.storeRelaxed(State::Idle);
    return;
  }
}

/* ----------------------------------------------------------------------------
 */
void ClientThread::worker()
{
  for (;;)
  {
    mutex.lock();
    while (state.loadSeqCst() != State::Running &&
           !terminate.loadSeqCst())
    {
      signal.wait(mutex);
    }
    mutex.unlock();

    if (terminate.loadSeqCst())
      break;

    input.clear();

    for (;;)
    {
      auto start_time = TimePoint::monotonic();

      if (state.loadSeqCst() != State::Running)
        break;

      {
        // TODO(sushi) we can probably do better than mutexes eventually.
        update_mutex.lock();
        defer { update_mutex.unlock(); };

        Client::UpdateParams params = 
        {
          .input = input,
          .viewport_size = vec2u(viewport_size),
        };

        client.update(params);

        new_frame.storeSeqCst(true);

        input.clear();
      }

      TimeSpan time_since_start = time::since(start_time);
      TimeSpan target_time = TimeSpan::fromMilliseconds(4);

      TimeSpan wait_time = TimeSpan::fromNanoseconds(
        target_time.ns - time_since_start.ns);
      
      if (wait_time.ns > 0)
        os::sleep(wait_time);
      else
        println("over budget by ", WithUnits(TimeSpan{-wait_time.ns}));
    }
  }
}

/* ----------------------------------------------------------------------------
 */
void ClientThread::render(gfx::Vulkan& vk, gfx::RenderTarget& target)
{
  Client::RenderParams client_params = 
  {
    .vk = vk,
    .target = target,
  };

  if (new_frame.loadSeqCst())
  {
    new_frame.storeSeqCst(false);

    update_mutex.lock();
    {
      client.render(client_params);
    }
    update_mutex.unlock();
  }
}

static const u64 c_client_render_w = 4096;
static const u64 c_client_render_h = c_client_render_w;


/* ----------------------------------------------------------------------------
 */
static inline b8 recreateClientTexture(
    gfx::Vulkan& vk,
    gfx::Texture* texture)
{
  texture->destroy(vk);

  *texture = gfx::Texture::createForRenderTarget(vk,
  {
    .size = vec2u(c_client_render_w, c_client_render_h),
    .debug_name = "client instance texture"_str
  });

  return notnil(*texture);
}

/* ----------------------------------------------------------------------------
 */
b8 ClientInstance::resetClient(this S& self)
{
  gfx::vk::waitForDeviceIdle(self.editor->vk);

  self.thread.resetClient(self);

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 ClientInstance::init(this S& self)
{
  self.client_render_size = vec2u(self.editor->window.size);

  if (!recreateClientTexture(
        *self.editor->vk,
        &self.client_render))
    return @log.error(editor, 
      "failed to initialize client render texture\n");

  if (!self.thread.init(self))
    return false;

  self.thread.unpause();

  return true;
}

/* ----------------------------------------------------------------------------
 */
void ClientInstance::deinit()
{
  thread.deinit(*this);
  client_render.destroy(*editor->vk);
}

/* ----------------------------------------------------------------------------
 */
void ClientInstance::update() 
{
  if (connected_server == nullptr)
  {
    for (DocMgr::TrackedDoc& tdoc : editor->doc_mgr.docs)
    {
      if (tdoc.type == "editor::ServerInstance"_typeid)
      {
        ((editor::ServerInstance*)tdoc.doc)->connectClientInstance(this);
        @log.info(editor, "ClientInstance found a ServerInstance\n");
        break;
      }
    }
  }
}

/* ----------------------------------------------------------------------------
 */
void ClientInstance::placeUI(ui::UI& ui, const EditorSkinDef& skin)
{
  ZoneScopedN("ClientInstance::placeUI");

  Rect menu_bar_bounds = {};
  menu_bar_bounds.x = 0.f;
  menu_bar_bounds.y = 0.f;
  menu_bar_bounds.w = ui.getWidth();
  menu_bar_bounds.h = 15.f;

  f32 bar_x = 0.f;

  if (ui.putButton(
        "reset"_fid, 
        Rect::from(bar_x, 0.f, 30.f, 15.f),
        "reset"_str,
        skin.button))
  {
    @log.info(editor, "reset\n");
    resetClient();
  }

  bar_x += 35.f;

  if (ui.putButton(
      "toggle-pause"_fid,
      Rect::from(bar_x, 0.f, 60.f, 15.f),
      (thread.isPaused()? "play"_str : "pause"_str),
      skin.button))
  {
    if (thread.isPaused())
      thread.unpause();
    else
      thread.pause();
  }

  Rect bounds = ui.getBounds();
  bounds.y += menu_bar_bounds.h;
  bounds.h -= menu_bar_bounds.h;

  InputState input;

  ui::FocusFlags game_focus = 
    ui.putFocusableBounds("game-focus"_fid, bounds);

  if (game_focus.test(ui::FocusFlag::Focused))
    editor->input.cloneInputState(&input);

  input.setCursorPos(ui.getLocalCursorPos());

  ui_size = bounds.size();
  
  input.mergeInto(thread.input);

  thread.viewport_size = ui_size;

  vec4f uv = {0,0,0,0};
  uv.z = ui_size.x / c_client_render_w;
  uv.w = ui_size.y / c_client_render_h;

  // Client::UpdateParams params = 
  // {
  //   .input = input,
  //   .viewport_size = vec2u(ui_size),
  // };
  //
  //
  // {
  //   ZoneScopedN("ClientInstance::placeUI (client-update)");
  //
  //   // Yeah weird but we have proper cursor input here. Would be nice to 
  //   // separate this from UI stuff. Maybe an input update or something.
  //   client.update(params);
  // }

  ui.putQuad(bounds, client_render.getHandle(), uv, 0xffffffff);
}

/* ----------------------------------------------------------------------------
 */
void ClientInstance::notifyAssetChanged(String name, String type)
{
  reflect::Linker linker = 
  { 
    .resource_mgr = editor->resource_mgr,
    .asset_mgr = editor->asset_mgr,
  };

  // client.notifyAssetChanged(name, type, linker);
}

/* ----------------------------------------------------------------------------
 */
void ClientInstance::render(gfx::Vulkan& vk) 
{
  if (ui_size.x == 0 || ui_size.y == 0)
    return;

  gfx::RenderTarget target = 
  { 
    .image = client_render.image,
    .view = client_render.view,
  };

  thread.render(vk, target);

  gfx::vk::prepareImageForSampling(&vk, client_render.image);
}

}
