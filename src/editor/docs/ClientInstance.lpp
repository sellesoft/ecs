$ require "common"

#include "iro/print.h"

@lpp.import "editor/docs/ClientInstance.lh"
@lpp.import "editor/docs/ServerInstance.lh"

@lpp.import "editor/Editor.lh"
@lpp.import "graphics/vk.lh"
@lpp.import "window/Window.events.lh"

@lpp.import "Profiling.lh"

@log.import

namespace editor
{

/* ----------------------------------------------------------------------------
 */
static b8 handleOfflinePacketSend(
    ClientInstance& self, 
    net::Source source,
    void* data,
    u16 len)
{
  if (self.connected_server == nullptr)
    return false;

  self.offline_packet_out.clear();
  self.offline_packet_out.write((u8*)data, len);

  @log.info(editor, "client send packet: ", data, ' ', len, '\n');
  return true;
}

/* ----------------------------------------------------------------------------
 */
static b8 handleOfflinePacketGet(
    ClientInstance& self, 
    net::Source source,
    net::Fragment& fragment)
{
  if (self.offline_packet_in.len == 0)
    return false;

  mem::copy(
    fragment.arr, 
    self.offline_packet_in.arr, 
    self.offline_packet_in.len);
  fragment.len = self.offline_packet_in.len;

  @log.info(editor, "client got a packet of size ", fragment.len, '\n');

  self.offline_packet_in.clear();

  return true;
}

/* ----------------------------------------------------------------------------
 */
static b8 initClient(ClientInstance& self)
{
  reflect::Linker linker = 
  { 
    .resource_mgr = self.editor->resource_mgr,
    .asset_mgr = self.editor->asset_mgr,
  };

  Client::InitParams client_params = 
  {
    .vk = *self.editor->vk,
    .linker = linker,
  };

  b8 client_init_success = self.thread.client.init(client_params);
  
  // Dump init messages to Console and such.
  for (logging::Entry& entry : self.thread.client.game_log.entries)
    self.editor->log.log(entry);

  if (!client_init_success)
    return self.editor->log.error("failed to initialize a client instance");

  self.thread.client.netmgr.registerOfflinePacketHandler(
    &self,
    handleOfflinePacketSend,
    handleOfflinePacketGet);

  self.thread.client.connectToServer(net::Address::createOffline());

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 ClientThread::init(ClientInstance& cli)
{
  if (!initClient(cli))
    return false;

  state.storeRelaxed(State::Idle);
  terminate.storeRelaxed(false);
  new_frame.storeRelaxed(false);

  signal = conc::ConditionVar::create();
  mutex = conc::Mutex::create();

  update_mutex = conc::Mutex::create();

  thread = conc::Thread::create(this, [](void* opaque)
  {
    ((ClientThread*)opaque)->worker();
  });

  // NOTE(sushi) initialize with some viewport size since the way that we 
  //             update it currently sucks, its possbile the client starts
  //             to update before the proper viewport size is set, which 
  //             causes the GameRenderer to not render, which causes the image
  //             to be in a bad vk layout, which causes validation errors. 
  //             We should handle this better soon.
  viewport_size = vec2f(100, 100);

  return true;
}

/* ----------------------------------------------------------------------------
 */
void ClientThread::deinit(ClientInstance& cli)
{
  terminate.storeSeqCst(true);
  pause();
  signal.signalOne();
  thread.join();

  thread = nil;
  signal.destroy();
  mutex.destroy();

  client.deinit(*cli.editor->vk);
}

/* ----------------------------------------------------------------------------
 */
void ClientThread::pause()
{
  if (state.loadSeqCst() != State::Paused)
    state.storeSeqCst(State::Paused);
}

/* ----------------------------------------------------------------------------
 */
void ClientThread::unpause()
{
  if (state.loadSeqCst() != State::Running)
  {
    state.storeSeqCst(State::Running);
    signal.signalOne();
  }
}

/* ----------------------------------------------------------------------------
 */
void ClientThread::resetClient(ClientInstance& cli)
{
  update_mutex.lock();
  defer { update_mutex.unlock(); };

  client.deinit(*cli.editor->vk);

  if (!initClient(cli))
  {
    state.storeRelaxed(State::Idle);
    return;
  }
}

/* ----------------------------------------------------------------------------
 */
void ClientThread::worker()
{
  for (;;)
  {
    mutex.lock();
    while (state.loadSeqCst() != State::Running &&
           !terminate.loadSeqCst())
    {
      signal.wait(mutex);
    }
    mutex.unlock();

    if (terminate.loadSeqCst())
      break;

    input.clear();

    for (;;)
    {
      auto start_time = TimePoint::monotonic();

      if (state.loadSeqCst() != State::Running)
        break;

      {
        // TODO(sushi) we can probably do better than mutexes eventually.
        update_mutex.lock();
        defer { update_mutex.unlock(); };
        
        // Cache the current input and clear immediately so that new inputs 
        // that occur during the update are processed next tick.
        InputState update_input = input;
        input.clear();

        Client::UpdateParams params = 
        {
          .input = update_input,
          .viewport_size = vec2u(viewport_size),
        };

        client.update(params);

        new_frame.storeSeqCst(true);
      }

      TimeSpan time_since_start = time::since(start_time);
      TimeSpan target_time = TimeSpan::fromMilliseconds(4);

      TimeSpan wait_time = TimeSpan::fromNanoseconds(
        target_time.ns - time_since_start.ns);
      
      if (wait_time.ns > 0)
        os::sleep(wait_time);
      else
        println("over budget by ", WithUnits(TimeSpan{-wait_time.ns}));
    }
  }
}

/* ----------------------------------------------------------------------------
 */
b8 ClientThread::render(gfx::Vulkan& vk, gfx::RenderTarget& target)
{
  Client::RenderParams client_params = 
  {
    .vk = vk,
    .target = target,
  };

  b8 did_render = false;

  if (new_frame.loadSeqCst() && !isPaused())
  {
    new_frame.storeSeqCst(false);

    update_mutex.lock();
    {
      Client::RenderResult client_result = client.render(client_params);
      if (client_result.game_rendered)
        did_render = true;
        
    }
    update_mutex.unlock();
  }

  return did_render;
}

static const u64 c_client_render_w = 4096;
static const u64 c_client_render_h = c_client_render_w;


/* ----------------------------------------------------------------------------
 */
static inline b8 recreateClientTexture(
    gfx::Vulkan& vk,
    gfx::Texture* texture)
{
  texture->destroy(vk);

  *texture = gfx::Texture::createForRenderTarget(vk,
  {
    .size = vec2u(c_client_render_w, c_client_render_h),
    .debug_name = "client instance texture"_str
  });

  return notnil(*texture);
}

/* ----------------------------------------------------------------------------
 */
b8 ClientInstance::resetClient(this S& self)
{
  gfx::vk::waitForDeviceIdle(self.editor->vk);

  self.thread.resetClient(self);

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 ClientInstance::init(this S& self)
{
  if (!recreateClientTexture(
        *self.editor->vk,
        &self.client_render))
    return @log.error(editor, 
      "failed to initialize client render texture\n");

  if (!self.thread.init(self))
    return false;

  self.thread.unpause();

  return true;
}

/* ----------------------------------------------------------------------------
 */
void ClientInstance::deinit()
{
  gfx::vk::waitForDeviceIdle(editor->vk);

  thread.deinit(*this);
  client_render.destroy(*editor->vk);
}

/* ----------------------------------------------------------------------------
 */
void ClientInstance::update() 
{
  if (connected_server == nullptr)
  {
    for (Doc* doc : editor->doc_mgr.docs)
    {
      if (doc->type == "editor::ServerInstance"_typeid)
      {
        ((editor::ServerInstance*)doc)->connectClientInstance(this);
        @log.info(editor, "ClientInstance found a ServerInstance\n");
        break;
      }
    }
  }
}

/* ----------------------------------------------------------------------------
 */
void ClientInstance::putUI(ui::UI& ui, const EditorSkinDef& skin)
{
  ZoneScopedN("ClientInstance::putUI");

  Rect menu_bar_bounds = {};
  menu_bar_bounds.x = 0.f;
  menu_bar_bounds.y = 0.f;
  menu_bar_bounds.w = ui.getWidth();
  menu_bar_bounds.h = 15.f;

  f32 bar_x = 0.f;

  if (ui.putButton(
        "reset"_fid, 
        Rect::from(bar_x, 0.f, 30.f, 15.f),
        "reset"_str,
        skin.text_button))
  {
    resetClient();
  }

  bar_x += 35.f;

  if (ui.putButton(
      "toggle-pause"_fid,
      Rect::from(bar_x, 0.f, 60.f, 15.f),
      (thread.isPaused()? "play"_str : "pause"_str),
      skin.text_button))
  {
    if (thread.isPaused())
      thread.unpause();
    else
      thread.pause();
  }

  Rect bounds = ui.getBounds();
  bounds.y += menu_bar_bounds.h;
  bounds.h -= menu_bar_bounds.h;

  ui_size = bounds.size();

  InputState input;

  ui::Focus game_focus = ui.putFocusableBounds("game-focus"_fid, bounds);

  if (game_focus.isFocused())
  {
    editor->input.cloneInputState(&input);
    input.setCursorPos(ui.getLocalCursorPos());
    input.mergeInto(thread.input);
  }

  thread.viewport_size = ui_size;

  vec4f uv = {0,0,0,0};
  uv.z = ui_size.x / c_client_render_w;
  uv.w = ui_size.y / c_client_render_h;

  ui.putQuad(bounds, client_render.getHandle(), uv, 0xffffffff);
}

/* ----------------------------------------------------------------------------
 */
void ClientInstance::notifyAssetChanged(String name, String type)
{
  reflect::Linker linker = 
  { 
    .resource_mgr = editor->resource_mgr,
    .asset_mgr = editor->asset_mgr,
  };

  // client.notifyAssetChanged(name, type, linker);
}

/* ----------------------------------------------------------------------------
 */
void ClientInstance::render(gfx::Vulkan& vk) 
{
  if (ui_size.x == 0 || ui_size.y == 0)
    return;

  gfx::RenderTarget target = 
  { 
    .image = client_render.image,
    .view = client_render.view,
  };

  if (thread.render(vk, target))
    gfx::vk::prepareImageForSampling(&vk, client_render.image);
}

}
