$ require "common"

#include "iro/print.h"

@lpp.import "editor/docs/ClientInstance.lh"
@lpp.import "editor/docs/ServerInstance.lh"

@lpp.import "editor/Editor.lh"
@lpp.import "graphics/vk.lh"
@lpp.import "window/Window.events.lh"

@lpp.import "Profiling.lh"

@log.import

namespace editor
{

static const u64 c_client_render_w = 4096;
static const u64 c_client_render_h = c_client_render_w;

/* ----------------------------------------------------------------------------
 */
static b8 handleOfflinePacketSend(
    ClientInstance& self, 
    net::Source source,
    void* data,
    u16 len)
{
  if (self.connected_server == nullptr)
    return false;

  self.offline_packet_out.clear();
  self.offline_packet_out.write((u8*)data, len);

  @log.info(editor, "client send packet: ", data, ' ', len, '\n');
  return true;
}

/* ----------------------------------------------------------------------------
 */
static b8 handleOfflinePacketGet(
    ClientInstance& self, 
    net::Source source,
    net::Fragment& fragment)
{
  if (self.offline_packet_in.len == 0)
    return false;

  mem::copy(
    fragment.arr, 
    self.offline_packet_in.arr, 
    self.offline_packet_in.len);
  fragment.len = self.offline_packet_in.len;

  @log.info(editor, "client got a packet of size ", fragment.len, '\n');

  self.offline_packet_in.clear();

  return true;
}

/* ----------------------------------------------------------------------------
 */
static inline b8 recreateClientTexture(
    gfx::Vulkan& vk,
    gfx::Texture* texture)
{
  texture->destroy(vk);

  *texture = gfx::Texture::createForRenderTarget(vk,
  {
    .size = vec2u(c_client_render_w, c_client_render_h),
    .debug_name = "client instance texture"_str
  });

  return notnil(*texture);
}
/* ----------------------------------------------------------------------------
 */
static b8 initClient(ClientInstance& self)
{
  reflect::Linker linker = 
  { 
    .resource_mgr = self.editor->resource_mgr,
    .asset_mgr = self.editor->asset_mgr,
  };

  Client::InitParams client_params = 
  {
    .vk = *self.editor->vk,
    .linker = linker,
  };

  if (!self.client.init(client_params))
    return @log.error(editor, "failed to initialize a client instance\n");

  self.client.netmgr.registerOfflinePacketHandler(
    &self,
    handleOfflinePacketSend,
    handleOfflinePacketGet);

  self.client.connectToServer(net::Address::createOffline());

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 ClientInstance::resetClient(this ClientInstance& self)
{
  gfx::vk::waitForDeviceIdle(self.editor->vk);

  self.client.deinit(*self.editor->vk);
  return initClient(self);
}

/* ----------------------------------------------------------------------------
 */
b8 ClientInstance::init(this S& self)
{
  self.title = "client-instance"_str;

  self.client_render_size = vec2u(self.editor->window.size);

  if (!recreateClientTexture(
        *self.editor->vk,
        &self.client_render))
    return @log.error(editor, 
      "failed to initialize client render texture\n");

  if (!initClient(self))
    return false;

  return true;
}

/* ----------------------------------------------------------------------------
 */
void ClientInstance::deinit()
{
}

/* ----------------------------------------------------------------------------
 */
void ClientInstance::update() 
{
  if (connected_server == nullptr)
  {
    for (DocMgr::TrackedDoc& tdoc : editor->doc_mgr.docs)
    {
      if (tdoc.type == "editor::ServerInstance"_typeid)
      {
        ((editor::ServerInstance*)tdoc.doc)->connectClientInstance(this);
        @log.info(editor, "ClientInstance found a ServerInstance\n");
        break;
      }
    }
  }
}

/* ----------------------------------------------------------------------------
 */
void ClientInstance::placeUI(ui::UI& ui, const EditorSkinDef& skin)
{
  ZoneScopedN("ClientInstance::placeUI");

  Rect menu_bar_bounds = {};
  menu_bar_bounds.x = 0.f;
  menu_bar_bounds.y = 0.f;
  menu_bar_bounds.w = ui.getWidth();
  menu_bar_bounds.h = 15.f;

  f32 bar_x = 0.f;

  if (ui.putButton(
        "reset"_fid, 
        Rect::from(bar_x, 0.f, 30.f, 15.f),
        "reset"_str,
        skin.button))
  {
    @log.info(editor, "reset\n");
    resetClient();
  }

  bar_x += 30.f;

  if (ui.putButton(
        "dump-logs"_fid,
        Rect::from(bar_x, 0.f, 60.f, 15.f),
        "dump-logs"_str,
        skin.button))
  {
    @log.info(editor, "dump-logs\n");
    for (logging::Entry& ent : client.game_log.entries)
      editor->log.log(ent);
  }

  Rect bounds = ui.getBounds();
  bounds.y += menu_bar_bounds.h;
  bounds.h -= menu_bar_bounds.h;

  InputState input;

  ui::FocusFlags game_focus = 
    ui.putFocusableBounds("game-focus"_fid, bounds);

  if (game_focus.test(ui::FocusFlag::Focused))
    editor->input.cloneInputState(&input);

  input.setCursorPos(ui.getLocalCursorPos());

  ui_size = bounds.size();

  vec4f uv = {0,0,0,0};
  uv.z = ui_size.x / c_client_render_w;
  uv.w = ui_size.y / c_client_render_h;

  Client::UpdateParams params = 
  {
    .input = input,
    .viewport_size = vec2u(ui_size),
  };

  
  {
    ZoneScopedN("ClientInstance::placeUI (client-update)");

    // Yeah weird but we have proper cursor input here. Would be nice to 
    // separate this from UI stuff. Maybe an input update or something.
    client.update(params);
  }

  ui.putQuad(bounds, client_render.getHandle(), uv, 0xffffffff);
}

/* ----------------------------------------------------------------------------
 */
void ClientInstance::notifyAssetChanged(String name, String type)
{
  reflect::Linker linker = 
  { 
    .resource_mgr = editor->resource_mgr,
    .asset_mgr = editor->asset_mgr,
  };

  client.notifyAssetChanged(name, type, linker);
}

/* ----------------------------------------------------------------------------
 */
void ClientInstance::render(gfx::Vulkan& vk) 
{
  if (ui_size.x == 0 || ui_size.y == 0)
    return;

  gfx::RenderTarget target = 
  { 
    .image = client_render.image,
    .view = client_render.view,
  };

  Client::RenderParams client_params = 
  {
    .vk = vk,
    .target = target,
  };

  client.render(client_params);

  gfx::vk::prepareImageForSampling(&vk, client_render.image);
}

}
