$ require "common"

$$$
local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/editor/**/*.lh"
}
$$$
$(imported)

@lpp.import "editor/docs/DocMgr.lh"

#include "iro/print.h"
#include "iro/io/SmallBuffer.h"

$ local TDoc = astctx:lookupTypeDecl "editor::Doc"

@log.import

namespace editor
{

/* ----------------------------------------------------------------------------
 */
static inline String docNameFromTypeId(rtr::TypeId type)
{
  switch (type.val)
  {
$ for derived in TDoc:allDerived() do
  case "$(derived.qname)"_typeid_val:
    return "$(derived.name)"_str;
$ end
  }
  assert(false);
  return "???"_str;
}

/* ----------------------------------------------------------------------------
 */
b8 DocMgr::init(Editor& editor)
{
  this->editor = &editor;

  if (!docs.init())
    return false;

  if (!order.init())
    return false;

  if (!tree_nodes.init())
    return false;

  MenuBarTab::Option opts[] = 
  {
$ for doc in TDoc:allDerived() do
    { "$(doc.name)"_str, "Editor.DocMgr.open $(doc.name)"_str },
$ end
  };

  editor.menu_bar.registerTab("open doc"_str, makeSlice(opts));

  editor.cmd_bus.registerCommand<DocMgr>("Editor.DocMgr.open"_str, this,
    [](DocMgr& self, event::CommandArgs args)
    {
      if (args.isEmpty())
      {
        @log.error(editor, "Editor.DocMgr.open requires one arg\n");
        return;
      }

      b8 v = true;
      b8 a = false;
      if (args.len >= 2)
      {
        if (args[1] == "v"_str)
        {
          v = true;
          a = false;
        }
        else if (args[1] == "vl"_str)
        {
          v = true;
          a = true;
        }
        else if (args[1] == "vr"_str)
        {
          v = true;
          a = false;
        }
        else if (args[1] == "h"_str)
        {
          v = false;
          a = false;
        }
        else if (args[1] == "ht"_str)
        {
          v = false;
          a = true;
        }
        else if (args[1] == "hb"_str)
        {
          v = false;
          a = false;
        }
      }

      self.open(args[0], v, a);
    });

  // Attempt to load the last doc layout if it exists.
  // loadCachedDocState();
  return true;
}

/* ----------------------------------------------------------------------------
 */
static void closeDocs(DocMgr& self, b8 all)
{
  for (s32 i = self.docs.len() - 1; i >= 0; --i)
  {
    if (all || self.docs[i].doc->flags.test(Doc::Flag::ToBeClosed))
    {
      self.editor->log.info("closing ", self.docs[i].doc->title);

      self.docs[i].doc->onClose();

      for (s32 o = self.order.len() - 1; o >= 0; --o)
      {
        if (self.order[o] == i)
          self.order.remove(o);
        else if (self.order[o] > i)
          self.order[o] -= 1;
      }
      
      mem::stl_allocator.free(self.docs[i].doc);
      self.docs.remove(i);
    }
  }
}

/* ----------------------------------------------------------------------------
 */
void DocMgr::deinit()
{
  // Save doc state on close so its restored next time the editor is opened.
  // TODO(sushi) config for this behavior.
  cacheDocState();

  closeDocs(*this, true);

  docs.destroy();
  order.destroy();
}

/* ----------------------------------------------------------------------------
 */
static void initWindowDoc(DocMgr& self, Doc* doc, rtr::TypeId type)
{
  doc->editor = self.editor;
  doc->pos = { 50.f, 50.f };
  doc->size = { 300.f, 300.f };

  self.order.insert(0, self.docs.len());
  self.docs.push({.type = type, .doc = doc});

  doc->onOpen();
}

/* ============================================================================
 *  Identifies the side of a split node. 
 *
 *  When SplitV, SplitSide::A is left and SplitSide::B is right.
 *  When SplitH, SplitSide::A is top and SplitSide::B is bottom.
 */
enum class SplitSide
{
  A, B
};

/* ----------------------------------------------------------------------------
 */
static inline DocTreeNode* insertNode(
    DocMgr& self, 
    DocTreeNode* target,
    SplitSide side)
{
  assert(target->isSplit());

  DocTreeNode* nu = self.tree_nodes.add();
  nu->ratio = 1.f;

  if (side == SplitSide::A)
  {
    nu->next = target->split.first;
    target->split.first = nu;
  }
  else
  {
    target->split.last->next = nu;
    target->split.last = nu;
  }

  return nu;
}

/* ----------------------------------------------------------------------------
 */
static inline DocTreeNode* splitSingle(
    DocMgr& self, 
    DocTreeNode* target,
    DocTreeNode::State split,
    SplitSide side)
{
  using enum DocTreeNode::State;

  assert(target->state == Single);

  DocTreeNode* a = self.tree_nodes.add();
  a->state = Single;
  a->doc = target->doc;
  a->ratio = 1.f;

  DocTreeNode* b = self.tree_nodes.add();
  b->ratio = 1.f;

  if (side == SplitSide::A)
  {
    target->split.first = b;
    target->split.last = a;
    b->next = a;
  }
  else
  {
    target->split.first = a;
    target->split.last = b;
    a->next = b;
  }

  target->state = split;
  return b;
}

/* ----------------------------------------------------------------------------
 *  Splits 'target' which is expected to already be split. If the desired 
 *  axis is different, then a new split node is created. Otherwise the new 
 *  node is just appended.
 */
static inline DocTreeNode* splitSplit(
    DocMgr& self,
    DocTreeNode* target,
    DocTreeNode::State split,
    SplitSide side)
{
  assert(target->isSplit());

  using enum DocTreeNode::State;

  // Just insert node when already in the same state.
  if (target->state == split)
    return insertNode(self, target, side);

  // Otherwise we need to create a new split.
  DocTreeNode* a = self.tree_nodes.add();
  a->state = target->state;
  a->split = target->split;
  a->ratio = 1.f;

  DocTreeNode* b = self.tree_nodes.add();
  b->ratio = 1.f;

  if (side == SplitSide::A)
  {
    target->split.first = b;
    target->split.last = a;
    b->next = a;
  }
  else
  {
    target->split.first = a;
    target->split.last = b;
    a->next = b;
  }

  target->state = split;
  return b;
}

/* ----------------------------------------------------------------------------
 */
static inline DocTreeNode* splitNode(
    DocMgr& self, 
    DocTreeNode* target, 
    DocTreeNode::State split,
    SplitSide side)
{
  using enum DocTreeNode::State;

  assert(target->state != Invalid);

  if (target->state == Single)
    return splitSingle(self, target, split, side);

  return splitSplit(self, target, split, side);
}

/* ----------------------------------------------------------------------------
 */
Doc* DocMgr::open(String name, b8 v, b8 a)
{
  rtr::TypeId type;
  Doc* doc = nullptr;

  switch (name.hash())
  {
  default:
    return @log.errorln(editor, "unknown doc type '", name, "'"),
           nullptr;

$ for doc in TDoc:allDerived() do
  case "$(doc.name)"_hashed:
    type = "$(doc.qname)"_typeid;
    doc = mem::stl_allocator.construct<$(doc.qname)>();
    doc->title = "$(doc.name)"_str;
    break;
$ end
  }

  editor->log.info("opening document '", name, "'");

  using enum DocTreeNode::State;

  doc->editor = editor;
  doc->onOpen();

  docs.push({.type = type, .doc = doc});

  if (tree_root.state == Invalid)
  {
    tree_root.state = Single;
    tree_root.doc = doc;
    return doc;
  }

  DocTreeNode::State split = v? SplitV : SplitH;
  SplitSide side = a? SplitSide::A : SplitSide::B;

  DocTreeNode* new_node = splitNode(*this, &tree_root, split, side);
  new_node->state = DocTreeNode::State::Single;
  new_node->doc = doc;

  return doc;
}

/* ----------------------------------------------------------------------------
 */
void DocMgr::close(Doc* doc)
{
  doc->flags.set(Doc::Flag::ToBeClosed);
}

/* ----------------------------------------------------------------------------
 */
static Doc::EdgeFlags computeEdgeFlags(
    vec2f local_cursor,
    vec2f size,
    f32 hit_size)
{
  Doc::EdgeFlags flags = {};
  if (local_cursor.x < hit_size)
    flags.set(Doc::Edge::Left);
  if (local_cursor.y < hit_size)
    flags.set(Doc::Edge::Top);
  if (size.x - local_cursor.x < hit_size)
    flags.set(Doc::Edge::Right);
  if (size.y - local_cursor.y < hit_size)
    flags.set(Doc::Edge::Bottom);
  return flags;
}

/* ----------------------------------------------------------------------------
 */
static void computeDisplayedPosAndSize(
    vec2f* disp_pos,
    vec2f* disp_size,
    vec2f local_cursor,
    vec2f drag_start,
    Doc::EdgeFlags dragged_edges)
{
  vec2f diff = local_cursor - drag_start;

  if (dragged_edges.test(Doc::Edge::Top))
  {
    disp_pos->y += diff.y;
    disp_size->y -= diff.y;
  }
  else if (dragged_edges.test(Doc::Edge::Bottom))
  {
    disp_size->y += diff.y;
  }

  if (dragged_edges.test(Doc::Edge::Left))
  {
    disp_pos->x += diff.x;
    disp_size->x -= diff.x;
  }
  else if (dragged_edges.test(Doc::Edge::Right))
  {
    disp_size->x += diff.x;
  }
}

/* ----------------------------------------------------------------------------
 */
static b8 putDocWindow(ui::UI& ui, Doc* doc, const EditorSkinDef& skin)
{
  ui.pushId(ui.generateIdFromPointer(doc));
  defer { ui.popId(); };

  b8 clicked = false;
  b8 closed = false;

  const f32 border_w = 1.f;
  const f32 border_hit_size = 10.f;

  const f32 header_h = 20.f;

  // Offset to the actual start of the window inside of the hit bounds.
  vec2f hit_offset = { border_hit_size, border_hit_size };

  // The position and size we will display the window with. 
  vec2f displayed_pos = doc->pos;
  vec2f displayed_size = doc->size;

  // Save the location of the cursor before we go into window space.
  vec2f container_cursor = ui.getLocalCursorPos();

  if (doc->control_state == Doc::ControlState::DraggingEdge)
  {
    computeDisplayedPosAndSize(
      &displayed_pos, 
      &displayed_size,
      container_cursor,
      doc->drag_start,
      doc->dragged_edges);

    if (ui.frame_input.wasMouseButtonReleased(MouseButton::Left))
    {
      doc->control_state = Doc::ControlState::None;
      doc->size = displayed_size;
      doc->pos = displayed_pos;
    }
  }

  // Place the hit area.
  vec2f hit_size;
  hit_size.x = displayed_size.x + 2 * border_hit_size;
  hit_size.y = displayed_size.y + 2 * border_hit_size;
  ui.beginGroup(Rect::from(displayed_pos - hit_offset, hit_size));
  
  // Place a focusable covering the entire area of the window + some offset 
  // from each edge for resize controls.
  ui::FocusFlags focus = 
    ui.putFocusableBounds("doc-border"_fid, ui.getBounds());

  if (focus.test(ui::FocusFlag::Hovered) && 
      doc->control_state != Doc::ControlState::DraggingEdge)
  {
    vec2f local_cursor = ui.getLocalCursorPos();

    Doc::EdgeFlags edges = 
      computeEdgeFlags(local_cursor, hit_size, border_hit_size);

    if (focus.test(ui::FocusFlag::PrimaryPressed))
    {
      clicked = true;
      doc->drag_start = container_cursor;
      doc->dragged_edges = edges;
      doc->control_state = Doc::ControlState::DraggingEdge;
    }
  }

  // Place the actual Window stuff.
  ui.beginGroup(Rect::from(hit_offset, displayed_size));
  {
    ui::ItemSkin bg = {};
    bg.color = 0x000000ff;
    bg.border = { -border_w, -border_w, -border_w, -border_w };
    bg.border_color = 0xaaaaaaff;
    
    ui.putItem(Rect::from({0,0}, displayed_size), bg);

    Rect header_bounds = {};
    header_bounds.x = 0.f;
    header_bounds.y = 0.f;
    header_bounds.w = ui.getWidth();
    header_bounds.h = header_h;

    ui.putTextItem(header_bounds, doc->title, skin.doc.window.header);

    ui::FocusFlags focus = 
      ui.putFocusableBounds("doc-window"_fid, header_bounds);
  
    if (doc->control_state == Doc::ControlState::DraggingWindow)
    {
      if (focus.test(ui::FocusFlag::PrimaryReleased))
      {
        doc->control_state = Doc::ControlState::None;
      }
      else
      {
        vec2f lcur = ui.getLocalCursorPos();
        doc->pos += lcur - ui.focus_state.pressed_cursor_offset;
      }
    }
    else if (focus.test(ui::FocusFlag::PrimaryPressed))
    {
      clicked = true;
      doc->control_state = Doc::ControlState::DraggingWindow;
    }

    const f32 close_button_size = 16.f;

    Rect close_button_bounds = {};
    close_button_bounds.x = header_bounds.extent().x - close_button_size - 4.f;
    close_button_bounds.y = 
      floor(0.5f * (header_bounds.h - skin.doc.window.close_button.uv.h));
    close_button_bounds.w = close_button_size;
    close_button_bounds.h = close_button_size;

    ui.putItem(close_button_bounds, skin.doc.window.close_button);

    ui::FocusFlags close_focus = 
      ui.putFocusableBounds("doc-close"_fid, close_button_bounds);

    if (close_focus.test(ui::FocusFlag::PrimaryReleased))
      doc->flags.set(Doc::Flag::ToBeClosed);

    Rect content_bounds = {};
    content_bounds.x = border_w;
    content_bounds.y = header_h;
    content_bounds.w = ui.getWidth() - 2 * border_w;
    content_bounds.h = ui.getHeight() - border_w - header_h;
    
    ui.beginGroup(content_bounds);
    doc->placeUI(ui, skin);
    ui.endGroup();
  }
  ui.endGroup();
  ui.endGroup();

  return clicked;
}

/* ----------------------------------------------------------------------------
 */
static void putDocTreeNode(
    DocMgr& self, 
    ui::UI& ui,
    DocTreeNode* node,
    const EditorSkinDef& skin)
{
  using enum DocTreeNode::State;

  if (node->state == Invalid)
    return;

  if (node->state == Single)
  {
    ui.pushId(ui.generateIdFromPointer(node->doc));
    node->doc->placeUI(ui, skin);
    ui.popId();

    return;
  }

  ui.pushId(ui.generateIdFromPointer(node));
  defer { ui.popId(); };

  b8 is_h_split = node->state == SplitH;

  vec2f local_cursor = ui.getLocalCursorPos();

  Rect bounds = ui.getBounds();

  u32 child_count = 0;
  f32 ratio_sum = 0.f;
  for (DocTreeNode* child = node->split.first; child; child = child->next)
  {
    child_count += 1;
    ratio_sum += child->ratio;
  }

  s32 num_dividers = child_count - 1;

  const f32 divider_size = 4.f;
  const f32 divider_half_size = divider_size / 2.f;

  f32 total_divider_size = divider_size * num_dividers;

  f32 children_space = is_h_split? bounds.h : bounds.w - total_divider_size;

  f32 prev_end = 0.f;
  f32 ratio_accumulator = 0.f;
  u32 child_idx = 0;
  for (DocTreeNode* child = node->split.first; child; 
       child = child->next, child_idx += 1)
  {
    ui.pushId(ui.generateIdFromPointer(child));
    defer { ui.popId(); };

    Rect child_bounds = {};

    ratio_accumulator += child->ratio;

    f32 start = prev_end + divider_size;
    f32 end = 
      round(children_space * ratio_accumulator / ratio_sum) + 
      divider_size * child_idx;

    prev_end = end;
    
    if (is_h_split)
    {
      child_bounds.x = bounds.x;
      child_bounds.y = start;
      child_bounds.w = bounds.w;
      child_bounds.h = end - start;
    }
    else
    {
      child_bounds.x = start;
      child_bounds.y = bounds.y;
      child_bounds.w = end - start;
      child_bounds.h = bounds.h;
    }

    ui.beginGroup(child_bounds);
    putDocTreeNode(self, ui, child, skin);
    ui.endGroup();

    if (child->next != nullptr)
    {
      Rect divider_bounds = {};
      
      if (is_h_split)
      {
        divider_bounds.x = bounds.x;
        divider_bounds.y = child_bounds.extentY();
        divider_bounds.w = bounds.w;
        divider_bounds.h = divider_size;
      }
      else
      {
        divider_bounds.x = child_bounds.extentX();
        divider_bounds.y = bounds.y;
        divider_bounds.w = divider_size;
        divider_bounds.h = bounds.h;
      }

      ui.putQuad(divider_bounds, 0x666666ff);

      ui::FocusFlags divider_focus = 
        ui.putFocusableBounds("divider"_fid, divider_bounds);

      if (divider_focus.test(ui::FocusFlag::PrimaryPressed))
        child->dragging = true;

      if (child->dragging)
      {
        // Find the offset of the cursor into this pair along the proper 
        // split axis.
        f32 cursor_offset = 0.f;
        if (is_h_split)
          cursor_offset = local_cursor.y - child_bounds.y;
        else
          cursor_offset = local_cursor.x - child_bounds.x;
        
        // Figure out what pixel the next child is meant to end at.
        f32 next_ratio_accum = ratio_accumulator + child->next->ratio;
        f32 next_end = 
          round(children_space * next_ratio_accum / ratio_sum) + 
          divider_size * (child_idx + 1);

        // Compute the ratio of the cursor's offset and the total width of 
        // the 
        f32 siblings_width = next_end - start;
        f32 cursor_ratio = cursor_offset / siblings_width;

        // Clamp ratio to kinda avoid crashing the editor.
        cursor_ratio = max(0.1f, min(0.9f, cursor_ratio));

        // Can probably simplify this.
        f32 prev_ratio_accum = ratio_accumulator - child->ratio;
        f32 total_ratio_need = next_ratio_accum - prev_ratio_accum;

        child->ratio = cursor_ratio * total_ratio_need;
        child->next->ratio = total_ratio_need - child->ratio;

        // Make sure that ratio_accumulator will be what will give the same 
        // end as the next_end we computed above.
        ratio_accumulator = next_ratio_accum - child->next->ratio;

        if (ui.getFocus().test(ui::FocusFlag::PrimaryReleased))
          child->dragging = false;
      }
    }
  }
}

/* ----------------------------------------------------------------------------
 */
void DocMgr::placeUI(ui::UI& ui, const EditorSkinDef& skin)
{
  putDocTreeNode(
    *this,
    ui,
    &tree_root,
    skin);

  b8 clicked = false;
  u32 clicked_idx = 0;
  for (u32 iorder = 0; iorder < order.len(); ++iorder)
  {
    u32 ordered_idx = order[iorder];

    if (putDocWindow(ui, docs[ordered_idx].doc, skin) &&
        !clicked)
    {
      clicked = true;
      clicked_idx = iorder;
    }
  }

  if (clicked)
  {
    u32 doc_idx = order[clicked_idx];
    order.remove(clicked_idx);
    order.push(doc_idx);
  }
}

/* ----------------------------------------------------------------------------
 */
void DocMgr::update()
{
  // Close any docs marked to be closed.
  closeDocs(*this, false);

  // Update each open doc.
  for (TrackedDoc& tdoc : docs)
    tdoc.doc->update();
}

/* ----------------------------------------------------------------------------
 */
void DocMgr::render(gfx::Vulkan& vk)
{
  for (TrackedDoc& tdoc : docs)
    tdoc.doc->render(vk);
}

/* ----------------------------------------------------------------------------
 */
void DocMgr::cacheDocState()
{
  SourceDataFile sfile;
  sfile.init();
  defer { sfile.deinit(); };

  SourceData* ret = sfile.addReturnData();

  ret->setObject(nil);

  SourceData* sdocs = ret->addObject(sfile, "docs"_str);

  for (TrackedDoc& tdoc : docs)
  {
    SourceData* sdoc = sdocs->addObject(sfile, nil);
    sdoc->addStringValue(sfile, "title"_str, tdoc.doc->title);
    sdoc->addVec2(sfile, "pos"_str, tdoc.doc->pos);
    sdoc->addVec2(sfile, "size"_str, tdoc.doc->size);
    sdoc->addStringValue(sfile, "type"_str, docNameFromTypeId(tdoc.type));
  }

  SourceData* sorder = ret->addObject(sfile, "order"_str);

  for (u32 o : order)
    sorder->addUIntValue(sfile, o);

  editor->cacheSourceDataFile(sfile, "doc-state"_str);
}

/* ----------------------------------------------------------------------------
 */
void DocMgr::loadCachedDocState()
{
  SourceDataFile sfile;
  defer { sfile.deinit(); };

  if (!editor->loadCachedSourceDataFile(&sfile, "doc-state"_str))
    return;

  // Close all currently open docs. 
  // TODO(sushi) probably not the best behavior.
  closeDocs(*this, true);

  SourceData* ret = sfile.returned_data;

  SourceData* docs = ret->findChildByName("docs"_str);

  for (SourceData* child : docs->children)
  {
    String title = child->findChildByName("title"_str)->val.str.allocateCopy();
    vec2f pos    = child->findChildByName("pos"_str)->as_vec2f();
    vec2f size   = child->findChildByName("size"_str)->as_vec2f();
    String type  = child->findChildByName("type"_str)->val.str;

    Doc* doc = open(type);
    doc->title = title;
    doc->size = size;
    doc->pos = pos;
  }

  order.clear();

  SourceData* cached_order = ret->findChildByName("order"_str);

  for (SourceData* o : cached_order->children)
    order.push(o->as_u64());
}

}
