$ require "common"

$$$
local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/editor/**/*.lh"
}
$$$
$(imported)

@lpp.import "editor/docs/DocMgr.lh"

#include "iro/print.h"
#include "iro/io/SmallBuffer.h"

$ local TDoc = astctx:lookupTypeDecl "editor::Doc"

@log.import

namespace editor
{

/* ----------------------------------------------------------------------------
 */
static inline String docNameFromTypeId(rtr::TypeId type)
{
  switch (type.val)
  {
$ for derived in TDoc:allDerived() do
  case "$(derived.qname)"_typeid_val:
    return "$(derived.name)"_str;
$ end
  }
  assert(false);
  return "???"_str;
}

/* ----------------------------------------------------------------------------
 */
static inline rtr::TypeId typeIdFromDocName(String name)
{
  switch (name.hash())
  {
$ for derived in TDoc:allDerived() do
  case "$(derived.name)"_hashed:
    return "$(derived.qname)"_typeid;
$ end
  }
  assert(false);
  return nil;
}

/* ----------------------------------------------------------------------------
 */
b8 DocMgr::init(Editor& editor)
{
  this->editor = &editor;

  if (!docs.init())
    return false;

  if (!order.init())
    return false;

  if (!tree_nodes.init())
    return false;

  MenuBarTab::Option opts[] = 
  {
$ for doc in TDoc:allDerived() do
    { "$(doc.name)"_str, "Editor.DocMgr.open $(doc.name)"_str },
$ end
  };

  editor.menu_bar.registerTab("open doc"_str, makeSlice(opts));

  editor.cmd_bus.registerCommand<DocMgr>("Editor.DocMgr.open"_str, this,
    [](DocMgr& self, event::CommandArgs args)
    {
      if (args.isEmpty())
      {
        @log.error(editor, "Editor.DocMgr.open requires one arg\n");
        return;
      }

      b8 v = true;
      b8 a = false;
      if (args.len >= 2)
      {
        if (args[1] == "v"_str)
        {
          v = true;
          a = false;
        }
        else if (args[1] == "vl"_str)
        {
          v = true;
          a = true;
        }
        else if (args[1] == "vr"_str)
        {
          v = true;
          a = false;
        }
        else if (args[1] == "h"_str)
        {
          v = false;
          a = false;
        }
        else if (args[1] == "ht"_str)
        {
          v = false;
          a = true;
        }
        else if (args[1] == "hb"_str)
        {
          v = false;
          a = false;
        }
      }

      self.open(args[0], v, a);
    });

  // Attempt to load the last doc layout if it exists.
  // loadCachedDocState();
  return true;
}

/* ----------------------------------------------------------------------------
 */
static inline u64 calcSplitCount(DocTreeNode* target)
{
  assert(target->isSplit());

  u64 sum = 0;
  for (DocTreeNode* child = target->split.first; child; child = child->next)
    sum += 1;
  return sum;
}

/* ----------------------------------------------------------------------------
 */
static b8 findDocTreeNode(
    DocMgr& self, 
    DocTreeNode* node, 
    DocTreeNode* container,
    Doc* doc,
    DocTreeNode** out_node,
    DocTreeNode** out_container)
{
  using enum DocTreeNode::State;

  if (node->state == Invalid)
    return false;

  if (node->state == Single)
  {
    if (doc == node->doc)
    {
      *out_node = node;
      *out_container = container;
      return true;
    }
    return false;
  }

  for (DocTreeNode* child = node->split.first; child; child = child->next)
  {
    if (findDocTreeNode(self, child, node, doc, out_node, out_container))
      return true;
  }

  return false;
}

/* ----------------------------------------------------------------------------
 */
static DocTreeNode* findPrevNodeInContainer(
    DocTreeNode* node, 
    DocTreeNode* container)
{
  DocTreeNode* prev = nullptr;
  for (DocTreeNode* child = container->split.first; 
       child; 
       child = child->next)
  {
    if (child->next == node)
    {
      prev = child;
      break;
    }
  }
  return prev;
}

/* ----------------------------------------------------------------------------
 */
static void removeNodeFromContainer(
    DocMgr& self,
    DocTreeNode* node, 
    DocTreeNode* container)
{
  using enum DocTreeNode::State;

  if (container->split.first->next == container->split.last)
  {
    // We are removing the second-to-last child node of this node, so the 
    // container node will be deleted and we have to merge the remaining
    // 'consumed' node into whatever contains the container.

    // Figure out which node we are consuming.
    DocTreeNode* consumed = nullptr;
    if (node == container->split.first)
      consumed = container->split.last;
    else 
      consumed = container->split.first;

    DocTreeNode* parent = container->parent;
    if (parent != nullptr && 
        consumed->isSplit() &&
        parent->state == consumed->state)
    {
      // If this container has a parent and it is split the same way as the 
      // 'consumed' node, we append or prepend 'consumed's children to 
      // the parent. 
      if (parent->split.first == container)
      {
        // If the container was the first child of its parent, then we can 
        // just prepend the parent's children with consumed's.
        consumed->split.last->next = container->next;
        parent->split.first = consumed->split.first;
      }
      else
      {
        // Otherwise, we must find the node preceeding the container node 
        // and inject consumed's nodes after it.
        DocTreeNode* prev = findPrevNodeInContainer(container, parent);

        consumed->split.last->next = container->next;
        prev->next = consumed->split.first;

        if (parent->split.last == container)
          parent->split.last = consumed->split.last;
      }

      // Reparent consumed's children.
      for (DocTreeNode* child = consumed->split.first; child; 
           child = child->next)
      {
        child->parent = parent;
      }

      // Delete the container node.
      self.tree_nodes.remove(container);
    }
    else
    {
      // Literally 'consume' the consumed node into the container node.
      // This preserves the size that container had.
      container->state = consumed->state;
      container->split = consumed->split;
      container->doc = consumed->doc;

      for (DocTreeNode* child = consumed->split.first; child; 
           child = child->next)
      {
        child->parent = container;
      }
    }

    // Delete the consumed node.
    self.tree_nodes.remove(consumed);
    return;
  }

  if (node == container->split.first)
  {
    // If this is the first node of the container, then we can just 
    // set its first to next.
    node->next->size += node->size;
    container->split.first = node->next;
    node->next = nullptr;

    return;
  }

  DocTreeNode* prev = nullptr;
  for (DocTreeNode* child = container->split.first; 
       child; 
       child = child->next)
  {
    if (child->next == node)
    {
      prev = child;
      break;
    }
  }

  prev->size += node->size;

  if (node == container->split.last)
  {
    prev->next = nullptr;
    container->split.last = prev;

    return;
  }

  prev->next = node->next;
}

/* ----------------------------------------------------------------------------
 */
static void closeDoc(
    DocMgr& self, 
    DocTreeNode* node, 
    DocTreeNode* container,
    Doc* doc)
{
  doc->onClose();

  if (node && container)
  {
    if (node != &self.tree_root)
      removeNodeFromContainer(self, node, container);

    node->state = DocTreeNode::State::Invalid;
    node->doc = nullptr;
  }

  for (u32 i = 0; i < self.docs.len(); ++i)
  {
    if (self.docs[i] == doc)
    {
      self.docs.remove(i);
      break;
    }
  }

  mem::stl_allocator.free(doc);
}

/* ----------------------------------------------------------------------------
 */
static void closeDocs(DocMgr& self, b8 all)
{
  for (s32 i = self.docs.len() - 1; i >= 0; --i)
  {
    if (all || self.docs[i]->flags.test(Doc::Flag::ToBeClosed))
    {
      Doc* doc = self.docs[i];

      self.editor->log.info("closing ", doc->title);

      DocTreeNode* node = nullptr;
      DocTreeNode* container = nullptr;
      findDocTreeNode(
          self, 
          &self.tree_root, 
          nullptr, 
          doc, 
          &node, 
          &container);

      closeDoc(self, node, container, doc);
    }
  }
}

/* ----------------------------------------------------------------------------
 */
void DocMgr::deinit()
{
  // Save doc state on close so its restored next time the editor is opened.
  // TODO(sushi) config for this behavior.
  cacheDocState();

  closeDocs(*this, true);

  docs.destroy();
  order.destroy();
}

/* ----------------------------------------------------------------------------
 */
static void initWindowDoc(DocMgr& self, Doc* doc, rtr::TypeId type)
{
  doc->editor = self.editor;
  doc->pos = { 50.f, 50.f };
  doc->size = { 300.f, 300.f };

  self.order.insert(0, self.docs.len());
  self.docs.push(doc);

  doc->onOpen();
}

/* ============================================================================
 *  Identifies the side of a split node. 
 *
 *  When SplitV, SplitSide::A is left and SplitSide::B is right.
 *  When SplitH, SplitSide::A is top and SplitSide::B is bottom.
 */
enum class SplitSide
{
  A, B
};

/* ----------------------------------------------------------------------------
 */
static inline f32 getSplitRatioSum(DocTreeNode* node)
{
  assert(node->isSplit());
  
  f32 sum = 0.f;
  for (DocTreeNode* child = node->split.first; child; child = child->next)
    sum += child->size;
  return sum;
}

/* ----------------------------------------------------------------------------
 */
static inline DocTreeNode* insertNode(
    DocMgr& self, 
    DocTreeNode* target,
    SplitSide side,
    f32 split_ratio)
{
  assert(target->isSplit());

  DocTreeNode* nu = self.tree_nodes.add();
  nu->parent = target;

  DocTreeNode* split_with = nullptr;
  if (side == SplitSide::A)
  {
    split_with = target->split.first;
    nu->next = target->split.first;
    target->split.first = nu;
  }
  else
  {
    split_with = target->split.last;
    target->split.last->next = nu;
    target->split.last = nu;
  }
  
  nu->size = floor(split_ratio * split_with->size);
  split_with->size -= nu->size;

  return nu;
}

/* ----------------------------------------------------------------------------
 */
static DocTreeNode* splitSingle(
    DocMgr& self, 
    DocTreeNode* target,
    DocTreeNode::State split,
    SplitSide side,
    f32 split_ratio)
{
  using enum DocTreeNode::State;

  assert(target->state == Single);

  f32 size_to_split;
  if (split == SplitV)
    size_to_split = target->last_displayed_size.x;
  else
    size_to_split = target->last_displayed_size.y;

  DocTreeNode* parent = target->parent;
  if (parent != nullptr && parent->state == split)
  {
    DocTreeNode* nu = self.tree_nodes.add();
    nu->state = Single;
    nu->parent = parent;

    DocTreeNode* a;
    DocTreeNode* b;

    if (side == SplitSide::A)
    {
      a = nu;
      b = target;
    }
    else
    {
      a = target;
      b = nu;
    }

    a->next = b;

    if (parent->split.first == target)
    {
      b->next = target->next;
      parent->split.first = a;
    }
    else
    {
      DocTreeNode* prev = findPrevNodeInContainer(target, parent);
      prev->next = a;

      if (parent->split.last == target)
        parent->split.last = b;
    }

    println("split ", target, " into ", nu);

    nu->size = floor(split_ratio * target->size);
    target->size -= nu->size;

    return nu;
  }
  else
  {
    DocTreeNode* a = self.tree_nodes.add();
    a->state = Single;
    a->doc = target->doc;
    a->parent = target;

    DocTreeNode* b = self.tree_nodes.add();
    b->parent = target;

    if (side == SplitSide::A)
    {
      target->split.first = b;
      target->split.last = a;
      b->next = a;
      b->size = floor(split_ratio * size_to_split);
      a->size = size_to_split - b->size;
    }
    else
    {
      target->split.first = a;
      target->split.last = b;
      a->next = b;
      a->size = floor(split_ratio * size_to_split);
      b->size = size_to_split - a->size;
    }

    target->state = split;
    target->doc = nullptr;

    return b;
  }
}

/* ----------------------------------------------------------------------------
 *  Splits 'target' which is expected to already be split. If the desired 
 *  axis is different, then a new split node is created. Otherwise the new 
 *  node is just appended.
 */
static inline DocTreeNode* splitSplit(
    DocMgr& self,
    DocTreeNode* target,
    DocTreeNode::State split,
    SplitSide side,
    f32 split_ratio)
{
  assert(target->isSplit());

  using enum DocTreeNode::State;

  // Just insert node when already in the same state.
  if (target->state == split)
    return insertNode(self, target, side, split_ratio);

  f32 size_to_split;
  if (split == SplitV)
    size_to_split = target->last_displayed_size.x;
  else
    size_to_split = target->last_displayed_size.y;

  // Otherwise we need to create a new split.
  DocTreeNode* a = self.tree_nodes.add();
  a->state = target->state;
  a->split = target->split;
  a->size = floor(split_ratio * size_to_split);
  a->parent = target;

  for (DocTreeNode* child = target->split.first; child; child = child->next)
    child->parent = a;

  DocTreeNode* b = self.tree_nodes.add();
  b->size = size_to_split - a->size;
  b->parent = target;

  if (side == SplitSide::A)
  {
    target->split.first = b;
    target->split.last = a;
    b->next = a;
  }
  else
  {
    target->split.first = a;
    target->split.last = b;
    a->next = b;
  }

  target->state = split;
  target->doc = nullptr;
  return b;
}

/* ----------------------------------------------------------------------------
 */
static inline DocTreeNode* splitNode(
    DocMgr& self, 
    DocTreeNode* target, 
    DocTreeNode::State split,
    SplitSide side,
    f32 split_ratio)
{
  using enum DocTreeNode::State;

  assert(target->state != Invalid);

  if (target->state == Single)
    return splitSingle(self, target, split, side, split_ratio);

  return splitSplit(self, target, split, side, split_ratio);
}

/* ----------------------------------------------------------------------------
 */
static Doc* allocateDocFromTypeId(DocMgr& self, rtr::TypeId type)
{
  Doc* doc = nullptr;
  switch (type.val)
  {
$ for doc in TDoc:allDerived() do
  case "$(doc.qname)"_typeid_val:
    doc = mem::stl_allocator.construct<$(doc.qname)>();
    doc->editor = self.editor;
    doc->title = "$(doc.name)"_str;
    doc->type = type;
    break;
$ end
  }
  
  if (doc != nullptr)
    self.docs.push(doc);

  return doc;
}

/* ----------------------------------------------------------------------------
 */
static Doc* openDoc(
    DocMgr& self, 
    rtr::TypeId type,
    DocTreeNode* destination,
    DocTreeNode::State split, 
    SplitSide side,
    f32 split_ratio)
{
  using enum DocTreeNode::State;

  Doc* doc = allocateDocFromTypeId(self, type);

  if (destination->state == Invalid)
  {
    destination->state = Single;
    destination->doc = doc;
    destination->size = 1.f;
  }
  else
  {
    DocTreeNode* nu = splitNode(self, destination, split, side, split_ratio);
    nu->state = Single;
    nu->doc = doc;
  }

  doc->onOpen();

  return doc;
}

/* ----------------------------------------------------------------------------
 */
static Doc* replaceDoc(
    DocMgr& self,
    rtr::TypeId type,
    DocTreeNode* node)
{
  using enum DocTreeNode::State;

  assert(node->state == Single);

  closeDoc(self, nullptr, nullptr, node->doc);

  f32 old_size = node->size;
  node->state = Invalid;
  Doc* doc = openDoc(self, type, node, SplitV, SplitSide::A, 0.f);
  node->size = old_size;
  return doc;
}

/* ----------------------------------------------------------------------------
 */
static void requestReplaceDoc(
    DocMgr& self, 
    DocTreeNode* node, 
    rtr::TypeId type)
{
  using enum DocTreeNode::State;

  assert(node->state == Single);

  if (self.replace_request.node != nullptr)
  {
    self.editor->log.warn("doc replace already requested");
    return;
  }

  self.replace_request.node = node;
  self.replace_request.type = type;
}

/* ----------------------------------------------------------------------------
 */
Doc* DocMgr::open(String name, b8 v, b8 a)
{
  using enum DocTreeNode::State;

  editor->log.info("opening document '", name, "'");

  Doc* doc = openDoc(
    *this, 
    typeIdFromDocName(name),
    &tree_root,
    v? SplitV : SplitH,
    a? SplitSide::A : SplitSide::B,
    0.5f);

  return doc;
}

/* ----------------------------------------------------------------------------
 */
void DocMgr::close(Doc* doc)
{
  doc->flags.set(Doc::Flag::ToBeClosed);
}

/* ----------------------------------------------------------------------------
 */
static inline void setCursorState(DocMgr& self, CursorState state)
{
  self.editor->cursor_state = state;
}

/* ----------------------------------------------------------------------------
 */
static void setCursorStateDivider(DocMgr& self, DocTreeNode::State split)
{
  if (split == DocTreeNode::State::SplitV)
    setCursorState(self, CursorState::ResizeH);
  else if (split == DocTreeNode::State::SplitH)
    setCursorState(self, CursorState::ResizeV);
}

/* ----------------------------------------------------------------------------
 */
static void putDocTreeNodeSingle(
    DocMgr& self, 
    ui::UI& ui, 
    DocTreeNode* node,
    const EditorSkinDef& skin)
{
  ui.pushId(ui.generateIdFromPointer(node->doc));
    
  Rect header_bounds = {};
  header_bounds.x = 0.f;
  header_bounds.y = 0.f;
  header_bounds.w = ui.getWidth();
  header_bounds.h = 15.f;

  ui.putTextItem(header_bounds, node->doc->title, skin.doc.header.text_item);

  const f32 close_button_size = 16.f;

  auto close_button_bounds = Rect::zero()
    .setSqSize(close_button_size)
    .alignRightInside(header_bounds, 4.f)
    .alignCenteredYInside(header_bounds);

  if (ui.putButton(
        "doc-close"_fid,
        close_button_bounds,
        nil,
        skin.doc.header.close_button))
  {
    node->doc->flags.set(Doc::Flag::ToBeClosed);
  }

  auto type_button_bounds = Rect::zero()
    .setSqSize(close_button_size)
    .alignLeftOutside(close_button_bounds, 4.f)
    .alignCenteredYInside(header_bounds);

  ui::CombinedItemId popupId = ui.getCombinedId("type-menu"_fid);

  b8 enabled = ui.isPopupOpen(popupId);
  if (ui.putCheckbox(
        "doc-type"_fid,
        type_button_bounds,
        &enabled,
        skin.doc.header.type_button))
  {
    if (enabled)
      ui.openPopup(popupId);
    else
      ui.closePopup(popupId);
  }

  Rect content_bounds = {};
  content_bounds.x = 0.f;
  content_bounds.y = header_bounds.h;
  content_bounds.w = ui.getWidth();
  content_bounds.h = ui.getHeight() - content_bounds.y;

  ui.beginGroup(content_bounds);
  node->doc->placeUI(ui, skin);
  ui.endGroup();

  auto type_menu_bounds = Rect::zero()
    .setSize(100.f, 100.f)
    .alignRightInside(type_button_bounds, 0.f)
    .alignBottomOutside(type_button_bounds, 0.f);

  if (ui.beginPopup(popupId, type_menu_bounds, 
          ui::PopupFlag::Dismissable
        | ui::PopupFlag::FocusOnOpen))
  {
    auto type_button_bounds = Rect::zero()
      .setSize(ui.getWidth(), 15.f);

$ for derived in TDoc:allDerived() do
    {
      if (ui.putButton(
            "type-$(derived.name)"_fid,
            type_button_bounds,
            "$(derived.name)"_str,
            skin.button))
      {
        requestReplaceDoc(self, node, "$(derived.qname)"_typeid);
      }
      type_button_bounds.y += type_button_bounds.h;
    }
$ end

    ui.endPopup();
  }

  // ui.putQuad(content_bounds, 0x44444499);
  //
  // io::SmallBuffer<128> ppbuf;
  // io::formatv(&ppbuf, node, '\n');
  // rtr::prettyPrint(&ppbuf, *node, 
  //   {.deref_ptrs = true, .depth_limit = 2});
  // ui.putText(content_bounds, String(ppbuf), skin.doc.header.text_item.text);

  ui.popId();
}

static void putDocTreeNode(
    DocMgr& self, 
    ui::UI& ui,
    DocTreeNode* node,
    const EditorSkinDef& skin);

/* ----------------------------------------------------------------------------
 */
static b8 putDocTreeNodeSplitCornerTests(
    DocMgr& self, 
    ui::UI& ui,
    DocTreeNode* node,
    Rect child_bounds,
    const EditorSkinDef& skin)
{
  f32 t = child_bounds.y;
  f32 l = child_bounds.x;
  f32 b = child_bounds.extentY();
  f32 r = child_bounds.extentX();

  vec2f corner_size = vec2f(4, 4);

  Rect corner_bounds = Rect::from(vec2f(0,0), corner_size);

  b8 hit = false;

  auto putTest = [&](ui::ItemId id, f32 x, f32 y)
  {
    corner_bounds.setPos(x, y); 
    // ui.putQuad(corner_bounds, 0xff0000ff);

    ui::FocusFlags corner_focus = ui.putFocusableBounds(id, corner_bounds);

    if (corner_focus.test(ui::FocusFlag::Hovered))
      setCursorState(self, CursorState::Cross);

    if (corner_focus.test(ui::FocusFlag::PrimaryPressed))
      hit = true;
  };

  putTest("tl-hit"_fid, l, t);
  putTest("tr-hit"_fid, r - corner_size.x, t);
  putTest("br-hit"_fid, r - corner_size.x, b - corner_size.x);
  putTest("bl-hit"_fid, l, b - corner_size.x);

  return hit;
}

/* ----------------------------------------------------------------------------
 */
static void handleDocTreeNodeSplitting(
    DocMgr& self,
    ui::UI& ui,
    DocTreeNode* node,
    Rect node_bounds,
    vec2f local_cursor,
    const EditorSkinDef& skin)
{
  using enum DocTreeNode::State;

  if (!node->isSplit())
  {
    if (putDocTreeNodeSplitCornerTests(
          self,
          ui,
          node,
          node_bounds,
          skin))
      node->splitting = true;
  }

  if (!node->splitting)
    return;

  vec2f child_local = local_cursor - node_bounds.pos();

  DocTreeNode::State split;
  Rect split_divider_bounds = {};
  f32 cursor_ratio = 0.5f;

  // Scale x so that the dividing line between h or v split is along the 
  // diagonal of the node. Would like to do this better eventually.
  f32 x_test = node_bounds.h / node_bounds.w * child_local.x;

  if (x_test >= child_local.y)
  {
    split_divider_bounds.x = node_bounds.x + child_local.x;
    split_divider_bounds.y = node_bounds.y;
    split_divider_bounds.w = skin.doc.divider_size;
    split_divider_bounds.h = node_bounds.h;
    split = SplitV;
    cursor_ratio = child_local.x / node_bounds.w;
  }
  else
  {
    split_divider_bounds.x = node_bounds.x;
    split_divider_bounds.y = node_bounds.y + child_local.y;
    split_divider_bounds.w = node_bounds.w;
    split_divider_bounds.h = skin.doc.divider_size;
    split = SplitH;
    cursor_ratio = child_local.y / node_bounds.h;
  }

  if (ui.frame_input.wasMouseButtonReleased(MouseButton::Left))
  {
    openDoc(
        self,
        node->doc->type,
        node,
        split,
        SplitSide::A,
        cursor_ratio);

    node->splitting = false;
  }

  ui.putQuad(split_divider_bounds, 0xffffffff);
}

/* ----------------------------------------------------------------------------
 */
static void addValueToSinglesAtEdgeOfSplits(
    DocTreeNode* node,
    DocTreeNode* root,
    DocTreeNode::State split,
    SplitSide side,
    f32 val)
{
  using enum DocTreeNode::State;

  if (node == nullptr)
    return;

  if (node->state == split)
  {
    DocTreeNode* side_node = side == SplitSide::A
      ? node->split.first 
      : node->split.last;
    addValueToSinglesAtEdgeOfSplits(
      side_node, 
      root, 
      split, 
      side,
      val);

    return;
  }

  if (node->isSplit())
  {
    for (DocTreeNode* child = node->split.first; child; child = child->next)
    {
      addValueToSinglesAtEdgeOfSplits(
        child, 
        root, 
        split, 
        side,
        val);
    }
  }

  if (node != root && 
      node->parent != nullptr &&
      node->parent->state == split)
  {
    node->size += val;
  }
}

/* ----------------------------------------------------------------------------
 */
static f32 putDocTreeNodeDivider(
    DocMgr& self,
    ui::UI& ui,
    Rect bounds,
    DocTreeNode* node,
    Rect node_bounds,
    DocTreeNode::State split_state,
    vec2f local_cursor,
    f32 divider_size,
    b8 is_h_split,
    f32 pos,
    const EditorSkinDef& skin)
{
  using enum DocTreeNode::State;

  Rect divider_bounds = {};

  if (is_h_split)
  {
    divider_bounds.x = bounds.x;
    divider_bounds.y = node_bounds.extentY();
    divider_bounds.w = bounds.w;
    divider_bounds.h = divider_size;
  }
  else
  {
    divider_bounds.x = node_bounds.extentX();
    divider_bounds.y = bounds.y;
    divider_bounds.w = divider_size;
    divider_bounds.h = bounds.h;
  }

  ui.putQuad(divider_bounds, 0x666666ff);

  ui::FocusFlags divider_focus = 
    ui.putFocusableBounds("divider"_fid, divider_bounds);

  if (divider_focus.test(ui::FocusFlag::Hovered))
    setCursorStateDivider(self, split_state);

  if (divider_focus.test(ui::FocusFlag::PrimaryPressed))
  {
    self.dragging_node = node;
    node->dragging = true;
  }

  if (node->dragging)
  {
    setCursorStateDivider(self, split_state);

    // Find the offset of the cursor into this pair along the proper 
    // split axis.
    f32 cursor_offset = 0.f;
    if (is_h_split)
      cursor_offset = local_cursor.y - node_bounds.y;
    else
      cursor_offset = local_cursor.x - node_bounds.x;

    cursor_offset = floor(cursor_offset);

    self.drag_desired_size = cursor_offset;
  }

  return pos + divider_size;
}

/* ----------------------------------------------------------------------------
 */
static Rect computeChildBounds(Rect bounds, f32 start, f32 end, b8 is_h_split)
{
  Rect child_bounds;
  if (is_h_split)
  {
    child_bounds.x = bounds.x;
    child_bounds.y = start;
    child_bounds.w = bounds.w;
    child_bounds.h = end - start;
  }
  else
  {
    child_bounds.x = start;
    child_bounds.y = bounds.y;
    child_bounds.w = end - start;
    child_bounds.h = bounds.h;
  }
  return child_bounds;
}

/* ----------------------------------------------------------------------------
 */
static void putDocTreeNodeSplit(
    DocMgr& self, 
    ui::UI& ui,
    DocTreeNode* node,
    const EditorSkinDef& skin)
{
  using enum DocTreeNode::State;

  ui.pushId(ui.generateIdFromPointer(node));
  defer { ui.popId(); };

  b8 is_h_split = node->state == SplitH;

  vec2f local_cursor = ui.getLocalCursorPos();

  Rect bounds = ui.getBounds();

  u32 child_count = calcSplitCount(node);

  s32 num_dividers = child_count - 1;

  const f32 divider_size = skin.doc.divider_size;
  const f32 divider_half_size = divider_size / 2.f;

  f32 total_divider_size = divider_size * num_dividers;

  f32 children_space = 0.f;
  if (is_h_split)
    children_space = bounds.h - total_divider_size;
  else
    children_space = bounds.w - total_divider_size;

  f32 pos = 0.f;
  f32 size_sum = 0.f;
  u32 child_idx = 0;
  for (DocTreeNode* child = node->split.first; child; 
       child = child->next, child_idx += 1)
  {
    ui.pushId(ui.generateIdFromPointer(child));
    defer { ui.popId(); };

    f32 start = pos;
    f32 end = start + child->size;

    size_sum += child->size;

    Rect child_bounds = computeChildBounds(bounds, start, end, is_h_split);

    pos = end;

    ui.beginPanel("doc-content"_fid, child_bounds);
    {
      putDocTreeNode(self, ui, child, skin);
    }
    ui.endPanel();

    handleDocTreeNodeSplitting(
      self, 
      ui,
      child,
      child_bounds,
      local_cursor,
      skin);
  
    if (child->next != nullptr)
    {
      pos = 
        putDocTreeNodeDivider(
          self,
          ui,
          bounds,
          child,
          child_bounds,
          node->state,
          local_cursor,
          divider_size,
          is_h_split,
          pos,
          skin);
     }
  }

  f32 desired_pos = is_h_split? bounds.h : bounds.w;
  if (pos != desired_pos)
  {
    f32 size_sum = getSplitRatioSum(node);

    f32 diff = size_sum - children_space;

    if (diff > 0)
    {
      f32 remaining = diff;
      for (DocTreeNode* child = node->split.first; child; child = child->next)
      {
        f32 take = floor((child->size / size_sum) * diff);
        child->size -= take;
        remaining -= take;
        if (child->next == nullptr)
          child->size -= remaining;
      }
    }
    else 
    {
      diff = -diff;
      f32 remaining = diff;
      for (DocTreeNode* child = node->split.first; child; child = child->next)
      {
        f32 take = floor((child->size / size_sum) * diff);
        child->size += take;
        remaining -= take;
        if (child->next == nullptr)
          child->size += remaining;
      }
    }
  }

  // ui.putQuad(bounds.contracted(30.f), 0x33eeaa33);
}

/* ----------------------------------------------------------------------------
 */
static void putDocTreeNode(
    DocMgr& self, 
    ui::UI& ui,
    DocTreeNode* node,
    const EditorSkinDef& skin)
{
  using enum DocTreeNode::State;

  if (node->state == Invalid)
    return;

  if (node->state == Single)
    putDocTreeNodeSingle(self, ui, node, skin);
  else
    putDocTreeNodeSplit(self, ui, node, skin);

  node->last_displayed_size = ui.getBounds().size();
}

/* ----------------------------------------------------------------------------
 */
static void handleDraggedNode(
    DocMgr& self, 
    ui::UI& ui, 
    const EditorSkinDef& skin)
{
  using enum DocTreeNode::State;

  DocTreeNode* node = self.dragging_node;
  if (node == nullptr)
    return;

  f32 pair_size = node->size + node->next->size;

  f32 old_node_size = node->size;

  node->size = self.drag_desired_size;
  node->next->size = pair_size - node->size;

  f32 size_delta = old_node_size - node->size;

  DocTreeNode* prev = findPrevNodeInContainer(node, node->parent);

  addValueToSinglesAtEdgeOfSplits(
    node, 
    node,
    node->parent->state,
    SplitSide::B,
    -size_delta);

  addValueToSinglesAtEdgeOfSplits(
    node->next, 
    node->next,
    node->parent->state,
    SplitSide::A,
    size_delta);

  if (ui.frame_input.wasMouseButtonReleased(MouseButton::Left))
  {
    node->dragging = false;
    self.dragging_node = nullptr;
  }
}

/* ----------------------------------------------------------------------------
 */
void DocMgr::placeUI(ui::UI& ui, const EditorSkinDef& skin)
{
  handleDraggedNode(
    *this,
    ui,
    skin);

  putDocTreeNode(
    *this,
    ui,
    &tree_root,
    skin);
}

/* ----------------------------------------------------------------------------
 */
void DocMgr::update()
{
  // Close any docs marked to be closed.
  closeDocs(*this, false);

  if (replace_request.node != nullptr)
  {
    replaceDoc(
      *this, 
      replace_request.type, 
      replace_request.node);

    replace_request.node = nullptr;
  }

  // Update each open doc.
  for (Doc* doc : docs)
    doc->update();
}

/* ----------------------------------------------------------------------------
 */
void DocMgr::render(gfx::Vulkan& vk)
{
  for (Doc* doc : docs)
    doc->render(vk);
}

/* ----------------------------------------------------------------------------
 */
static void cacheDocTreeNodeState(
    DocMgr& self, 
    DocTreeNode* node,
    SourceDataFile& sfile,
    SourceData& sdata)
{
  using enum DocTreeNode::State;
  
  sdata.setObject(nil);
  
  if (node->state == Single)
  {
    sdata.type = "single"_str;

    sdata.addStringValue(sfile, 
      "title"_str, node->doc->title);
    sdata.addStringValue(sfile, 
      "type"_str, docNameFromTypeId(node->doc->type));
    sdata.addUIntValue(sfile,
      "size"_str, node->size);
  }
  else if (node->isSplit())
  {
    sdata.type = node->isSplitV()? "split_v"_str : "split_h"_str;
    sdata.addUIntValue(sfile, "size"_str, node->size);

    SourceData* split = sdata.addObject(sfile, "split"_str);

    for (DocTreeNode* child = node->split.first; child; child = child->next)
    {
      SourceData* child_data = split->addObject(sfile, nil);
      cacheDocTreeNodeState(self, child, sfile, *child_data);
    }
  }
}

/* ----------------------------------------------------------------------------
 */
void DocMgr::cacheDocState()
{
  editor->log.info("caching document state");

  SourceDataFile sfile = {};
  sfile.init();
  defer { sfile.deinit(); };

  SourceData* root = sfile.addReturnData();

  cacheDocTreeNodeState(*this, &tree_root, sfile, *root); 

  editor->cacheSourceDataFile(sfile, "doc-cache"_str);
}

/* ----------------------------------------------------------------------------
 */
static void loadCachedDocTreeNode(
    DocMgr& self, 
    DocTreeNode* node,
    SourceData& sdata)
{
  using enum DocTreeNode::State;

  if (sdata.type == "single"_str)
    node->state = Single;
  else if (sdata.type == "split_v"_str)
    node->state = SplitV;
  else if (sdata.type == "split_h"_str)
    node->state = SplitH;
  else
    return; 

  SourceData* size_data = sdata.findChildByName("size"_str);

  node->size = size_data->as_f32();

  if (node->state == Single)
  {
    SourceData* doc_type_data = sdata.findChildByName("type"_str);
    rtr::TypeId type = typeIdFromDocName(doc_type_data->val.str);

    node->doc = allocateDocFromTypeId(self, type);

    node->doc->onOpen();
  }
  else
  {
    SourceData* split_data = sdata.findChildByName("split"_str);

    for (SourceData* child : split_data->children)
    {
      DocTreeNode* child_node = self.tree_nodes.add();
      child_node->parent = node;

      if (node->split.first == nullptr)
      {
        node->split.first = child_node;
        node->split.last = child_node;
      }
      else
      {
        node->split.last->next = child_node;
        node->split.last = child_node;
      }
    
      loadCachedDocTreeNode(self, child_node, *child);
    }
  }
}

/* ----------------------------------------------------------------------------
 */
void DocMgr::loadCachedDocState()
{
  closeDocs(*this, true);

  SourceDataFile sfile;
  if (!editor->loadCachedSourceDataFile(&sfile, "doc-cache"_str))
    return;
  defer { sfile.deinit(); };

  loadCachedDocTreeNode(*this, &tree_root, *sfile.returned_data);
}

}
