$ require "common"

$ -- TODO(sushi) make a reflect.import or something.
$ local ast = require "reflect.ast"
$ local astctx, imported = require "reflect.AstContext" 
$                          .fromGlobs { "src/editor/docs/MapEditor.lh" }
$(imported)

@lpp.import "editor/Editor.lh"

@lpp.import "game/client/structure/StructureVisualizer.sys.lh"
@lpp.import "game/shared/Collider.comp.lh"

@lpp.import "graphics/Geo.lh"
@lpp.import "graphics/BatchRenderer.lh"

@lpp.import "window/Window.events.lh"

@lpp.import "reflect/CompiledData.lh"
@lpp.import "reflect/Unpacking.lh"

$ local TTool = assert(astctx:lookupTypeDecl "editor::MapEditor::Tool")

namespace editor
{

using Tool = MapEditor::Tool;

static const f32 c_map_render_w = 2048;
static const f32 c_map_render_h = 2048;

/* ----------------------------------------------------------------------------
 */
static inline b8 recreateMapTexture(gfx::Vulkan& vk, gfx::Texture* texture)
{
  texture->destroy(vk);

  *texture = gfx::Texture::createForRenderTarget(vk,
  {
    .size = vec2u(c_map_render_w, c_map_render_h),
    .debug_name = "map render texture"_str,
  });

  return notnil(*texture);
}

/* ----------------------------------------------------------------------------
 *  Reloads the map state (and entity state) of the current source data file 
 *  stored by MapEditor.
 */
static b8 reloadMapState(MapEditor& self)
{
  self.entity_mgr.destroyAllEntities();
  self.map_def_packed.deinit();

  self.map_def_packed.init();

  reflect::PackParams pack_params;
  pack_params.packed = &self.map_def_packed;

  if (!reflect::packSourceDataFromType(
        *self.sdf_map_def.returned_data,
        pack_params))
    return false;

  auto* def = self.map_def_packed.getDataAs<MapDef>();

  self.editor->getLinker().link("MapDef"_typeid, def);

  MapLoadParams map_load_params = 
  {
    .entmgr = self.entity_mgr,
    .log = &self.editor->log,
  };

  if (!loadMap(&self.map_state, *def, map_load_params))
    return false;

  // Call StructureVisualizer's helper for updating structure sprite states
  // so that they appear properly in the render.
  cl::updateAllStructureAppearances(self.map_state, self.entity_mgr);

  return true;
}

/* ----------------------------------------------------------------------------
 *  Loads the map state from the source data file at `path`.
 */
static b8 loadMapState(MapEditor& self, String path)
{
  self.sdf_map_def.deinit();

  if (!SourceDataFile::from(&self.sdf_map_def, path))
    return false;

  return reloadMapState(self);
}

/* ----------------------------------------------------------------------------
 */
b8 MapEditor::init()
{
  if (!entity_mgr.init())
    return editor->log.error("failed to init entity manager");

  reflect::Linker linker = 
  {
    .asset_mgr = editor->asset_mgr,
    .resource_mgr = editor->resource_mgr,
  };

  cl::GameRenderer::InitParams game_renderer_params = 
  {
    .vk = *editor->vk,
    .linker = linker,
  };

  if (!game_renderer.init(game_renderer_params))
    return editor->log.error("failed to init game renderer");

  loadMapState(*this, "assets/maps/Test.map"_str);

  if (!recreateMapTexture(*editor->vk, &map_render))
    return editor->log.error("failed to create map texture");

  sd_editor.init();

  editor->event_bus->subscribeTo<WindowFocusChange, MapEditor>(this,
    [](auto& self, auto& ev) -> void
    {
      if (!ev.has_focus)
        self.control_state = ControlState::None;
    });

  return true;
}

/* ----------------------------------------------------------------------------
 */
template<typename TComp>
static TComp* tryComp(MapEditor& self, EntityId id)
{
  return self.entity_mgr.tryComp<TComp>(id);
}

/* ============================================================================
 *  Bundle of state related to the view of the map computed in putUI() and 
 *  fed down into helpers. This is intended to be immutable.
 */
struct MapViewState
{
  // Focus of the map state from UI, eg. is it hovered, focused, was a 
  // mouse button clicked etc.
  ui::Focus focus;

  // Position of the cursor relative to the map view's position on screen 
  // and its position in world space.
  vec2f local_cursor;
  vec2f world_cursor;
};

/* ============================================================================
 *  State that helpers use to indicate if they have changed the map, which 
 *  is used in putUI() to decide if the map needs to be reloaded.
 */
struct MapViewResult
{
  b8 changed_tile;
};

/* ----------------------------------------------------------------------------
 */
static void handleDragState(
    MapEditor& self,
    ui::UI& ui,
    const MapViewState& state)
{
  using enum MapEditor::ControlState;
  using Focus = ui::FocusFlag;

  switch (self.control_state)
  {
  case None:
    if (state.focus.wasTertiaryPressed())
    {
      self.drag_start_viewport = state.local_cursor;
      self.drag_start_world = self.view.pos;
      self.control_state = DraggingView;
    }
    break;

  case DraggingView:
    {
      vec2f offset = self.view.viewportPointToWorld(
        self.drag_start_viewport, 
        self.map_view_size);

      self.view.pos = self.drag_start_world + offset - state.world_cursor;

      // Check if middle mouse is released anywhere to avoid the drag state 
      // getting stuck.
      if (ui.wasTertiaryReleasedGlobally())
        self.control_state = None;
    } 
    break;
  }
}

/* ----------------------------------------------------------------------------
 */
static void handleScrollState(
    MapEditor& self,
    ui::UI& ui,
    const MapViewState& state)
{
  if (!state.focus.isHovered())
    return;

  f32 scroll = ui.frame_input.getScroll();
  if (scroll != 0.f)
  {
    ui.frame_input.consumeScroll();

    if (ui.frame_input.isKeyDown(Key::LShift))
    {
      self.view.rotation += scroll * degreesToRadians(1.f);
    }
    else
    {
      self.view.zoom -= self.view.zoom / 10.f * scroll;

      self.view.zoom = max(1e-3f, min(1e4f, self.view.zoom)); 

      vec2f new_world_cursor = self.view.viewportPointToWorld(
        state.local_cursor, 
        self.map_view_size);

      self.view.pos -= new_world_cursor - state.world_cursor;
    }
  }
}

/* ----------------------------------------------------------------------------
 */
static void reloadEntitySourceDataFile(
    MapEditor& self,
    EntityId id)
{
  SourceDataFile* sfile = &self.sdf_selected_entity_def;
  sfile->deinit();

  Entity* selected = self.entity_mgr.getEntity(self.selected_entity);
  if (selected == nullptr)
    // Must have selected empty space.
    return;

  fs::PathBuffer def_path;
  io::formatv(&def_path, selected->def_name, ".entity"_str);

  if (!SourceDataFile::from(sfile, String(def_path)))
  {
    self.editor->log.error(
      "failed to load def source data for entity ", id, " from '",
      String(def_path), "'");
    return;
  }

  self.sd_editor.setSourceData(
    sfile->returned_data,
    sfile,
    "EntityDef"_typeid);
}

/* ----------------------------------------------------------------------------
 */
static void handleEntitySelection(
    MapEditor& self,
    ui::UI& ui,
    const MapViewState& state,
    Layer& layer,
    Tile& tile)
{
  u32 layer_idx = self.map_state.getLayerIndex(layer);

  EntityMgr::Iter ent_iter(self.entity_mgr);
  for (; ent_iter.isValid(); ent_iter.next())
  {
    EntityId id = ent_iter.current();
    
    const auto* transform = tryComp<Transform>(self, id);
    if (transform == nullptr || transform->placement_layer != layer_idx)
      continue;

    const auto* collider = tryComp<Collider>(self, id);
    if (collider == nullptr)
      continue;

    Rect collider_bounds = collider->def->bounds;
    collider_bounds.addPos(transform->pos + vec2f(layer.pos));

    if (collider_bounds.containsPoint(state.world_cursor))
    {
      self.hovered_entity = id;
      break;
    }
  }

  if (ui.frame_input.wasMouseButtonPressed(MouseButton::Left))
  {
    b8 new_selection = self.hovered_entity != self.selected_entity;

    self.selected_entity = self.hovered_entity;

    if (new_selection)
      reloadEntitySourceDataFile(self, self.selected_entity);
  }
}

/* ----------------------------------------------------------------------------
 */
static void handlePaintTile(
    MapEditor& self,
    ui::UI& ui,
    const MapViewState& state,
    MapViewResult& result,
    Layer* layer,
    Tile* tile)
{

}

/* ----------------------------------------------------------------------------
 */
static void handleMapAndEntityCursorInteraction(
    MapEditor& self,
    ui::UI& ui,
    const MapViewState& state,
    MapViewResult& result)
{
  self.hovered_layer_idx = -1;
  self.hovered_tile_idx = -1;
  self.hovered_entity = nil;

  if (!state.focus.isHovered())
    return;

  Tile* tile = nullptr;
  Layer* layer = nullptr;
  b8 got_tile_layer = self.map_state.getTileAndLayerAtPos(
      &layer, 
      &tile, 
      state.world_cursor);

  if (got_tile_layer)
  {
    self.hovered_tile_idx = self.map_state.getLayerIndex(*layer);
    self.hovered_layer_idx = layer->getTileIndex(*tile);
  }

  switch (self.selected_tool)
  {
  case Tool::None:
    if (got_tile_layer)
      handleEntitySelection(self, ui, state, *layer, *tile);
    break;
  case Tool::PaintTile:
    handlePaintTile(self, ui, state, result, layer, tile);
    break;
  }
}

/* ----------------------------------------------------------------------------
 */
static void handleControlInputs(
    MapEditor& self, 
    ui::UI& ui, 
    const MapViewState& state,
    MapViewResult& result,
    const EditorSkinDef& skin)
{
  handleDragState(self, ui, state);
  handleScrollState(self, ui, state);
  handleMapAndEntityCursorInteraction(self, ui, state, result);
}

/* ----------------------------------------------------------------------------
 */
static void putMapView(
    MapEditor& self, 
    ui::UI& ui, 
    Rect bounds,
    const MapViewState& state,
    MapViewResult& result,
    const EditorSkinDef& skin)
{
  // Since we render the map into a texture much larger than the size
  // we actually render it at, we have to compute the proper uv's to 
  // use for the texture.
  auto uv = vec4f(0,0,0,0);
  uv.z = bounds.w / c_map_render_w;
  uv.w = bounds.h / c_map_render_h;

  ui.putQuad(bounds, self.map_render.getHandle(), uv, 0xffffffff);

  handleControlInputs(self, ui, state, result, skin);
}

/* ----------------------------------------------------------------------------
 */
static void putToolSelect(
    MapEditor& self,
    ui::UI& ui,
    Rect bounds,
    const EditorSkinDef& skin)
{
  String selected_text = nil;
  switch (self.selected_tool)
  {
$ for elem in TTool.elems:each() do
  case Tool::$(elem.name):
    selected_text = "$(elem.name)"_str;
    break;
$ end
  }

  if (ui.beginDropDown("map_editor.tool_select"_fid,
        bounds,
        90.f,
        selected_text,
        skin.dropdown))
  {
    Rect button_bounds;
    button_bounds.x = 0.f;
    button_bounds.y = 0.f;
    button_bounds.w = ui.getWidth();
    button_bounds.h = 14.f;

$ for elem in TTool.elems:each() do
    if (self.selected_tool != Tool::$(elem.name))
    {
      if (ui.putButton("map_editor.tool_select.$(elem.name)"_fid,
            button_bounds,
            "$(elem.name)"_str,
            skin.text_button))
      {
        self.selected_tool = Tool::$(elem.name);
        ui.closePopup();
      }

      button_bounds.y += button_bounds.h;
    }
$ end

    ui.endDropDown();
  }
}

/* ----------------------------------------------------------------------------
 */
static void putToolMenu(
    MapEditor& self,
    ui::UI& ui,
    const MapViewState& state,
    MapViewResult& result,
    const EditorSkinDef& skin)
{
  const f32 sde_height = 300.f;

  io::StaticBuffer<128> buffer;
  io::formatv(&buffer, floor(state.world_cursor), '\n');

  io::formatv(&buffer, "selected: "_str, self.selected_entity, '\n');
  io::formatv(&buffer, "hovered: "_str, self.hovered_entity, '\n');

  if (Entity* ent = self.entity_mgr.getEntity(self.selected_entity))
  {
    io::formatv(&buffer, "selected def: "_str, ent->def_name, '\n'); 
  }

  vec2f text_size = 
    ui.putText(Rect::from(0,0,0,0), String(buffer), skin.text);

  f32 y = text_size.y + 4.f;

  Rect sde_bounds;
  sde_bounds.x = 2.f;
  sde_bounds.y = y;
  sde_bounds.w = ui.getWidth() - 2.f * sde_bounds.x;
  sde_bounds.h = sde_height;

  self.sd_editor.put(ui, sde_bounds, skin.sdata_edit);

  y += sde_height + 4.f;

  Rect select_bounds;
  select_bounds.x = 2.f;
  select_bounds.y = y;
  select_bounds.w = ui.getWidth() - 2.f * select_bounds.x;
  select_bounds.h = 14.f;

  putToolSelect(self, ui, select_bounds, skin);
}

/* ----------------------------------------------------------------------------
 */
void MapEditor::putUI(ui::UI& ui, const EditorSkinDef& skin)
{
  const f32 tool_menu_width = 400.f;

  Rect map_view_bounds = {};
  map_view_bounds.x = tool_menu_width;
  map_view_bounds.y = 0.f;
  map_view_bounds.w = ui.getWidth() - map_view_bounds.x;
  map_view_bounds.h = ui.getHeight();

  // Save the view size for the next time we go to render.
  map_view_size = map_view_bounds.size();

  Rect tool_menu_bounds = {};
  tool_menu_bounds.x = 0.f;
  tool_menu_bounds.y = 0.f;
  tool_menu_bounds.w = tool_menu_width;
  tool_menu_bounds.h = ui.getHeight();

  MapViewState view_state;
  view_state.local_cursor = ui.getLocalCursorPos() - map_view_bounds.pos();
  view_state.world_cursor = view.viewportPointToWorld(
    view_state.local_cursor,
    map_view_size);
  view_state.focus = ui.putFocusableBounds("game-view"_fid, map_view_bounds);

  MapViewResult view_result;

  putMapView(
    *this,
    ui,
    map_view_bounds,
    view_state,
    view_result,
    skin);

  ui.beginPanel("map-editor.tool-menu"_fid, tool_menu_bounds);
  {
    putToolMenu(
      *this,
      ui,
      view_state,
      view_result,
      skin);
  }
  ui.endPanel();
}

/* ----------------------------------------------------------------------------
 *  Computes the size of a pixel on screen in the world. Used to properly
 *  size things drawn in the map view so that they appear consistently sized on 
 *  screen.
 */
static vec2f getWorldPixelSize(MapEditor& self)
{
  return self.viewportToWorld(vec2f(1.f, 1.f)) - 
         self.viewportToWorld(vec2f(0.f, 0.f));
}

/* ----------------------------------------------------------------------------
 */
static void placeGrid(MapEditor& self, gfx::BatchRenderer& br)
{
  // Get where the top-left and top-right of the viewport correspond to 
  // in the world.
  vec2f world_view_origin = self.viewportToWorld(vec2f(0.f, 0.f));
  vec2f world_view_extent = self.viewportToWorld(self.map_view_size);

  // Used to determine thickness of lines as drawn in the world so that 
  // they appear with a consistent thickness on screen.
  vec2f world_pixel_size = 
    self.viewportToWorld(vec2f(1.f, 1.f)) - world_view_origin;

  vec2f world_view_size = world_view_extent - world_view_origin;

  f32 grid_sep = max(1.f, math::round(self.view.zoom * 2.f));

  vec2f grid_start;
  grid_start.x = roundDownTo(world_view_origin.x, grid_sep);
  grid_start.y = roundDownTo(world_view_origin.y, grid_sep);

  vec2f grid_end;
  grid_end.x = roundUpTo(world_view_extent.x, grid_sep);
  grid_end.y = roundDownTo(world_view_extent.y, grid_sep);

  for (f32 x = grid_start.x; x <= grid_end.x; x += grid_sep)
  {
    br.drawLine(
      vec2f(x, world_view_origin.y),
      vec2f(x, world_view_extent.y),
      2.f * world_pixel_size.x, 
      0x77777788);
  }

  for (f32 y = grid_start.y; y >= grid_end.y; y -= grid_sep)
  {
    br.drawLine(
      vec2f(world_view_origin.x, y),
      vec2f(world_view_extent.x, y),
      2.f * world_pixel_size.x, 
      0x77777788);
  }
}

/* ----------------------------------------------------------------------------
 */
static void outlineEntityCollider(
    MapEditor& self,
    gfx::BatchRenderer& br,
    EntityId id, 
    Color color)
{
  if (isnil(id))
    return;

  auto* transform = tryComp<Transform>(self, id);
  auto* collider = tryComp<Collider>(self, id);

  if (collider)
  {
    Layer* layer = 
      self.map_state.getLayerByIndex(transform->placement_layer);

    Rect collider_bounds = collider->def->bounds;
    collider_bounds.addPos(transform->pos + vec2f(layer->pos));

    f32 thickness = getWorldPixelSize(self).x;

    br.drawBorder(collider_bounds, thickness, color);
  }
}

/* ----------------------------------------------------------------------------
 */
void MapEditor::render(gfx::Vulkan& vk)
{
  gfx::RenderTarget target = 
  {
    .image = map_render.image,
    .view = map_render.view,
  };

  cl::GameRenderer::RenderParams render_params = 
  {
    .entmgr = &entity_mgr,
    .map = &map_state,
    .viewport_size = vec2u(map_view_size),
    .vk = vk,
    .target = target,
    .view = view.getViewMat(),
  };

  gfx::RenderPass pass;
  if (!gfx::vk::beginRenderPass(
        &vk,
        &pass,
        target,
        vec2i(0,0),
        vec2u(map_view_size),
        0x000000ff))
    return;

  game_renderer.updateSceneBuffer(vk, map_view_size, view.getViewMat());

  gfx::VertexBufferView vbv;
  gfx::IndexBufferView ibv;
  game_renderer.mapBuffersAndGetViews(vk, &vbv, &ibv);

  gfx::BatchRenderer br;
  br.init(&pass, vbv, ibv);

  br.begin();

  br.setPipeline(game_renderer.quad_pipeline_link.getHandle());

  pass.bindVertexBuffer(game_renderer.quad_buffers.vertex);
  pass.bindIndexBuffer(game_renderer.quad_buffers.index);
  pass.bindUniformBuffer(game_renderer.scene_uniform_buffer);

  pass.setViewport({0,0}, map_view_size);
  pass.setScissor({0,0}, vec2u(map_view_size));
  
  game_renderer.renderMapState(vk, br, map_state);
  
  br.setTexture(editor->l_white_texture.getHandle());
  placeGrid(*this, br);

  game_renderer.renderSprites(vk, br, map_state, entity_mgr);

  br.setTexture(editor->l_white_texture.getHandle());
  outlineEntityCollider(*this, br, selected_entity, 0x00ff00ff);
  outlineEntityCollider(*this, br, hovered_entity, 0x0000ffff);

  br.end();

  game_renderer.unmapBuffers(vk);

  gfx::vk::endRenderPass(&vk);

  gfx::vk::prepareImageForSampling(&vk, map_render.image);
}

}
