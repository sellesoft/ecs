$ require "common"

$ -- TODO(sushi) make a reflect.import or something.
$ local ast = require "reflect.ast"
$ local astctx, imported = require "reflect.AstContext" 
$                          .fromGlobs { "src/editor/docs/SceneEditor.lh" }
$(imported)

@lpp.import "editor/Editor.lh"
@lpp.import "editor/EditorUIFuncs.lh"

@lpp.import "game/client/structure/StructureVisualizer.sys.lh"
@lpp.import "game/shared/map/Map.sys.lh"
@lpp.import "game/shared/SpriteFuncs.lh"
@lpp.import "game/shared/Collider.comp.lh"
@lpp.import "game/shared/SceneLoader.lh"
@lpp.import "game/shared/SceneSerializer.lh"
@lpp.import "game/shared/Placement.sys.lh"

@lpp.import "graphics/Geo.lh"
@lpp.import "graphics/BatchRenderer.lh"

@lpp.import "window/Window.events.lh"

@lpp.import "reflect/CompiledData.lh"
@lpp.import "reflect/Unpacking.lh"

#include "iro/fs/Glob.h"

$ local TTool = assert(astctx:lookupTypeDecl "editor::SceneEditor::Tool")

namespace editor
{

using Tool = SceneEditor::Tool;
using ControlState = SceneEditor::ControlState;

static const f32 c_map_render_w = 2048;
static const f32 c_map_render_h = 2048;

/* ----------------------------------------------------------------------------
 */
static inline b8 recreateMapTexture(gfx::Vulkan& vk, gfx::Texture* texture)
{
  texture->destroy(vk);

  *texture = gfx::Texture::createForRenderTarget(vk,
  {
    .size = vec2u(c_map_render_w, c_map_render_h),
    .debug_name = "map render texture"_str,
  });

  return notnil(*texture);
}

/* ----------------------------------------------------------------------------
 */
static inline b8 initGameSubSystems(SceneEditor& self)
{
  if (!self.game_log.init())
    return self.editor->log.error("failed init game log");

  if (!self.entity_mgr.init(&self.game_log))
    return self.editor->log.error("failed to init entity manager");

  cl::EntitySysMgr::InitParams ent_sys_mgr_params = 
  {
    {
      .entmgr = self.entity_mgr,
      .log = self.game_log,
    }
  };

  if (!self.entity_sys_mgr.init(ent_sys_mgr_params))
    return self.editor->log.error("failed to init entity system manager");

  return true;
}

/* ----------------------------------------------------------------------------
 */
static inline void deinitGameSubSystems(SceneEditor& self)
{
  self.game_log.deinit();
  self.entity_mgr.deinit();
  self.entity_sys_mgr.deinit();
}

/* ----------------------------------------------------------------------------
 */
static inline b8 reinitGameSubSystems(SceneEditor& self)
{
  deinitGameSubSystems(self);
  return initGameSubSystems(self);
}

/* ----------------------------------------------------------------------------
 */
static b8 reloadSceneFromDef(SceneEditor& self, SceneDef& def)
{
  reinitGameSubSystems(self);

  self.link("SceneDef"_typeid, &def);

  SceneLoadParams load_params = 
  {
    .entmgr = self.entity_mgr,
    .log = &self.game_log,
  };

  if (!loadScene(def, load_params))
    return self.editor->log.error("failed to load scene");

  return true;
}

/* ----------------------------------------------------------------------------
 */
static void beginSelectedEntityPlacement(SceneEditor& self)
{
  if (!self.hasLoadableSelectedEntity())
    return;

  self.placement_entity = self.entity_mgr.spawnEntity(
    self.selected_entity_asset->l_def,
    nil);
}

/* ----------------------------------------------------------------------------
 */
static void endSelectedEntityPlacement(SceneEditor& self)
{
  if (notnil(self.placement_entity))
    self.entity_mgr.destroyEntity(self.placement_entity);

  self.placement_entity = nil;
}

/* ----------------------------------------------------------------------------
 *  Replaces the current placement entity (if any) with a new one.
 */
static void replacePlacementEntity(SceneEditor& self)
{
  endSelectedEntityPlacement(self);
  beginSelectedEntityPlacement(self);
}

/* ----------------------------------------------------------------------------
 */
void serializeSceneState(
    SceneEditor& self, 
    SceneDef* def,
    mem::Bump* allocator)
{
  // Remove possible placement entity so its not serialized in to the scene.
  endSelectedEntityPlacement(self);

  SerializeSceneParams params = 
  {
    .entity_mgr = self.entity_mgr,
    .allocator = allocator,
    .log = &self.game_log,
  };

  serializeScene(def, params);

  replacePlacementEntity(self);
}

/* ----------------------------------------------------------------------------
 */
void unpackScene(SceneEditor& self, const SceneDef& def, SourceDataFile* sfile)
{
  reflect::UnpackParams unpack_params = 
  {
    .type = "SceneDef"_typeid,
    .data = bytesOf(def),
    .sfile = sfile
  };

  SourceData* unpacked = reflect::unpackData(unpack_params);

  sfile->returned_data = unpacked;
}

/* ----------------------------------------------------------------------------
 */
void serializeAndUnpackScene(SceneEditor& self, SourceDataFile* sfile)
{
  SceneDef def;
  mem::StackBump bump;

  serializeSceneState(self, &def, &bump);

  sfile->init();

  unpackScene(self, def, sfile);
}

/* ----------------------------------------------------------------------------
 */
static void saveScene(SceneEditor& self)
{
  self.save_failed = false;

  SourceDataFile sfile;
  serializeAndUnpackScene(self, &sfile);
  defer { sfile.deinit(); };

  fs::PathBuffer scene_path;
  io::formatv(&scene_path, String(self.loaded_scene_name), ".scene"_str);

  auto file = fs::File::createForTruncatedWriting(String(scene_path));

  if (isnil(file))
  {
    self.save_failed = true;
    return;
  }

  sfile.dump(&file);
  file.close();

  self.saved_snapshot = self.current_snapshot;
}

/* ----------------------------------------------------------------------------
 */
static SceneSnapshot* createSceneSnapshot(SceneEditor& self)
{
  SceneSnapshot* snapshot = self.scene_snapshots.push();
  snapshot->packed.init();
  return snapshot;
}

/* ----------------------------------------------------------------------------
 */
static void destroySceneSnapshot(SceneEditor& self, SceneSnapshot* snapshot)
{
  snapshot->packed.deinit();
}

/* ----------------------------------------------------------------------------
 */
static void captureSceneSnapshot(SceneEditor& self)
{
  SourceDataFile sfile;
  serializeAndUnpackScene(self, &sfile);
  defer { sfile.deinit(); };

  SceneSnapshot* snapshot = createSceneSnapshot(self);

  reflect::PackParams pack_params = 
  {
    .name = "scene-editor.snapshot"_str,
    .packed = &snapshot->packed,
  };

  packSourceDataFromType(*sfile.returned_data, pack_params);
}

/* ----------------------------------------------------------------------------
 *  Loads a scene from a '.scene' asset named `name`.
 */
static b8 loadSceneFile(SceneEditor& self, String name)
{
  // Load the scene file as source data.
  fs::PathBuffer path;
  io::formatv(&path, name, ".scene"_str);

  SourceDataFile sdf_scene_def;
  if (!SourceDataFile::from(&sdf_scene_def, String(path)))
    return false;
  defer { sdf_scene_def.deinit(); };

  // Reset a bunch of state.
  self.save_failed = false;

  for (SceneSnapshot& snapshot : self.scene_snapshots)
    destroySceneSnapshot(self, &snapshot);
  self.scene_snapshots.clear();

  reinitGameSubSystems(self);

  // Create the initial snapshot.
  SceneSnapshot* snapshot = createSceneSnapshot(self);

  self.current_snapshot = 0;
  self.saved_snapshot = 0;

  // Pack it.
  reflect::PackParams pack_params = 
  {
    .name = String(path),
    .packed = &snapshot->packed,
  };

  if (!reflect::packSourceDataFromType(
        *sdf_scene_def.returned_data, 
        pack_params))
    return false;

  auto* scene_def = snapshot->packed.getDataAs<SceneDef>();

  // Link it.
  self.link("SceneDef"_typeid, scene_def);

  // Load the scene state into the game systems.
  SceneLoadParams load_params = 
  {
    .entmgr = self.entity_mgr,
    .log = &self.game_log,
  };

  if (!loadScene(*scene_def, load_params))
    return self.editor->log.error(
      "failed to load scene from file '", String(path), "'");

  return true;
}

/* ----------------------------------------------------------------------------
 */
static void onChange(SceneEditor& self)
{
  if (self.current_snapshot < self.scene_snapshots.len - 1)
  {
    // If there are snapshots ahead of the current one, clear them.
    // TODO(sushi) it would be nice to experiment with forming a tree of 
    //             states rather than just throwing away future ones. 
    //             Not sure how practical that is, since I've never used
    //             a program that does that and especially with how our 
    //             current undo/redo stuff works atm.
    for (s32 i = self.scene_snapshots.len - 1; i > self.current_snapshot; --i)
    {
      destroySceneSnapshot(self, &self.scene_snapshots[i]);
      self.scene_snapshots.pop();
    }
  }

  captureSceneSnapshot(self);

  self.current_snapshot += 1; 
}

/* ----------------------------------------------------------------------------
 */
static void reloadCurrentSnapshot(SceneEditor& self)
{
  SceneSnapshot* current = &self.scene_snapshots[self.current_snapshot];
  SceneDef* def = current->packed.getDataAs<SceneDef>();

  endSelectedEntityPlacement(self);
  reloadSceneFromDef(self, *def);
  replacePlacementEntity(self);
}

/* ----------------------------------------------------------------------------
 */
static void undo(SceneEditor& self)
{
  if (self.current_snapshot == 0)
    return;

  self.current_snapshot -= 1;
  reloadCurrentSnapshot(self);
}

/* ----------------------------------------------------------------------------
 */
static void redo(SceneEditor& self)
{
  if (self.current_snapshot == self.scene_snapshots.len - 1)
    return;

  self.current_snapshot += 1;
  reloadCurrentSnapshot(self);
}

/* ----------------------------------------------------------------------------
 */
b8 SceneEditor::init()
{
  if (!initGameSubSystems(*this))
    return editor->log.error("failed to initialize game subsystems");

  reflect::Linker linker = 
  {
    .asset_mgr = editor->asset_mgr,
    .resource_mgr = editor->resource_mgr,
  };

  cl::GameRenderer::InitParams game_renderer_params = 
  {
    .vk = *editor->vk,
    .linker = linker,
  };

  if (!game_renderer.init(game_renderer_params))
    return editor->log.error("failed to init game renderer");

  scene_snapshots.init();

  if (!loadScene("assets/scenes/Test"_str))
    return editor->log.error("failed to load scene");

  if (!recreateMapTexture(*editor->vk, &scene_render))
    return editor->log.error("failed to create map texture");

  sd_editor.init();

  entity_assets.list.init();

  editor->event_bus->subscribeTo<WindowFocusChange, SceneEditor>(this,
    [](auto& self, auto& ev) -> void
    {
      if (!ev.has_focus)
        self.control_state = ControlState::None;
    });

  return true;
}

/* ----------------------------------------------------------------------------
 */
template<typename TComp>
static TComp* tryComp(SceneEditor& self, EntityId id)
{
  return self.entity_mgr.tryComp<TComp>(id);
}

/* ----------------------------------------------------------------------------
 */
template<typename TComp>
static Slice<TComp> eachComp(SceneEditor& self)
{
  return self.entity_mgr.eachComp<TComp>();
}

/* ============================================================================
 *  Bundle of state related to the view of the map computed in putUI() and 
 *  fed down into helpers. This is intended to be immutable.
 */
struct MapViewState
{
  // Focus of the map state from UI, eg. is it hovered, focused, was a 
  // mouse button clicked etc.
  ui::Focus focus;

  // Position of the cursor relative to the map view's position on screen 
  // and its position in world space.
  vec2f local_cursor;
  vec2f world_cursor;
};

/* ============================================================================
 *  State that helpers use to indicate if they have changed the map, which 
 *  is used in putUI() to decide if the map needs to be reloaded.
 */
struct MapViewResult
{
  b8 changed_tile;
};

/* ----------------------------------------------------------------------------
 */
static void handleDragState(
    SceneEditor& self,
    ui::UI& ui,
    const MapViewState& state)
{
  using Focus = ui::FocusFlag;

  if (self.dragging_view)
  {
    vec2f offset = self.view.viewportPointToWorld(
      self.drag_start_viewport, 
      self.view_size);

    self.view.pos = self.drag_start_world + offset - state.world_cursor;

    // Check if middle mouse is released anywhere to avoid the drag state 
    // getting stuck.
    if (ui.wasTertiaryReleasedGlobally())
      self.dragging_view = false;
  }
  else
  {
    if (state.focus.wasTertiaryPressed())
    {
      self.drag_start_viewport = state.local_cursor;
      self.drag_start_world = self.view.pos;
      self.dragging_view = true;
    }
  }
}

/* ----------------------------------------------------------------------------
 */
static void handleScrollState(
    SceneEditor& self,
    ui::UI& ui,
    const MapViewState& state)
{
  if (!state.focus.isHovered())
    return;

  f32 scroll = ui.frame_input.getScroll();
  if (scroll != 0.f)
  {
    ui.frame_input.consumeScroll();

    if (ui.frame_input.isKeyDown(Key::LShift))
    {
      self.view.rotation += scroll * degreesToRadians(1.f);
    }
    else
    {
      self.view.zoom -= self.view.zoom / 10.f * scroll;

      self.view.zoom = max(1e-3f, min(1e4f, self.view.zoom)); 

      vec2f new_world_cursor = self.view.viewportPointToWorld(
        state.local_cursor, 
        self.view_size);

      self.view.pos -= new_world_cursor - state.world_cursor;
    }
  }
}

/* ----------------------------------------------------------------------------
 */
static void reloadEntitySourceDataFile(
    SceneEditor& self,
    EntityId id)
{
  SourceDataFile* sfile = &self.sdf_selected_entity_def;
  sfile->deinit();

  if (isnil(self.selected_entity))
    // Must have selected empty space.
    return;

  String defname = self.entity_mgr.getDefName(self.selected_entity);

  if (isnil(defname))
    // TODO(sushi) handle this. 
    return;

  fs::PathBuffer def_path;
  io::formatv(&def_path, defname, ".entity"_str);

  if (!SourceDataFile::from(sfile, String(def_path)))
  {
    self.editor->log.error(
      "failed to load def source data for entity ", id, " from '",
      String(def_path), "'");
    return;
  }

  self.editor->log.info("selected entity ", id);

  self.sd_editor.setSourceData(
    sfile->returned_data,
    sfile,
    "EntityDef"_typeid);

  self.link(
    "EntityDefLink"_typeid, 
    defname, 
    &self.selected_entity_def); 
}

/* ----------------------------------------------------------------------------
 */
static void handleEntitySelection(
    SceneEditor& self,
    ui::UI& ui,
    const MapViewState& state)
{
  EyeSys& eye = self.getSys<EyeSys>();

  self.hovered_entity = nil;
  
  vec2f world_cursor = state.world_cursor;
  vec2f hovered_pos_entity_local = {};

  for (auto& sprite : self.entity_mgr.eachComp<cl::Sprite>())
  {
    vec2f world_pos = self.entity_mgr.computeWorldPos(sprite.owner);

    vec2f world_size = computeSpriteTextureWorldSize(
      sprite, 
      self.view,
      self.view_size);

    if (Rect::from(world_pos, world_size).containsPoint(world_cursor))
    {
      if (pixelTestSprite(sprite, world_cursor - world_pos))
      {
        self.hovered_entity = sprite.owner;
        hovered_pos_entity_local = world_cursor - world_pos;
        break;
      }
    }
  }

  if (ui.frame_input.wasMouseButtonPressed(MouseButton::Left))
  {
    b8 new_selection = self.hovered_entity != self.selected_entity;

    self.selected_entity = self.hovered_entity;

    if (new_selection)
    {
      reloadEntitySourceDataFile(self, self.selected_entity);
      self.entity_select_pos_viewport = state.local_cursor;
      self.entity_select_pos_entity_local = hovered_pos_entity_local;
    }
  }
  else if (ui.frame_input.isMouseButtonDown(MouseButton::Left) &&
           notnil(self.selected_entity))
  {
    vec2f delta = state.local_cursor - self.entity_select_pos_viewport;
    if (delta.mag() > 3.f)
      self.dragging_entity = true;
  }
}

/* ----------------------------------------------------------------------------
 */
static void handleEntityPlacement(
    SceneEditor& self,
    ui::UI& ui,
    EntityId id,
    vec2f pos,
    vec2f offset,
    PlacementMode placement_mode,
    const MapViewState& state)
{
  auto& placement_sys = self.getSys<PlacementSys>();
  placement_sys.placeEntity(id, placement_mode, pos, offset);
}

/* ----------------------------------------------------------------------------
 */
static void handleEntitySpawning(
    SceneEditor& self,
    ui::UI& ui,
    const MapViewState& state)
{
  if (!self.hasLoadableSelectedEntity())
    return;

  if (!state.focus.isHovered())
    return;

  handleEntityPlacement(
    self,
    ui,
    self.placement_entity,
    state.world_cursor,
    vec2f(0.f),
    self.selected_entity_asset->l_def->placement,
    state);

  if (state.focus.wasPrimaryPressed())
  {
    beginSelectedEntityPlacement(self);
    onChange(self);
  }
}

/* ----------------------------------------------------------------------------
 */
static void handleEntityDrag(
    SceneEditor& self,
    ui::UI& ui,
    const MapViewState& state)
{
  if (!state.focus.isHovered())
    return;

  if (isnil(self.selected_entity))
    return;

  handleEntityPlacement(
    self,
    ui,
    self.selected_entity,
    state.world_cursor,
    -self.entity_select_pos_entity_local,
    self.selected_entity_def->placement,
    state);

  if (ui.wasPrimaryReleasedGlobally())
  {
    self.selected_entity = nil;
    self.dragging_entity = false;
    onChange(self);
  }
}

/* ----------------------------------------------------------------------------
 */
static void handleMapAndEntityCursorInteraction(
    SceneEditor& self,
    ui::UI& ui,
    const MapViewState& state,
    MapViewResult& result)
{
  auto& map = self.getSys<MapSys>();

  if (!state.focus.isHovered())
    return;

  switch (self.selected_tool)
  {
  case Tool::Add:
    handleEntitySpawning(self, ui, state);
    break;
  case Tool::Move:
    handleEntityDrag(self, ui, state);
    break;
  default:
    handleEntitySelection(self, ui, state);
  }
}

/* ----------------------------------------------------------------------------
 */
static void handleControlInputs(
    SceneEditor& self, 
    ui::UI& ui, 
    const MapViewState& state,
    MapViewResult& result,
    const EditorSkinDef& skin)
{
  handleDragState(self, ui, state);
  handleScrollState(self, ui, state);
  handleMapAndEntityCursorInteraction(self, ui, state, result);
}

/* ----------------------------------------------------------------------------
 */
static void putToolSelectIcons(
    SceneEditor& self,
    ui::UI& ui,
    Rect bounds,
    const EditorSkinDef& skin)
{
  static const f32 icon_size = 16.f;
  static const f32 icon_spacing = 4.f;
  static const f32 icon_stride = icon_size + icon_spacing;

  auto icon_bounds = Rect::zero()
    .setPos(bounds.pos())
    .setSqSize(icon_size)
    .alignCenteredYInside(bounds)
    .alignLeftInside(bounds, 4.f);

$ local function placeIcon(tool, skin)
  {
    b8 enabled = self.selected_tool == Tool::$(tool);
    if (ui.putCheckbox("scene-editor.select-tool-$(tool)"_fid,
          icon_bounds,
          &enabled,
          skin.scene_editor.$(skin)))
    {
      if (enabled)
        self.selected_tool = Tool::$(tool);
    }

    icon_bounds.x += icon_stride;
  }
$ end
  
  @placeIcon(Add,    tool_add)
  @placeIcon(Move,   tool_move)
  @placeIcon(Pick,   tool_pick)
  @placeIcon(Delete, tool_delete)
}

/* ----------------------------------------------------------------------------
 */
static void putMapView(
    SceneEditor& self, 
    ui::UI& ui, 
    Rect bounds,
    const MapViewState& state,
    MapViewResult& result,
    const EditorSkinDef& skin)
{
  // Since we render the map into a texture much larger than the size
  // we actually render it at, we have to compute the proper uv's to 
  // use for the texture.
  auto uv = vec4f(0,0,0,0);
  uv.z = bounds.w / c_map_render_w;
  uv.w = bounds.h / c_map_render_h;

  ui.putQuad(bounds, self.scene_render.getHandle(), uv, 0xffffffff);

  Rect tool_select_bounds = Rect::zero()
    .setPos(bounds.pos())
    .setHeight(26.f)
    .setWidth(bounds.w)
    .contractedX(10.f)
    .alignTopInside(bounds, 4.f);

  putToolSelectIcons(self, ui, tool_select_bounds, skin);

  handleControlInputs(self, ui, state, result, skin);
}

/* ----------------------------------------------------------------------------
 */
static void handleEntityBuildResult(
    SceneEditor& self, 
    String name,
    String type,
    Editor::BuildRequestResult result)
{
  for (EntityAsset& asset : self.entity_assets.list)
  {
    if (name != String(asset.l_def.name))
      continue;

    b8 success = result == Editor::BuildRequestResult::Success;

    if (success)
    {
      asset.build_state = EntityBuildState::None;

      self.link("EntityDefLink"_typeid, &asset.l_def);
    }
    else
      asset.build_state = EntityBuildState::Failed;

    break;
  }
}

/* ----------------------------------------------------------------------------
 */
static void requestEntityAssetBuild(SceneEditor& self, EntityAsset& asset)
{
  b8 request_success = self.editor->requestBuild<SceneEditor>(
    asset.l_def.name,
    "entity.data"_str,
    &self,
    handleEntityBuildResult);
  
  if (request_success)
    asset.build_state = EntityBuildState::Requested;
  else
    asset.build_state = EntityBuildState::RequestFailed;
}

/* ----------------------------------------------------------------------------
 */
static void putBuildIcon(
    SceneEditor& self,
    ui::UI& ui,
    Rect bounds,
    EntityAsset& asset,
    const EditorSkinDef& skin)
{
  ui.pushId(ui.generateIdFromPointer(&asset));
  defer { ui.popId(); };

  ui::Focus icon_focus = ui.putFocusableBounds(
    "scene-editor.build-result-icon"_fid,
    bounds);

  if (asset.build_state != EntityBuildState::Requested &&
      icon_focus.isHovered())
  {
    ui.putItem(bounds, skin.icons.redo);   

    if (icon_focus.wasPrimaryPressed())
      requestEntityAssetBuild(self, asset);
  }
  else
  {
    switch (asset.build_state)
    {
    case EntityBuildState::None:
      ui.putItem(bounds, skin.icons.checkmark);
      break;
    case EntityBuildState::Requested:
      placeLoadingDots(
        ui, 
        bounds, 
        time::since(self.editor->start_time).toSeconds(),
        skin);
      break;
    case EntityBuildState::Failed:
      ui.putItem(bounds, skin.icons.error_triangle);
      break;
    }
  }

  // TODO(sushi) support ui Items passing through inputs, this blocks clicking
  //             the button.
  //
  // String tooltip_text = nil;
  // switch (self.entity_build_state)
  // {
  // case EntityBuildState::None:
  //   tooltip_text = "click to rebuild the selected entity asset"_str;
  //   break;
  // case EntityBuildState::Requested:
  //   tooltip_text = "entity asset is currently building"_str;
  //   break;
  // case EntityBuildState::Failed:
  //   tooltip_text = "entity asset failed to build; click to try again"_str;
  //   break;
  // }
  //
  // ui.putTooltip("scene-editor.entity-build"_fid,
  //   bounds,
  //   tooltip_text,
  //   skin.tooltip);
}

/* ----------------------------------------------------------------------------
 */
static void cacheEntityAssetList(SceneEditor& self)
{
  self.entity_assets.last_cache = TimePoint::monotonic();

  auto glob = fs::Globber::create("assets/**/*.entity"_str);

  glob.run([&](String path)
  {
    EntityAsset* asset = self.entity_assets.list.push();
    asset->l_def.name = path.removeSuffix(".entity"_str).allocateCopy();
    requestEntityAssetBuild(self, *asset);
    return true;
  });

  glob.destroy();
}

/* ----------------------------------------------------------------------------
 */
static void putEntityDefSelection(
    SceneEditor& self,
    ui::UI& ui,
    Rect bounds,
    const EditorSkinDef& skin)
{
  static const f32 icon_size = 16.f;
  static const f32 icon_dropdown_spacing = 2.f;

  static const f32 row_size = 20.f;
  static const f32 row_spacing = 2.f;
  static const f32 row_stride = row_size + row_spacing;

  static const f32 preview_size = row_size;
  static const u64 preview_state_time_ms = 1000;

  SpriteTextureDraw null_sprite_draw = 
  {
    .texture = self.editor->l_null_texture.getHandle(),
    .uv = vec4f(0.f, 0.f, 1.f, 1.f),
    .color = 0xff0000ff,
  };

  f32 preview_time = time::since(self.editor->start_time).toSeconds();

  ui.beginScrollGroup("scene-editor.entity-asset-scroll"_fid,
    bounds,
    skin.scroll_bar);
  {
    auto row_bounds = Rect::zero()
      .setSize(ui.getWidth(), row_size);

    for (EntityAsset& asset : self.entity_assets.list)
    {
      auto preview_bounds = Rect::zero()
        .setSqSize(preview_size)
        .alignLeftInside(row_bounds, 2.f)
        .alignCenteredYInside(row_bounds);

      auto icon_bounds = Rect::zero()
        .setSqSize(icon_size)
        .alignRightInside(row_bounds, 2.f)
        .alignCenteredYInside(row_bounds);

      auto name_bounds = Rect::from(row_bounds)
        .contractedLeft(preview_bounds.extentX() + 4.f)
        .contractedRight(icon_bounds.w + 4.f);

      SpriteTextureDraw sprite_draw = null_sprite_draw;
      
      if (asset.build_state == EntityBuildState::None)
      {
        for (const ComponentPtr& cptr : asset.l_def->components)
        {
          if (cptr.type != "cl::Sprite"_typeid)
            continue;

          const auto* sprite = cptr.getAs<cl::Sprite>();

          if (!sprite->states.isValid())
            continue;

          u64 num_states = sprite->states->map.len;
          u64 time_ms = preview_time * u64(time::ms_p_s);
          u64 state = (time_ms / preview_state_time_ms) % num_states;

          sprite_draw = computeSpriteTextureDrawForState(
            *sprite,
            state,
            null_sprite_draw);
        }
      }

      ui.putQuad(
        preview_bounds, 
        sprite_draw.texture,
        sprite_draw.uv,
        sprite_draw.color);

      ui::Focus name_focus = ui.putFocusableBounds(
        ui.generateIdFromString(asset.l_def.name),
        name_bounds);

      if (name_focus.wasPrimaryPressed())
        self.selected_entity_asset = &asset;

      b8 is_selected = &asset == self.selected_entity_asset;

      const ui::TextItemSkin* name_skin = nullptr;

      if (is_selected)
      {
        name_skin = &skin.scene_editor.selected_entity_asset;
      }
      else
      {
        if (name_focus.isHovered())
          name_skin = &skin.scene_editor.hovered_entity_asset;
        else
          name_skin = &skin.scene_editor.entity_asset;
      }

      ui.putTextItem(name_bounds, asset.l_def.name, *name_skin);

      putBuildIcon(self, ui, icon_bounds, asset, skin);

      row_bounds.y += row_stride;
    }
  }
  ui.endScrollGroup(skin.scroll_bar);
}

/* ----------------------------------------------------------------------------
 */
static void putToolMenu(
    SceneEditor& self,
    ui::UI& ui,
    const MapViewState& state,
    MapViewResult& result,
    const EditorSkinDef& skin)
{
  const f32 sde_height = 300.f;

  io::StaticBuffer<128> buffer;
  io::formatv(&buffer, floor(state.world_cursor), '\n');

  io::formatv(&buffer, "selected: "_str, self.selected_entity, '\n');
  io::formatv(&buffer, "hovered: "_str, self.hovered_entity, '\n');

  auto text_bounds = Rect::from(0, 0, ui.getWidth(), ui.getHeight());

  vec2f text_size = ui.putText(text_bounds, String(buffer), skin.text);

  f32 y = text_size.y + 4.f;

  Rect entity_asset_list_bounds = {};
  entity_asset_list_bounds.x = 2.f;
  entity_asset_list_bounds.y = y;
  entity_asset_list_bounds.w = 
    ui.getWidth() - 2.f * entity_asset_list_bounds.x;
  entity_asset_list_bounds.h = 200.f;

  putEntityDefSelection(
    self,
    ui, 
    entity_asset_list_bounds,
    skin);

  y = entity_asset_list_bounds.extentY() + 4.f;

  // Rect sde_bounds;
  // sde_bounds.x = 2.f;
  // sde_bounds.y = y;
  // sde_bounds.w = ui.getWidth() - 2.f * sde_bounds.x;
  // sde_bounds.h = sde_height;
  //
  // self.sd_editor.put(ui, sde_bounds, skin.sdata_edit);
  //
  // y += sde_height + 4.f;
  //
  // Rect select_bounds;
  // select_bounds.x = 2.f;
  // select_bounds.y = y;
  // select_bounds.w = ui.getWidth() - 2.f * select_bounds.x;
  // select_bounds.h = 14.f;
}

/* ----------------------------------------------------------------------------
 */
void SceneEditor::putUI(ui::UI& ui, const EditorSkinDef& skin)
{
  if (ui.frame_input.wasKeyPressed(Key::Z) &&
      ui.frame_input.isKeyDown(Key::LCtrl))
  {
    if (ui.frame_input.isKeyDown(Key::LShift))
      redo(*this);
    else
      undo(*this);
  }

  if (time::since(entity_assets.last_cache) > TimeSpan::fromMinutes(9999.f))
  {
    entity_assets.list.clear();
    cacheEntityAssetList(*this);
  }

  const f32 tool_menu_width = 400.f;

  Rect map_view_bounds = {};
  map_view_bounds.x = tool_menu_width;
  map_view_bounds.y = 0.f;
  map_view_bounds.w = ui.getWidth() - map_view_bounds.x;
  map_view_bounds.h = ui.getHeight();

  // Save the view size for the next time we go to render.
  view_size = map_view_bounds.size();

  Rect tool_menu_bounds = {};
  tool_menu_bounds.x = 0.f;
  tool_menu_bounds.y = 0.f;
  tool_menu_bounds.w = tool_menu_width;
  tool_menu_bounds.h = ui.getHeight();

  MapViewState view_state;
  view_state.local_cursor = ui.getLocalCursorPos() - map_view_bounds.pos();
  view_state.world_cursor = view.viewportPointToWorld(
    view_state.local_cursor,
    view_size);
  view_state.focus = ui.putFocusableBounds("game-view"_fid, map_view_bounds);

  MapViewResult view_result;

  putMapView(
    *this,
    ui,
    map_view_bounds,
    view_state,
    view_result,
    skin);

  ui.beginPanel("map-editor.tool-menu"_fid, tool_menu_bounds);
  {
    putToolMenu(
      *this,
      ui,
      view_state,
      view_result,
      skin);
  }
  ui.endPanel();

  if (ui.frame_input.wasKeyPressed(Key::S) &&
      ui.frame_input.isKeyDown(Key::LCtrl))
    saveScene(*this);
}

/* ----------------------------------------------------------------------------
 */
void SceneEditor::putHeaderUI(ui::UI& ui, const EditorSkinDef& skin)
{
  Rect text_bounds = ui.getBounds();

  if (saved_snapshot != current_snapshot)
  {
    auto warning_bounds = Rect::zero().setSqSize(16.f);

    ui.putItem(warning_bounds, skin.icons.warning_triangle);

    ui.putTooltip("scene-editor.dirty-tooltip"_fid,
      warning_bounds,
      "scene has unsaved changes"_str,
      skin.tooltip);

    text_bounds = text_bounds.contractedLeft(warning_bounds.w + 4.f);
  }

  if (save_failed)
  {
    auto error_bounds = Rect::zero()
      .addPos(text_bounds.pos())
      .setSqSize(16.f);

    ui.putItem(error_bounds, skin.icons.error_triangle);

    ui.putTooltip("scene-editor.save-fail-tooltip"_fid,
      error_bounds,
      "saving the scene failed; do you need to checkout the file?"_str,
      skin.tooltip);

    text_bounds = text_bounds.contractedLeft(error_bounds.w + 4.f);
  }

  ui.putText(text_bounds, String(loaded_scene_name), skin.doc.header.text);
}

/* ----------------------------------------------------------------------------
 */
b8 SceneEditor::loadScene(String name)
{
  loaded_scene_name.clear();
  io::format(&loaded_scene_name, name);

  return loadSceneFile(*this, name);
}

/* ----------------------------------------------------------------------------
 *  Computes the size of a pixel on screen in the world. Used to properly
 *  size things drawn in the map view so that they appear consistently sized on 
 *  screen.
 */
static vec2f getWorldPixelSize(SceneEditor& self)
{
  return self.viewportToWorld(vec2f(1.f, 1.f)) - 
         self.viewportToWorld(vec2f(0.f, 0.f));
}

/* ----------------------------------------------------------------------------
 */
static void placeGrid(SceneEditor& self, gfx::BatchRenderer& br)
{
  // Get where the top-left and top-right of the viewport correspond to 
  // in the world.
  vec2f world_view_origin = self.viewportToWorld(vec2f(0.f, 0.f));
  vec2f world_view_extent = self.viewportToWorld(self.view_size);

  // Used to determine thickness of lines as drawn in the world so that 
  // they appear with a consistent thickness on screen.
  vec2f world_pixel_size = 
    self.viewportToWorld(vec2f(1.f, 1.f)) - world_view_origin;

  vec2f world_view_size = world_view_extent - world_view_origin;

  f32 grid_sep = max(1.f, math::round(self.view.zoom * 2.f));

  vec2f grid_start;
  grid_start.x = roundDownTo(world_view_origin.x, grid_sep);
  grid_start.y = roundDownTo(world_view_origin.y, grid_sep);

  vec2f grid_end;
  grid_end.x = roundUpTo(world_view_extent.x, grid_sep);
  grid_end.y = roundDownTo(world_view_extent.y, grid_sep);

  for (f32 x = grid_start.x; x <= grid_end.x; x += grid_sep)
  {
    br.drawLine(
      vec2f(x, world_view_origin.y),
      vec2f(x, world_view_extent.y),
      2.f * world_pixel_size.x, 
      0x77777788);
  }

  for (f32 y = grid_start.y; y >= grid_end.y; y -= grid_sep)
  {
    br.drawLine(
      vec2f(world_view_origin.x, y),
      vec2f(world_view_extent.x, y),
      2.f * world_pixel_size.x, 
      0x77777788);
  }
}

/* ----------------------------------------------------------------------------
 */
static void outlineEntityCollider(
    SceneEditor& self,
    gfx::BatchRenderer& br,
    EntityId id, 
    Color color)
{
  if (isnil(id))
    return;

  auto* transform = tryComp<Transform>(self, id);
  auto* sprite    = tryComp<cl::Sprite>(self, id);

  vec2f pos = self.entity_mgr.computeWorldPos(*transform);
  vec2f size = computeSpriteTextureWorldSize(
    *sprite, self.view, self.view_size);
  
  auto bounds = Rect::from(pos, size);

  f32 thickness = getWorldPixelSize(self).x;

  br.drawBorder(bounds, thickness, color);
}

/* ----------------------------------------------------------------------------
 */
void SceneEditor::render(gfx::Vulkan& vk)
{
  if (view_size.x <= 0.f || view_size.y <= 0.f)
    return;

  gfx::RenderTarget target = 
  {
    .image = scene_render.image,
    .view = scene_render.view,
  };

  gfx::RenderPass pass;
  if (!gfx::vk::beginRenderPass(
        &vk,
        &pass,
        target,
        vec2i(0,0),
        vec2u(view_size),
        0x000000ff))
    return;

  game_renderer.updateSceneBuffer(vk, view_size, view.getViewMat());

  gfx::VertexBufferView vbv;
  gfx::IndexBufferView ibv;
  game_renderer.mapBuffersAndGetViews(vk, &vbv, &ibv);

  gfx::BatchRenderer br;
  br.init(&pass, vbv, ibv);

  br.begin();

  br.setPipeline(game_renderer.quad_pipeline_link.getHandle());

  pass.bindVertexBuffer(game_renderer.quad_buffers.vertex);
  pass.bindIndexBuffer(game_renderer.quad_buffers.index);
  pass.bindUniformBuffer(game_renderer.scene_uniform_buffer);

  pass.setViewport({0,0}, view_size);
  pass.setScissor({0,0}, vec2u(view_size));
  
  game_renderer.renderMapLayers(vk, br, entity_mgr);
  
  br.setTexture(editor->l_white_texture.getHandle());
  placeGrid(*this, br);

  game_renderer.renderSprites(vk, br, entity_mgr);

  br.setTexture(editor->l_white_texture.getHandle());
  outlineEntityCollider(*this, br, selected_entity, 0x00ff00ff);
  outlineEntityCollider(*this, br, hovered_entity, 0x0000ffff);

  br.end();

  game_renderer.unmapBuffers(vk);

  gfx::vk::endRenderPass(&vk);

  gfx::vk::prepareImageForSampling(&vk, scene_render.image);
}

}
