/*
 *  Functions for creating a Client, which contains the client-side systems
 *  and memory needed when the game is running as a client.
 *
 *  It's probably more appropriate for this to be an engine level interface
 *  as well, that simply hooks into the game (as I would like this project
 *  to try and keep the Engine agnostic of the Game running in it for
 *  possible reuse in future projects), but for now I'm going to keep it
 *  under game/ to simplify implementing it, as it avoids needing to design
 *  the Client and Server to be modular in what they run.
 */

$ require "common"

@lpp.import "game/client/GameMgr.lh"
@lpp.import "game/client/NetMgr.lh"
@lpp.import "game/shared/entity/EntityMgr.lh"
@lpp.import "game/shared/GameLog.lh"

@lpp.import "reflect/Linker.lh"

#include "iro/time/Time.h"

struct AssetLoader;

/* ============================================================================
 */
struct Client
{
  cl::NetMgr netmgr;
  cl::GameMgr gamemgr;

  GameLog game_log;

  struct InitParams
  {
    gfx::Vulkan& vk;
    reflect::Linker& linker;
  };

  b8 init(const InitParams& params);
  void deinit(gfx::Vulkan& vk);

  struct UpdateParams
  {
    InputState& input;
    vec2u viewport_size;
  };

  struct UpdateResult
  {
  };

  UpdateResult update(const UpdateParams& params);

  struct RenderParams
  {
    gfx::Vulkan& vk;
    gfx::RenderTarget& target;
  };    

  struct RenderResult
  {
    b8 game_rendered;
  };

  RenderResult render(const RenderParams& params);

  b8 connectToServer(net::Address address);

  void disconnectFromServer();

  void notifyAssetChanged(String name, String type, reflect::Linker& linker)
  {
    gamemgr.notifyAssetChanged(name, type, linker);
  }
};
