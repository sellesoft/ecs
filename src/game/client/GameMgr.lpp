$ local cmn = require "common"

@lpp.import "game/client/GameMgr.lh"

@lpp.import "Engine.lh"

@lpp.import "reflect/Packing.lh"
@lpp.import "reflect/CompiledData.lh"
@lpp.import "sdata/SourceDataFile.lh"
@lpp.import "sdata/SourceDataParser.lh"

@lpp.import "game/client/graphics/Sprite.comp.lh"

@lpp.import "game/shared/Eye.sys.lh"
@lpp.import "game/client/input/Input.sys.lh"
@lpp.import "game/shared/Movement.comp.lh"
@lpp.import "game/shared/Transform.comp.lh"

@lpp.import "game/shared/map/Map.sys.lh"
@lpp.import "game/shared/map/Map.defs.lh"

@lpp.import "window/Window.events.lh"
@lpp.import "game/shared/SceneLoader.lh"

@log.import

using namespace iro;

namespace cl
{

/* ----------------------------------------------------------------------------
 *  Temporary helper for getting a ghost into the world. Once networking is 
 *  setup this should be handled more formally.
 */
static void spawnPlayerGhost(GameMgr& self, reflect::Linker& linker)
{
  EntityId spawn_parent = nil;
  for (auto& layer : self.entmgr.eachComp<MapLayer>())
  {
    spawn_parent = layer.owner;
    break;
  }

  EntityDefLink ghost_def;
  linker.link(
    "EntityDefLink"_typeid,
    "assets/entities/ghost/Ghost"_str,
    &ghost_def);

  EntityId ghost = self.entmgr.spawnEntity(
    ghost_def,
    spawn_parent);

  println("spawned ghost ", ghost);

  auto& eye = self.getSys<EyeSys>();
  auto& input = self.getSys<InputSys>();

  eye.attach(ghost);
  input.attach(ghost);
}

/* ----------------------------------------------------------------------------
 */
b8 GameMgr::init(const InitParams& params)
{
  log = &params.log;

  if (!entmgr.init())
    return log->error("failed to initialize entmgr");

  EntitySysMgr::InitParams ent_sys_mgr_params = 
  { 
    {
      .entmgr = entmgr,
      .log = params.log,
    }
  };

  if (!entsysmgr.init(ent_sys_mgr_params))
    return log->error("failed to initialize entsysmgr");

  GameRenderer::InitParams render_params = 
  {
    .vk = params.vk,
    .linker = params.linker,
  };
  if (!game_renderer.init(render_params))
    return log->error("failed to initialize GameRenderer");

  params.linker.link(
    "SceneDefLink"_typeid, 
    "assets/scenes/Test"_str,
    &loaded_scene);

  SceneLoadParams scene_load_params = 
  {
    .entmgr = entmgr,
    .log = &params.log,
  };

  if (!loadScene(*loaded_scene, scene_load_params))
    return log->error("failed to load Test scene");

  spawnPlayerGhost(*this, params.linker);

  return true;
}

/* ----------------------------------------------------------------------------
 */
void GameMgr::deinit(gfx::Vulkan& vk)
{
  entmgr.deinit();
  entsysmgr.deinit();
  game_renderer.deinit(vk);
}

/* ----------------------------------------------------------------------------
 */
b8 GameMgr::update(UpdateParams& params)
{
  // Initialize systems for tick. Ideally this wouldn't be done directly 
  // like this. As more things get added, this should probably be moved to
  // an Event. Just how we parameterize that event (or events) isnt very clear.
  entsysmgr.get<cl::InputSys>().frame_input = params.input;
  entsysmgr.get<EyeSys>().viewport_size = params.viewport_size;

  if (!entsysmgr.update())
    return log->error("failed to update entity systems\n");

  return true;
}

/* ----------------------------------------------------------------------------
 */
GameMgr::RenderResult GameMgr::render(const RenderParams& params)
{
  RenderResult result = {};

  EyeSys& eye = entsysmgr.get<EyeSys>();
  // MapSys& map = entsysmgr.get<MapSys>();
  //
  GameRenderer::RenderParams render_params =
  {
    .entmgr = &entmgr,
    .target = params.target,
    .viewport_size = eye.viewport_size,
    .vk = params.vk,
    .view = eye.view.getViewMat(),
  };

  result.game_rendered = game_renderer.render(render_params);

  return result;
}

}
