$ local cmn = require "common"
$ local ast = require "reflect.ast"
$ local List = require "iro.List"
$ local glob = require "iro.fs.glob"
$ local dumpValue = require "iro.util".dumpValue

@lpp.import "game/client/entity/EntitySysMgr.lh"

#include "iro/time/Time.h"

@log.import

$$$

local astctx, imported = require "reflect.AstContext".fromGlobs
{
  "src/game/client/**/*.sys.lh",
  "src/game/shared/**/*.sys.lh"
}

-- io.write(ast.dump(astctx.translation_unit), '\n')

-- Shorthand helper for looking up a declaration by name.
local function lookup(name)
  return astctx:lookupTypeDecl(name)
end

$$$
$(imported)

namespace cl
{

$ -- * ------------------------------------------------------------------------

$ local TEntitySys = astctx:lookupTypeDecl "EntitySys"
$ assert(TEntitySys)
$ local function isSys(decl)
$   if decl:is(ast.Record) and decl:isDerivedFrom(TEntitySys) then
$     return true
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ local systems_by_canonical_name = {}
$ local systems = cmn.List{}
$ for decl in astctx.type_decls:each() do
$   if isSys(decl) then
$     -- Only take systems that aren't derived from to avoid creating 
$     -- the shared version of a system that is derived from on client side.
$     if decl.derived:isEmpty() then
$       local system = 
$       {
$         name = decl:formCSafeName():get():match("([%w_]-)Sys"):lower(),
$         typename = decl.type.name,
$         decl = decl
$       }
$       systems_by_canonical_name[decl.type.name] = system
$       if decl.base then
$         systems_by_canonical_name[decl.base.name] = system
$       end
$       systems:push(system)
$     end
$   end
$ end

/* ============================================================================
 */
struct EntitySystems
{
$ systems:each(function(sys)
  $(sys.typename) $(sys.name);
$ end)
};

/* ----------------------------------------------------------------------------
 */
b8 EntitySysMgr::init(const InitParams& params)
{
  if (!SharedEntitySysMgr::init(params))
    return false;

  log->info("initializing entity systems...");
  auto init_start = TimePoint::now();

  // Bulk allocate all entity systems.
  systems = mem::stl_allocator.allocateType<EntitySystems>();
  mem::zero(systems, sizeof(EntitySystems));

  log->info(
    "allocated ", io::ByteUnits(sizeof(EntitySystems)),
    " for client entity systems");

  auto on_fail_deallocate_systems = deferWithCancel
  {
    mem::stl_allocator.free(systems);
  };
  
$ systems:each(function(sys)
$   if not sys.decl:findMethod "init" then
$     error("system "..sys.typename.." is missing an 'init' function")
$   end
$   local sysvar = "systems->"..sys.name
  new (&$(sysvar)) $(sys.typename);
  $(sysvar).entmgr = &params.entmgr;
$ local function initStruct(decl)
  $(sysvar).log = log;
$   if decl.base then
$     initStruct(decl.base)
$   end
$   for field in decl:eachField() do
$     local is_ptr = field.type:is(ast.Pointer)
$     local is_ref = field.type:is(ast.Reference)
$     if is_ref then
$       error("entity systems cannot contain references! ("..sys.typename..
$             "::"..field.name..")")
$     end
$     if is_ptr then
$       local decl = field.type.subtype:desugar().decl
$       if decl and isSys(decl) then
$         local refsys = "systems->"..systems_by_canonical_name[decl.name].name
  $(sysvar).$(field.name) = &$(refsys);
$       end
$     end
$   end
$ end
$ initStruct(sys.decl)
$ end)

  TimePoint sys_init_start;

$ systems:each(function(sys)
  sys_init_start = TimePoint::now();
  if (!systems->$(sys.name).init())
    return false;
  log->info("initialized ", "$(sys.typename)"_str, " in ",
       WithUnits(TimePoint::now() - sys_init_start));
$ end)

  log->info("initialized all client entity systems in ",
       WithUnits(TimePoint::now() - init_start), "!");

  on_fail_deallocate_systems.cancel();
  return true;
}

/* ----------------------------------------------------------------------------
 */
void EntitySysMgr::deinit()
{
$ systems:each(function(sys)
$   if sys.decl:findMethod "deinit" then
  systems->$(sys.name).deinit();
$   end
$ end)

  SharedEntitySysMgr::deinit();
}

/* ----------------------------------------------------------------------------
 */
b8 EntitySysMgr::update()
{
$ systems:each(function(sys)
$   if sys.decl:findMethod "update" then
  {
    systems->$(sys.name).update();
  }
$   end
$ end)
  return true;
}

$ systems:each(function(sys)
/* ----------------------------------------------------------------------------
 */
template<>
$(sys.typename)& EntitySysMgr::get<$(sys.typename)>()
{
  return systems->$(sys.name);
}

$ end)

}
