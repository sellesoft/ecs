/*
 *  System for rendering Sprite components (and maybe some other stuff).
 *
 *  Note that this is not an EntitySys, as it doesn't (shouldn't) deal with
 *  events or updating components, it's job is to simply communicate with 
 *  gfx::Renderer to render the game.
 *
 *  TODO(sushi) better name for this, as its not an entity system and so
 *              it adhering to the entity system naming convention could
 *              be confusing.
 */

$ require "common"

#include "iro/Common.h"
#include "math/Rect.h"
#include "math/mat.h"
#include "Color.h"

@lpp.import "graphics/TextureHandle.lh"
@lpp.import "graphics/Texture.resource.lh"
@lpp.import "graphics/Buffer.lh"
@lpp.import "graphics/Pipeline.lh"
@lpp.import "graphics/Pipeline.resource.lh"
@lpp.import "graphics/RenderTarget.lh"
@lpp.import "graphics/Texture.defs.lh"
@lpp.import "graphics/vi_types.lh"
@lpp.import "reflect/Linker.lh"

namespace gfx 
{ 
struct Vulkan; 
struct RenderPass;
}

struct AssetMgr;
struct EntityMgr;
struct MapState; 

namespace cl
{

struct GameRenderer;

/* ============================================================================
 *  An interface that may be implemented and provided to GameRenderer to inject
 *  stuff into the render at various points. 
 *
 *  I REALLY don't care for doing this this sort of way, but there's not 
 *  really a better option atm. What I feel would be nice now is to just make 
 *  each 'render pass' (not in the gfx sense) of the renderer separated and 
 *  moving the api towards explicitly telling the renderer to draw those 
 *  passes. Or something. Idk, I just don't like this, but I want a way to 
 *  render stuff *in* the game from the map editor. Worked fine this way last 
 *  time so whatever.
 */
struct IExternalRender
{
  // Counts of vertexes/indexes drawn this frame by the external render.
  // This is not maintained internally and is just provided for convenience,
  // the implementer is expected to count their draws.
  //
  // TODO(sushi) should really implement that batch renderer.
  vec2i draw_counts;

  // Pointers to the mapped vertex/index buffers.
  gfx::Vertex* vp;
  gfx::Index* ip;

  // The current render pass.
  gfx::RenderPass* pass;

  // Called before rendering the map.
  virtual void preMap() {}

  // Called before drawing any sprites, after the map has been drawn.
  virtual void preSprites() {}

  // The last call made before GameRenderer ends its render pass. Anything
  // drawn here will draw overtop of everything.
  virtual void overlay() {}
};

/* ============================================================================
 */
struct VIBuffers
{
  gfx::Buffer vertex;
  gfx::Buffer index;
};

/* ============================================================================
 */
struct GameRenderer
{
  enum 
  {
    c_MaxQuads = 8192,
    c_MaxBatches = 256,
    c_MaxExternal = 1024,
  };

  struct QuadBatch
  {
    u32 quad_count = 0;
    gfx::TextureHandle texture;
  };

  //NOTE: every field is padded to 16 bytes due to std140
  struct Scene
  {
    f32 proj[16];
    f32 view[16];
    f32 resolution_and_time[4];
  };

  struct InitParams
  {
    gfx::Vulkan& vk;
    reflect::Linker& linker;
  };

  b8 init(InitParams& params);
  void deinit(gfx::Vulkan& vk);

  struct RenderParams
  {
    EntityMgr* entmgr;
    MapState* map;

    vec2u viewport_size;
    mat3x2 view;

    // TODO(sushi) see if it would be better to just start a RenderPass outside
    //             of this call and have it passed in here to simplify what 
    //             this does internally.
    //             Maybe not, because we do buffer stuff during a render, 
    //             which needs Vulkan directly. Hm. I guess RenderPass has 
    //             a pointer to Vulkan, but using that feels weird.
    //             The Buffer stuff sucks majorly though and needs to be 
    //             redone anyways, so we'll deal with this until then.
    gfx::Vulkan& vk;
    gfx::RenderTarget& target;

    // Optional interface called by the renderer at various points to 
    // allow external things to draw stuff in the game world. 
    // Would like to get rid of this eventually, see comment on 
    // IExternalRender.
    IExternalRender* external;
  };

  b8 render(const RenderParams& params);

  void drawQuad(
    gfx::Vulkan& vk,
    gfx::RenderPass& pass,
    vec2f pos,
    gfx::TextureHandle texture,
    vec4f uv,
    Color color);

  gfx::TextureLink null_texture;

  Scene scene;
  gfx::Buffer scene_uniform_buffer;

  VIBuffers background_buffers;
  VIBuffers quad_buffers;
  VIBuffers external_buffers;

  QuadBatch batches[c_MaxBatches];
  u32 batch_count = 0;
  u32 quad_count = 0;

  gfx::PipelineLink quad_pipeline_link;
};

}
