$ require "common"

@lpp.import "game/client/graphics/GameRenderer.lh"
@lpp.import "game/client/graphics/Sprite.comp.lh"

@lpp.import "Engine.lh"

@lpp.import "graphics/CompiledShader.lh"
@lpp.import "graphics/RenderPass.lh"
@lpp.import "graphics/Geo.lh"

@lpp.import "game/client/GameMgr.lh"

@lpp.import "game/shared/Transform.comp.lh"
@lpp.import "game/shared/map/Map.defs.lh"
@lpp.import "game/shared/map/Map.sys.lh"
@lpp.import "game/shared/Eye.sys.lh"

#include "iro/time/Time.h"

@log.import

namespace cl
{

/* ----------------------------------------------------------------------------
 */
b8 GameRenderer::init(InitParams& params)
{
  gfx::Vulkan& vk = params.vk;

  params.linker.link(
    "gfx::TextureLink"_typeid, 
    "assets/textures/null"_str,
    &null_texture);

  //init scene uniform buffer
  scene_uniform_buffer = gfx::Buffer::create(vk,
    {
      .data = nullptr,
      .size = sizeof(Scene),
      .usage = gfx::Buffer::UniformBuffer,
      .properties = gfx::Buffer::DeviceMappable,
      .behavior = gfx::Buffer::Occasional,
      .debug_name = "game.renderer.scene"_str,
    });
  if (isnil(scene_uniform_buffer))
    return @log.error(game, "failed to init scene uniform buffer");

  quad_buffers.vertex = gfx::Buffer::create(vk,
    {
      .data       = nullptr,
      .size       = c_MaxQuads * 4 * sizeof(gfx::Vertex),
      .usage      = gfx::Buffer::VertexBuffer,
      .properties = gfx::Buffer::DeviceMappable,
      .behavior   = gfx::Buffer::Occasional,
      .debug_name = "game.renderer.quads.vertex"_str,
    });

  if (isnil(quad_buffers.vertex))
    return @log.error(game, "failed to init the quads vertex buffer");
  
  gfx::Index quad_indices[c_MaxQuads * 6];
  for (int i = 0, j = 0; i < 6*c_MaxQuads; j++, i += 6)
  {
    quad_indices[i+0] = 4*j + 0;
    quad_indices[i+1] = 4*j + 1;
    quad_indices[i+2] = 4*j + 2;
    quad_indices[i+3] = 4*j + 0;
    quad_indices[i+4] = 4*j + 2;
    quad_indices[i+5] = 4*j + 3;
  }

  quad_buffers.index = gfx::Buffer::create(vk,
    {
      .data = quad_indices,
      .size = c_MaxQuads * 6 * sizeof(gfx::Index),
      .usage = gfx::Buffer::IndexBuffer,
      .properties = gfx::Buffer::DeviceOnly,
      .behavior = gfx::Buffer::Never,
      .debug_name = "game.renderer.quads.index"_str,
    });

  if (isnil(quad_buffers.index))
    return @log.error(game, "failed to init the quads index buffer");

  //init quads batches
  batches[0].texture = null_texture.getHandle();
  batch_count = 1;
  quad_count = 0;

  params.linker.link(
    "gfx::PipelineLink"_typeid, 
    "assets/shaders/Quad"_str, 
    &quad_pipeline_link);

  // Initialize external rendering buffers. 
  // TODO(sushi) make this optional, the game wont do this but stuff like 
  //             the map editor does. I would like to make this work better
  //             overall though.
  external_buffers.vertex = gfx::Buffer::create(vk,
  {
    .data = nullptr,
    .size = c_MaxExternal * 4 * sizeof(gfx::Vertex),
    .usage = gfx::Buffer::VertexBuffer,
    .properties = gfx::Buffer::DeviceMappable,
    .behavior = gfx::Buffer::Occasional,
    .debug_name = "game.renderer.external.vertex"_str,
  });

  if (isnil(external_buffers.vertex))
    return @log.error(game, "failed to init external vertex buffer");

  external_buffers.index = gfx::Buffer::create(vk,
  {
    .data = nullptr,
    .size = c_MaxExternal * 6 * sizeof(gfx::Index),
    .usage = gfx::Buffer::IndexBuffer,
    .properties = gfx::Buffer::DeviceMappable,
    .behavior = gfx::Buffer::Occasional,
    .debug_name = "game.renderer.external.index"_str,
  });

  if (isnil(external_buffers.index))
    return @log.error(game, "failed to init external index buffer");

  return true;
}

/* ----------------------------------------------------------------------------
 */
void GameRenderer::deinit(gfx::Vulkan& vk)
{
  scene_uniform_buffer.destroy(vk);

  quad_buffers.vertex.destroy(vk);
  quad_buffers.index.destroy(vk);

  external_buffers.vertex.destroy(vk);
  external_buffers.index.destroy(vk);

  null_texture = {};
  quad_pipeline_link = {};
}

/* ----------------------------------------------------------------------------
 */
static void drawBatches(GameRenderer& sys, gfx::RenderPass& pass)
{
  assert(sys.batch_count <= GameRenderer::c_MaxBatches);
  assert(sys.quad_count <= GameRenderer::c_MaxQuads);

  pass.bindVertexBuffer(sys.quad_buffers.vertex);
  pass.bindIndexBuffer(sys.quad_buffers.index);

  u32 index_offset = 0;
  for (u32 i = 0; i < sys.batch_count; i++)
  {
    assert(notnil(sys.batches[i].texture));
    pass.bindTexture(sys.batches[i].texture);
    pass.draw(index_offset, 6*sys.batches[i].quad_count, 0);
    index_offset += 6*sys.batches[i].quad_count;
  }
  assert(index_offset == 6*sys.quad_count);

  sys.batches[0].quad_count = 0;
  sys.batches[0].texture = sys.null_texture.getHandle();
  sys.batch_count = 1;
  sys.quad_count = 0;
}

/* ----------------------------------------------------------------------------
 */
void GameRenderer::drawQuad(
    gfx::Vulkan& vk,
    gfx::RenderPass& pass,
    vec2f pos,
    gfx::TextureHandle texture,
    vec4f uv,
    Color color)
{
  if (texture != batches[batch_count-1].texture)
  {
    if (batches[batch_count-1].quad_count > 0)
    {
      if (batch_count >= GameRenderer::c_MaxBatches)
      {
        // TODO(delle) investigate if this stalls
        quad_buffers.vertex.flush(vk, 0, gfx::Buffer::FLUSH_WHOLE_BUFFER);
        quad_buffers.vertex.unmap(vk);
        drawBatches(*this, pass);
        quad_buffers.vertex.map(vk);
      }
      else
      {
        batch_count++;
      }
    }

    batches[batch_count-1].quad_count = 0;
    batches[batch_count-1].texture = texture;
  }

  static const vec2f offsets[4] = 
  {
    vec2f(-0.f,-0.f),
    vec2f( 1.f,-0.f),
    vec2f( 1.f, 1.f),
    vec2f(-0.f, 1.f),
  };

  gfx::Vertex quad_verts[4] = {};

  quad_verts[0].pos = pos + offsets[0];
  quad_verts[1].pos = pos + offsets[1];
  quad_verts[2].pos = pos + offsets[2];
  quad_verts[3].pos = pos + offsets[3];

  quad_verts[0].uv = vec2f(uv.x, uv.w);
  quad_verts[1].uv = vec2f(uv.z, uv.w);
  quad_verts[2].uv = vec2f(uv.z, uv.y);
  quad_verts[3].uv = vec2f(uv.x, uv.y);

  quad_verts[0].color = color.rgba;
  quad_verts[1].color = color.rgba;
  quad_verts[2].color = color.rgba;
  quad_verts[3].color = color.rgba;

  auto vp = (gfx::Vertex*)quad_buffers.vertex.mapped_data + 4*quad_count;
  mem::copy(vp, quad_verts, sizeof(quad_verts));

  batches[batch_count-1].quad_count++;
  quad_count++;

  if (quad_count >= GameRenderer::c_MaxQuads)
  {
    // TODO(delle) investigate if this stalls
    quad_buffers.vertex.flush(vk, 0, gfx::Buffer::FLUSH_WHOLE_BUFFER);
    quad_buffers.vertex.unmap(vk);
    drawBatches(*this, pass);
    quad_buffers.vertex.map(vk);
  }
}

/* ----------------------------------------------------------------------------
 */
b8 GameRenderer::render(const RenderParams& params)
{
  // TODO(delle) We might want to sort quads by texture before
  // building their vertexes so we can produce bigger batches.
  // Alternatively, we could use instancing.
  // Alternatively, we could build a sprite sheet so we don't need
  // to change the texture (this is probably the better option).

  gfx::Vulkan& vk = params.vk;

  vec2u view_size = params.viewport_size;

  if (view_size.x == 0 && view_size.y == 0)
  {
    @log.error(game, "GameRenderer::render called with a zero view_size\n");
    return false;
  }

  assert(notnil(params.target));

  ///////////////////////////////////////////////
  // 0. Update Scene
  {
    mat3x2 proj = mat3x2::identity();
    proj.set(0, 0, EyeSys::pixels_per_meter * 2.f / (f32)view_size.x);
    proj.set(1, 1, EyeSys::pixels_per_meter * -2.f / (f32)view_size.y);
    proj.toMat4(scene.proj);

    params.view.toTransposedMat4(scene.view);

    f32 time = (TimePoint::monotonic() - TimePoint{}).toSeconds();

    scene.resolution_and_time[0] = (f32)view_size.x;
    scene.resolution_and_time[1] = (f32)view_size.y;
    scene.resolution_and_time[2] = time;

    scene_uniform_buffer.map(vk);
    scene_uniform_buffer.copyAndFlush(vk, &scene, sizeof(scene));
    scene_uniform_buffer.unmap(vk);
  }

  gfx::RenderPass pass;
  if (!gfx::vk::beginRenderPass(&vk,
        &pass,
        params.target,
        vec2i(0, 0),
        view_size,
        0x000000ff))
    return false;

  pass.setViewport({0,0}, vec2f(view_size));
  pass.setScissor({0,0}, view_size);

  if (params.external != nullptr)
  {
    // If we were given an external render interface, prep its buffer pointers
    // and draw counts.
    params.external->draw_counts = {};
    params.external->vp = (gfx::Vertex*)external_buffers.vertex.map(vk);
    params.external->ip = (gfx::Index*)external_buffers.index.map(vk);
    params.external->pass = &pass;
  }

  ///////////////////////////////////////////////
  // 1. Draw Background
  {
    // renderer.bindFramebuffer(stars_framebuffer);
    // renderer.bindPipeline(stars_pipeline);
    // renderer.bindUniformBuffer(scene_uniform_buffer);
    // renderer.bindVertexBuffer(background_vertex_buffer);
    // renderer.bindIndexBuffer(background_index_buffer);
    // renderer.draw(0, 6, 0);
    //
    // renderer.bindFramebuffer(framebuffer);
    // renderer.bindPipeline(dither_pipeline);
    // renderer.bindTexture(stars_texture);
    // renderer.draw(0, 6, 0);
  }

  ///////////////////////////////////////////////
  // 2. Draw Map Tiles
  // TODO(delle) only update changed tiles after init

  if (params.external != nullptr)
    params.external->preMap();

  pass.bindPipeline(quad_pipeline_link.getHandle());
  pass.bindUniformBuffer(scene_uniform_buffer);
  quad_buffers.vertex.map(vk);

  if (params.map)
  {
    MapState& map = *params.map;

    u32 layer_idx = 0;
    for (const Layer& layer : map.layers)
    {
      Color tint = Color(0xffffffff) * (1.0f - (layer_idx * 0.25f));

      for (const Tile& tile : layer.tiles)
      {
        if (!tile.kind.isValid())
          continue;

        const TileKindDef& tilekind = *tile.kind;

        gfx::TextureHandle texture = 
          tilekind.texture.isValid() 
          ? tilekind.texture.getHandle()
          : null_texture.getHandle();

        vec2f pos = map.getTilePos(layer, tile);
        drawQuad(vk, pass, pos, texture, {0.f,0.f,1.f,1.f}, tint);
      }

      layer_idx++;
    }
  }

  ///////////////////////////////////////////////
  // 3. Draw Sprite Components

  if (params.external != nullptr)
    params.external->preSprites();

  if (params.entmgr && params.map)
  {
    MapState&     map    = *params.map;
    EntityMgr&    entmgr = *params.entmgr;
    ComponentMgr& cmpmgr = entmgr.cmpmgr;

    for (Sprite& sprite : cmpmgr.iterate<Sprite>())
    {
      Entity* owner = entmgr.getEntity(sprite.owner);
      if (owner == nullptr)
      {
        @log.error(game, 
          "sprite component for entity ", sprite.owner.value, 
          " has no owner\n");
        continue;
      }
      
      gfx::TextureHandle texture = null_texture.getHandle();
      vec4f uv = {0.f, 0.f, 1.f, 1.f};
      Color color = 0xff0000ff;
      if (sprite.def->states.isValid())
      {
        const SpriteTexture* stex =
          sprite.def->states->map.getAtIndex(sprite.state);

        if (stex != nullptr && stex->texture.isValid())
        {
          const gfx::CompiledTexture& tex_data = 
            stex->texture->compiled_texture.get();

          texture = stex->texture.getHandle();
          color = stex->color;

          vec2f uv_min = stex->uv.pos();
          vec2f uv_max = stex->uv.extent();

          // TODO(sushi) we need to set up something during data compiling 
          //             that caches these somewhere for us.
          uv.x = uv_min.x / f32(tex_data.width);
          uv.y = uv_min.y / f32(tex_data.height);
          uv.z = uv_max.x / f32(tex_data.width);
          uv.w = uv_max.y / f32(tex_data.height);
        }
      }

      if (auto* transform = entmgr.tryComp<Transform>(sprite.owner))
      {
        Layer& layer = map.layers[transform->placement_layer];

        vec2f pos = transform->pos;
        pos.x += layer.pos.x;
        pos.y += layer.pos.y;

        drawQuad(vk, pass, pos, texture, uv, color);
      }
    }
  }

  quad_buffers.vertex.flush(vk, 0, gfx::Buffer::FLUSH_WHOLE_BUFFER);
  quad_buffers.vertex.unmap(vk);
  if (batch_count > 0)
  {
    drawBatches(*this, pass);
  }

  if (params.external != nullptr)
  {
    params.external->overlay();
    
    pass.bindVertexBuffer(external_buffers.vertex);
    pass.bindVertexBuffer(external_buffers.vertex);

    vec2i external_draw_counts = params.external->draw_counts;
    if (external_draw_counts.x != 0 && external_draw_counts.y != 0)
      pass.draw(0, external_draw_counts.y, 0);

    external_buffers.vertex.unmap(vk);
    external_buffers.index.unmap(vk);

    external_buffers.vertex.flush(vk, 0, gfx::Buffer::FLUSH_WHOLE_BUFFER);
    external_buffers.index.flush(vk, 0, gfx::Buffer::FLUSH_WHOLE_BUFFER);
  }

  gfx::vk::endRenderPass(&vk);

  return true;
}

}
