$ require "common"

@lpp.import "game/shared/structure/Structure.comp.lh"
@lpp.import "game/client/structure/StructureVisualizer.sys.lh"

@lpp.import "game/shared/map/Map.sys.lh"

@lpp.import "game/shared/Transform.comp.lh"
@lpp.import "game/client/graphics/Sprite.comp.lh"

@log.import

namespace cl
{

/* ============================================================================
 */
enum 
{
  R = 1 << 0,
  T = 1 << 1,
  L = 1 << 2,
  B = 1 << 3,
};

static const u64 c_state_map[] = 
{
  [0]       = "Island"_hashed,
  [R]       = "HorizontalLeftCap"_hashed,
  [T]       = "VerticalBottomCap"_hashed,
  [L]       = "HorizontalRightCap"_hashed,
  [B]       = "VerticalTopCap"_hashed,
  [R|T]     = "BottomLeft"_hashed,
  [R|L]     = "Horizontal"_hashed,
  [R|B]     = "TopLeft"_hashed,
  [T|L]     = "BottomRight"_hashed,
  [T|B]     = "Vertical"_hashed,
  [L|B]     = "TopRight"_hashed,
  [R|T|L]   = "ThreeWayBottomCap"_hashed,
  [R|T|B]   = "ThreeWayLeftCap"_hashed,
  [R|L|B]   = "ThreeWayTopCap"_hashed,
  [T|L|B]   = "ThreeWayRightCap"_hashed,
  [R|T|L|B] = "Full"_hashed,
};

static const String c_state_string_map[] = 
{
  [0]       = "Island"_str,
  [R]       = "HorizontalLeftCap"_str,
  [T]       = "VerticalBottomCap"_str,
  [L]       = "HorizontalRightCap"_str,
  [B]       = "VerticalTopCap"_str,
  [R|T]     = "BottomLeft"_str,
  [R|L]     = "Horizontal"_str,
  [R|B]     = "TopLeft"_str,
  [T|L]     = "BottomRight"_str,
  [T|B]     = "Vertical"_str,
  [L|B]     = "TopRight"_str,
  [R|T|L]   = "FullBottomCap"_str,
  [R|T|B]   = "FullRightCap"_str,
  [R|L|B]   = "FullTopCap"_str,
  [T|L|B]   = "FullLeftCap"_str,
  [R|T|L|B] = "Full"_str,
};

/* ----------------------------------------------------------------------------
 */
static u8 constructStructureNeighborMask(
    ExtendableStructure& target,
    vec2f target_tile_pos,
    const Layer& target_layer,
    EntityMgr& entmgr,
    MapState& map)
{
  u8 mask = 0;

  for (auto& other_comp : entmgr.iterateComp<ExtendableStructure>())
  {
    if (target.owner == other_comp.owner)
      continue;

    if (target.def->kind != other_comp.def->kind)
      continue;

    auto* other_transform = entmgr.tryComp<Transform>(other_comp.owner);

    if (&target_layer != map.getLayerByIndex(other_transform->placement_layer))
      continue;

    const Tile* other_tile = target_layer.getTileAtPos(other_transform->pos);
    if (other_tile == nullptr)
      // ???
      continue;

    vec2f other_tile_pos = target_layer.getTilePos(*other_tile);

    vec2f diff = other_tile_pos - target_tile_pos;

    if (diff.mag() == 1.f)
    {
      if (diff.x == 1.f)
        mask |= R;
      else if (diff.y == 1.f)
        mask |= T;
      else if (diff.x == -1.f)
        mask |= L;
      else if (diff.y == -1)
        mask |= B;
    }
  }

  return mask;
}

/* ----------------------------------------------------------------------------
 */
static void updateStructureSpriteAppearance(
    Sprite& target_sprite, 
    u8 neighbor_mask)
{
  auto& sprite_states = *target_sprite.def->states;

  u64 state_idx = sprite_states.map.findIndex(c_state_map[neighbor_mask]);
  if (state_idx == sprite_states.map.len)
  {
    @log.warn(game, 
      "missing sprite state ", c_state_string_map[neighbor_mask]);

    // Try to default back to a horizontal/vertical state if one of the
    // caps are missing.
    switch (neighbor_mask)
    {
    case L:
    case R:
      state_idx = sprite_states.map.findIndex("Horizonal"_hashed);
      break;
    case B:
    case T:
      state_idx = sprite_states.map.findIndex("Vertical"_hashed);
      break;
    }

    // If its still missing, try the Island state.
    if (state_idx == sprite_states.map.len)
      state_idx = sprite_states.map.findIndex("Island"_hashed);

    // And if its STILL missing, just set to an invalid index.
    if (state_idx == sprite_states.map.len)
      state_idx = 0;
  }

  target_sprite.state = state_idx;
}

/* ----------------------------------------------------------------------------
 */
static void updateStructureAppearance(
    ExtendableStructure& structure,
    Sprite& structure_sprite,
    vec2f structure_tile_pos,
    const Layer& structure_layer,
    MapState& map,
    EntityMgr entmgr)
{
  u8 mask = constructStructureNeighborMask(
      structure,
      structure_tile_pos,
      structure_layer,
      entmgr,
      map);

  updateStructureSpriteAppearance(structure_sprite, mask);
}

/* ----------------------------------------------------------------------------
 */
static b8 getStructureLayerTileTransformAndSprite(
    ExtendableStructure& structure,
    MapState& map,
    EntityMgr& entmgr,
    Layer** out_layer,
    Tile** out_tile,
    Transform** out_transform,
    Sprite** out_sprite)
{
  Transform* transform = entmgr.tryComp<Transform>(structure.owner);
  Sprite* sprite = entmgr.tryComp<Sprite>(structure.owner);

  if (sprite == nullptr)
    return false;

  if (!map.getLayerAndTileFromTransform(
        out_layer,
        out_tile,
        *transform))
    return false;

  *out_sprite = sprite;
  *out_transform = transform;

  return true;
}

/* ----------------------------------------------------------------------------
 */
void updateStructureAppearance(
    ExtendableStructure& structure, 
    MapState& map,
    EntityMgr& entmgr)
{
  Transform* structure_transform = nullptr;
  Sprite* structure_sprite = nullptr;
  Layer* structure_layer = nullptr;
  Tile* structure_tile = nullptr;

  if (!getStructureLayerTileTransformAndSprite(
        structure,
        map,
        entmgr,
        &structure_layer,
        &structure_tile,
        &structure_transform,
        &structure_sprite))
    return;

  u8 mask = constructStructureNeighborMask(
      structure,
      structure_layer->getTilePos(*structure_tile),
      *structure_layer,
      entmgr,
      map);

  updateStructureSpriteAppearance(*structure_sprite, mask);
}

/* ----------------------------------------------------------------------------
 */
void updateAllStructureAppearances(MapState& map, EntityMgr& entmgr)
{
  for (auto& structure : entmgr.iterateComp<ExtendableStructure>())
    updateStructureAppearance(structure, map, entmgr);
}

/* ----------------------------------------------------------------------------
 */
void StructureVisualizerSys::onAppearanceChange(
    EntComp<ExtendableStructure> ec,
    AppearanceChange& ev)
{
  updateStructureAppearance(ec.comp, map->state, *entmgr);
}

}
