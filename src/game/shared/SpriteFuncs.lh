/*
 *  Helper functions related to the Sprite component.
 */

$ require "common"

@lpp.import "game/client/graphics/Sprite.comp.lh"
@lpp.import "graphics/View.lh"
@lpp.import "game/shared/Eye.sys.lh"

/* ----------------------------------------------------------------------------
 */
static inline const SpriteTexture* getSpriteTexture(const cl::Sprite& sprite)
{
  if (!sprite.states.isValid())
    return nullptr;

  return sprite.states->map.getAtIndex(sprite.state);
}

/* ----------------------------------------------------------------------------
 */
static const gfx::CompiledTexture* getSpriteCompiledTexture(
    const cl::Sprite& sprite)
{
  if (const SpriteTexture* tex = getSpriteTexture(sprite))
  {
    if (const gfx::TextureResource* r_tex = tex->texture.tryGet())
    {
      if (const gfx::CompiledTexture* c_tex = r_tex->compiled_texture.tryGet())
      {
        return c_tex;
      }
    }
  }
  return nullptr;
}

/* ----------------------------------------------------------------------------
 */
static inline vec2i getSpriteTextureSize(const cl::Sprite& sprite)
{
  if (const SpriteTexture* tex = getSpriteTexture(sprite))
    return vec2i(tex->uv.w, tex->uv.h);
  return vec2i(0);
}

/* ----------------------------------------------------------------------------
 */
static inline vec2f computeSpriteTextureWorldSize(
    const cl::Sprite& sprite,
    const gfx::View& view,
    vec2f viewport_size)
{
  // TODO(sushi) surely this can be done better.
  // TODO(sushi) properly handle rotated views.
  vec2f sprite_size = vec2f(getSpriteTextureSize(sprite)) / view.zoom;
  vec2f origin = view.viewportPointToWorld(vec2f(0.f), viewport_size);
  vec2f extent = view.viewportPointToWorld(sprite_size, viewport_size);

  return (extent - origin).yneg();
}

/* ----------------------------------------------------------------------------
 */
static inline vec2f computeSpriteTextureWorldSize(
    const cl::Sprite& sprite,
    const EyeSys& eye)
{
  return computeSpriteTextureWorldSize(
    sprite,
    eye.view,
    vec2f(eye.viewport_size));
}

/* ----------------------------------------------------------------------------
 *  Given a texture space `point`, tests if the pixel of the current texture
 *  displayed by `sprite` is visible. Can probably do this better later.
 */
static b8 pixelTestSprite(const cl::Sprite& sprite, vec2f point)
{
  const gfx::CompiledTexture* ctex = getSpriteCompiledTexture(sprite);
  if (ctex == nullptr)
    return false;

  // Invert y, because we render textures upside down, or something... I don't
  // remember.
  u32 pos_x = point.x * ctex->width;
  u32 pos_y = (1.f - point.y) * ctex->height;

  u64 pixel_offset = pos_x + pos_y * ctex->width;

  if (pixel_offset >= ctex->width * ctex->height)
    return false;

  auto pixels = (u32*)ctex->pixels.get();

  Color pixel_color = pixels[pixel_offset];

  return pixel_color.a != 0;
}

/* ----------------------------------------------------------------------------
 *  TODO(sushi) this should be removed as its really only for putting the 
 *              uv computation in one place. Eventually we need to store 
 *              a computed uv on SpriteTexture that is cached when the 
 *              data is loaded, so we only compute the proper uv's once.
 */
struct SpriteTextureDraw
{
  gfx::TextureHandle texture = {};
  vec4f uv = {};
  Color color = {};
};

static SpriteTextureDraw computeSpriteTextureDrawForState(
    const cl::Sprite& sprite,
    u32 state,
    SpriteTextureDraw placeholder)
{
  SpriteTextureDraw draw = placeholder;
  if (sprite.states.isValid())
  {
    const SpriteTexture* stex = sprite.states->map.getAtIndex(state);
    if (stex != nullptr && stex->texture.isValid())
    {
      const gfx::CompiledTexture& data = stex->texture->compiled_texture.get();

      draw.texture = stex->texture.getHandle();
      draw.color = stex->color;

      vec2f uv_min = stex->uv.pos();
      vec2f uv_max = stex->uv.extent();

      // TODO(sushi) we need to set up something during data compiling 
      //             that caches these somewhere for us.
      draw.uv.x = uv_min.x / f32(data.width);
      draw.uv.y = uv_min.y / f32(data.height);
      draw.uv.z = uv_max.x / f32(data.width);
      draw.uv.w = uv_max.y / f32(data.height);
    }
  }
  return draw;
}

