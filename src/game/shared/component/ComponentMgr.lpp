$ require "common"
$ local ast = require "reflect.ast"

$ do return end

$$$
local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/game/**/*.comp.lh",
  "src/editor/**/*.comp.lh"
}
$$$
$(imported)

#include "iro/containers/LinkedPool.h"

using namespace iro;

@log.import

@lpp.import "game/shared/component/ComponentMgr.lh"
@lpp.import "game/IndexedPool.lh"

$ local TComponent = astctx:lookupTypeDecl "Component"
$ local function eachComp(f)
$   for decl in astctx.type_decls:each() do
$     if decl:is(ast.Record) and decl:isDerivedFrom(TComponent) then
$       f
$       {
$         name = decl:formCSafeName():get(),
$         typename = decl.type.name,
$         decl = decl,
$       }
$     end
$   end
$ end

#include "iro/containers/BitArray.h"

/* ============================================================================
 */
struct CompPools
{

$ eachComp(function(comp)
  DLinkedPool<$(comp.typename)> $(comp.name)_pool;
  BitArray<4096> $(comp.name)_ent_map;
$ end)

  b8 init()
  {
$ eachComp(function(comp)
    if (!$(comp.name)_pool.init())
      return @log.error(game, 
        "failed to init $(comp.typename) component pool\n");
$ end)
    return true;
  }

  void deinit()
  {
$ eachComp(function(comp)
    for (Component& comp : $(comp.name)_pool)
    {
      comp.kind = 0;
      comp.owner = nil;
    }
    $(comp.name)_pool.deinit();
$ end)
  }

  template<typename T>
  T* allocateComponent();
};

$ eachComp(function(comp)

/* ----------------------------------------------------------------------------
 */
template<>
$(comp.typename)* ComponentMgr::allocateComponent<$(comp.typename)>()
{
  auto* node = pools->$(comp.name)_pool.pushHead();
  auto* cmp = node->data;
  mem::zero(cmp, sizeof($(comp.typename)));
  cmp->node = node;
  cmp->Component::kind = "$(comp.typename)"_hashed;
  return cmp;
}

/* ----------------------------------------------------------------------------
 */
template<>
void ComponentMgr::setEntHasComp<$(comp.typename)>(EntityId id, b8 val)
{
  if (val)
    pools->$(comp.name)_ent_map.set(id.value);
  else
    pools->$(comp.name)_ent_map.unset(id.value);
}


/* ----------------------------------------------------------------------------
 */
template<>
b8 ComponentMgr::entHasComp<$(comp.typename)>(EntityId id)
{
  return pools->$(comp.name)_ent_map.test(id.value);
}

/* ----------------------------------------------------------------------------
 */
template<>
ComponentIter<$(comp.typename)> ComponentMgr::iterate<$(comp.typename)>()
{
  return ComponentIter<$(comp.typename)>{pools->$(comp.name)_pool.headNode()};
}

$ end)

/* ----------------------------------------------------------------------------
 */
void ComponentMgr::deallocateComponent(Component* cmp)
{
  switch (cmp->kind)
  {
$ eachComp(function(comp)
  case "$(comp.typename)"_hashed:
    pools->$(comp.name)_pool.remove(
      (DLinkedPool<$(comp.typename)>::Node*)cmp->node);
    break;
$ end)
  }
}

/* ----------------------------------------------------------------------------
 */
b8 ComponentMgr::init()
{
  pools = mem::stl_allocator.construct<CompPools>();

  if (!pools->init())
    return false;

  return true;
}

/* ----------------------------------------------------------------------------
 */
void ComponentMgr::deinit()
{
  pools->deinit();
  mem::stl_allocator.deconstruct(pools);
}

