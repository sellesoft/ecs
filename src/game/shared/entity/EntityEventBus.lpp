$ local cmn = require "common"
$ local ast = require "reflect.ast"
$ local List = require "iro.List"
$ local glob = require "iro.fs.glob"
$ local dumpValue = require "iro.util".dumpValue

@lpp.import "game/client/entity/EntitySysMgr.lh"

#include "iro/time/Time.h"

@log.import

$$$

local AstContext = require "reflect.AstContext"

local imported = require "string.buffer" .new()
local function importpattern(pattern)
  glob(pattern):each(function(path)
    imported:put((lpp.import(path):getOutput()) or "")
  end)
end

importpattern "src/game/**/*.comp.lh"
importpattern "src/game/**/*.events.lh"

local astctx = require "reflect.AstContext".fromString(tostring(imported))

-- io.write(ast.dump(astctx.translation_unit), '\n')

-- Shorthand helper for looking up a declaration by name.
local function lookup(name)
  return astctx:lookupTypeDecl(name)
end

$$$
@imported:get

@lpp.import "game/shared/entity/EntityMgr.lh"

$ local TComponent = astctx:lookupTypeDecl "Component"

#include "iro/containers/LinkedPool.h"

@lpp.import "game/shared/entity/EntityEventBus.lh"

$ local comps = cmn.List {} 
$ local events = cmn.List {}

$ for decl in astctx.type_decls:each() do
$   if decl.metadata.event == "entity" or decl.metadata.event == "comp-init" 
$   then
$     events:push(decl)
$   elseif decl:is(ast.Record) and decl:isDerivedFrom(TComponent) then
$     comps:push(decl)
$   end
$ end

$ local function eachComponent(f)
$   for comp in comps:each() do
$     f
$     {
$       name = comp:formCSafeName(),
$       typename = comp.type.name,
$       decl = comp,
$     }
$   end
$ end

$ local function eachEvent(f)
$   for event in events:each() do
$     f
$     {
$       name = event:formCSafeName(),
$       typename = event.type.name,
$       decl = event,
$     }
$   end
$ end

$ local function eachCombination(f)
$   -- haha
$   eachComponent(function(comp)
$     eachEvent(function(event)
$       f(comp, event)
$     end)
$   end)
$ end

$ local function getSubTypename(comp, event)
$   return comp.name..'_'..event.name..'_'.."Subscriber"
$ end

$ local function getSubList(comp, event)
$   return getSubTypename(comp, event).."_list"
$ end

/* ============================================================================
 */
struct EntitySubLists
{
  mem::Bump subscriber_arena;

$ eachCombination(function(comp, event)
$   local subname = getSubTypename(comp, event)
$   local listname = getSubList(comp, event)
  struct $(subname)
  {
    void* subscriber;
    void (*callback)(void*, EntComp<$(comp.typename)>, $(event.typename)&);

    $(subname)* next;
  };
  $(subname)* $(listname);
$ end)

$ eachEvent(function(event)
  struct $(event.name)Subscriber
  {
    void* subscriber;
    void (*callback)(void*, $(event.typename)&);

    $(event.name)Subscriber* next;
  };
  $(event.name)Subscriber* $(event.name)_list;
$ end)

  b8 init()
  {
    subscriber_arena.init();
    return true;
  }
};

$ eachCombination(function(comp, event)
/* ----------------------------------------------------------------------------
 */
template<>
void EntityEventBus::subscribeTo<$(comp.typename), $(event.typename)>(
    void* subscriber,
    void (*cb)(void*, EntComp<$(comp.typename)>, $(event.typename)&))
{
  auto* sub = sub_lists->subscriber_arena.
    allocateType<EntitySubLists::$(getSubTypename(comp, event))>();

  sub->subscriber = subscriber;
  sub->callback = cb;

  sub->next = sub_lists->$(getSubList(comp, event));
  sub_lists->$(getSubList(comp, event)) = sub;
}

$ end)

$ eachEvent(function(event)
/* ----------------------------------------------------------------------------
 */
template<>
void EntityEventBus::subscribeTo<$(event.typename)>(
    void* subscriber,
    void (*cb)(void*, $(event.typename)&))
{
  auto* sub = sub_lists->subscriber_arena
    .allocateType<EntitySubLists::$(event.name)Subscriber>();

  sub->subscriber = subscriber;
  sub->callback = cb;

  sub->next = sub_lists->$(event.name)_list;
  sub_lists->$(event.name)_list = sub;
}
$ end)

$ eachEvent(function(event)
/* ----------------------------------------------------------------------------
 */
template<>
void EntityEventBus::raise<$(event.typename)>(
    EntityId id, 
    $(event.typename)& event) const
{
  Entity* ent = entmgr->getEntity(id);

  for (auto& comp : ent->components)
  {
    switch (comp.kind)
    {
$ eachComponent(function(comp)
    case "$(comp.typename)"_hashed:
      for (auto* sub = sub_lists->$(getSubList(comp,event)); 
           sub; sub = sub->next)
        sub->callback(sub->subscriber, {id, ($(comp.typename)&)comp}, event);
      break;
$ end)
    }
  }
}

/* ----------------------------------------------------------------------------
 */
template<>
void EntityEventBus::raise<$(event.typename)>($(event.typename)& event) const
{
  for (auto* sub = sub_lists->$(event.name)_list; sub; sub = sub->next)
    sub->callback(sub->subscriber, event);
}
$ end)

/* ----------------------------------------------------------------------------
 */
b8 EntityEventBus::init(EntityMgr* entmgr)
{
  this->entmgr = entmgr;
  sub_lists = mem::stl_allocator.construct<EntitySubLists>();
  sub_lists->init();
  return true;
}


