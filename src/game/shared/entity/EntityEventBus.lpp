$ local cmn = require "common"
$ local ast = require "reflect.ast"
$ local List = require "iro.List"
$ local glob = require "iro.fs.glob"
$ local dumpValue = require "iro.util".dumpValue

@lpp.import "game/client/entity/EntitySysMgr.lh"

#include "iro/time/Time.h"

@log.import

$$$

local AstContext = require "reflect.AstContext"

local imported = require "string.buffer" .new()
local function importpattern(pattern)
  glob(pattern):each(function(path)
    imported:put((lpp.import(path):get()) or "")
  end)
end

importpattern "src/game/**/*.comp.lh"
importpattern "src/game/**/*.events.lh"

local astctx = require "reflect.AstContext".fromString(tostring(imported))

-- io.write(ast.dump(astctx.translation_unit), '\n')

-- Shorthand helper for looking up a declaration by name.
local function lookup(name)
  return astctx:lookupTypeDecl(name)
end

$$$
@imported:get

@lpp.import "game/shared/entity/EntityMgr.lh"

$ local TComponent = astctx:lookupTypeDecl "Component"

#include "iro/containers/LinkedPool.h"

@lpp.import "game/shared/entity/EntityEventBus.lh"

$ local comps = cmn.List {} 
$ local events = cmn.List {}

$ for decl in astctx.type_decls:each() do
$   if decl.metadata.event == "entity" or decl.metadata.event == "comp-init" 
$   then
$     events:push(decl)
$   elseif decl:is(ast.Record) and decl:isDerivedFrom(TComponent) then
$     comps:push(decl)
$   end
$ end

$ local function eachComponent(f)
$   for comp in comps:each() do
$     f
$     {
$       name = comp:formCSafeName(),
$       typename = comp.type.name,
$       decl = comp,
$     }
$   end
$ end

$ local function eachEvent(f)
$   for event in events:each() do
$     f
$     {
$       name = event:formCSafeName(),
$       typename = event.type.name,
$       decl = event,
$     }
$   end
$ end

$ local function eachCombination(f)
$   -- haha
$   eachComponent(function(comp)
$     eachEvent(function(event)
$       f(comp, event)
$     end)
$   end)
$ end

$ local function getSubTypename(comp, event)
$   return comp.name..'_'..event.name..'_'.."Subscriber"
$ end

$ local function getSubList(comp, event)
$   return getSubTypename(comp, event).."_list"
$ end

/* ============================================================================
 */
struct EntitySubLists
{

$ eachCombination(function(comp, event)
$   local subname = getSubTypename(comp, event)
$   local listname = getSubList(comp, event)
  struct $(subname)
  {
    void* subscriber;
    void (*callback)(void*, EntComp<$(comp.typename)>, $(event.typename)&);
  };
  SLinkedPool<$(subname)> $(listname);
$ end)

$ eachEvent(function(event)
  struct $(event.name)Subscriber
  {
    void* subscriber;
    void (*callback)(void*, $(event.typename)&);
  };
  SLinkedPool<$(event.name)Subscriber> $(event.name)_list;
$ end)

  b8 init()
  {
$ eachCombination(function(comp,event)
    $(getSubList(comp,event)).init();
$ end)
$ eachEvent(function(event)
    $(event.name)_list.init();
$ end)
    return true;
  }
};

$ eachCombination(function(comp, event)
/* ----------------------------------------------------------------------------
 */
template<>
void EntityEventBus::subscribeTo<$(comp.typename), $(event.typename)>(
    void* subscriber,
    void (*cb)(void*, EntComp<$(comp.typename)>, $(event.typename)&))
{
  auto* sub = sub_lists->$(getSubList(comp,event)).push()->data;
  sub->subscriber = subscriber;
  sub->callback = cb;
}

$ end)

$ eachEvent(function(event)
/* ----------------------------------------------------------------------------
 */
template<>
void EntityEventBus::subscribeTo<$(event.typename)>(
    void* subscriber,
    void (*cb)(void*, $(event.typename)&))
{
  auto* sub = sub_lists->$(event.name)_list.push()->data;
  sub->subscriber = subscriber;
  sub->callback = cb;
}
$ end)

$ eachEvent(function(event)
/* ----------------------------------------------------------------------------
 */
template<>
void EntityEventBus::raise<$(event.typename)>(
    EntityId id, 
    $(event.typename)& event) const
{
  Entity* ent = entmgr->getEntity(id);

  for (auto& comp : ent->components)
  {
    switch (comp.kind)
    {
$ eachComponent(function(comp)
    case "$(comp.typename)"_hashed:
      for (auto& sub : sub_lists->$(getSubList(comp,event)))
        sub.callback(sub.subscriber, {id, ($(comp.typename)&)comp}, event);
      break;
$ end)
    }
  }
}

/* ----------------------------------------------------------------------------
 */
template<>
void EntityEventBus::raise<$(event.typename)>($(event.typename)& event) const
{
  for (auto& sub : sub_lists->$(event.name)_list)
    sub.callback(sub.subscriber, event);
}
$ end)

/* ----------------------------------------------------------------------------
 */
b8 EntityEventBus::init(EntityMgr* entmgr)
{
  this->entmgr = entmgr;
  sub_lists = mem::stl_allocator.construct<EntitySubLists>();
$ eachCombination(function(comp, event)
  if (!sub_lists->$(getSubList(comp, event)).init()) return false;
$ end)
$ eachEvent(function(event)
  if (!sub_lists->$(event.name)_list.init()) return false;
$ end)
  return true;
}


