$ local cmn = require "common"
$ local ast = require "reflect.ast"
$ local List = require "iro.List"
$ local glob = require "iro.fs.glob"
$ local dumpValue = require "iro.util".dumpValue

@lpp.import "game/client/entity/EntitySysMgr.lh"

#include "iro/time/Time.h"

@log.import

$$$

local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/game/**/*.comp.lh",
  "src/game/**/*.events.lh",
}

-- Shorthand helper for looking up a declaration by name.
local function lookup(name)
  return astctx:lookupTypeDecl(name)
end

$$$
$(imported)

@lpp.import "game/shared/entity/EntityMgr.lh"

#include "iro/containers/LinkedPool.h"

@lpp.import "game/shared/entity/EntityEventBus.lh"

$ local TComponent = astctx:lookupTypeDecl "Component"
$ local comps = cmn.List {} 
$ local events = cmn.List {}

$ for decl in astctx.type_decls:each() do
$   if decl.metadata.event == "entity" or decl.metadata.event == "component" 
$   then
$     events:push(decl)
$   elseif decl:is(ast.Record) and decl:isDerivedFrom(TComponent) then
$     comps:push(decl)
$   end
$ end

$ local function eachComponent(f)
$   for comp in comps:each() do
$     f
$     {
$       name = comp:formCSafeName(),
$       typename = comp.type.qname,
$       decl = comp,
$     }
$   end
$ end

$ local function eachEvent(f)
$   for event in events:each() do
$     f
$     {
$       name = event:formCSafeName(),
$       typename = event.type.qname,
$       decl = event,
$       kind = event.metadata.event,
$     }
$   end
$ end

$ local function eachCombination(f)
$   -- haha
$   eachComponent(function(comp)
$     eachEvent(function(event)
$       f(comp, event)
$     end)
$   end)
$ end

$ local function getSubTypename(comp, event)
$   return comp.name..'_'..event.name..'_'.."Subscriber"
$ end

$ local function getSubList(comp, event)
$   return getSubTypename(comp, event).."_list"
$ end

/* ============================================================================
 *  TODO(sushi) convert this to store flat arrays of subscribers per 
 *              event component pair. I'm pretty sure we only need to store
 *              enough subscriber slots such that any system can subscribe to
 *              each pair.
 */
struct EntitySubLists
{
  mem::Bump subscriber_arena;

$ eachCombination(function(comp, event)
$   local subname = getSubTypename(comp, event)
$   local listname = getSubList(comp, event)
$   if event.kind == "entity" then

  struct $(subname)
  {
    void* subscriber;
    void (*callback)(void*, EntComp<$(comp.typename)>, $(event.typename)&);

    $(subname)* next;
  };
  $(subname)* $(listname);

$   else

  struct $(subname)
  {
    void* subscriber;
    void (*callback)(void*, $(comp.typename)&, $(event.typename)&);

    $(subname)* next;
  };
  $(subname)* $(listname);

$   end
$ end)

$ eachEvent(function(event)
$   if event.kind == "entity" then
  struct $(event.name)Subscriber
  {
    void* subscriber;
    void (*callback)(void*, $(event.typename)&);

    $(event.name)Subscriber* next;
  };
  $(event.name)Subscriber* $(event.name)_list;
$   end
$ end)

  b8 init()
  {
    subscriber_arena.init();
    return true;
  }
};

$ eachCombination(function(comp, event)
$   if event.kind == "entity" then

/* ----------------------------------------------------------------------------
 */
template<>
void EntityEventBus::subscribeTo<$(comp.typename), $(event.typename)>(
    void* subscriber,
    void (*cb)(void*, EntComp<$(comp.typename)>, $(event.typename)&))
{
  auto* sub = sub_lists->subscriber_arena.
    allocateType<EntitySubLists::$(getSubTypename(comp, event))>();

  sub->subscriber = subscriber;
  sub->callback = cb;

  sub->next = sub_lists->$(getSubList(comp, event));
  sub_lists->$(getSubList(comp, event)) = sub;
}

$   elseif event.kind == "component" then

/* ----------------------------------------------------------------------------
 */
template<>
void EntityEventBus::subscribeTo<$(comp.typename), $(event.typename)>(
    void* subscriber,
    void (*cb)(void*, $(comp.typename)&, $(event.typename)&))
{
  auto* sub = sub_lists->subscriber_arena.
    allocateType<EntitySubLists::$(getSubTypename(comp, event))>();

  sub->subscriber = subscriber;
  sub->callback = cb;

  sub->next = sub_lists->$(getSubList(comp, event));
  sub_lists->$(getSubList(comp, event)) = sub;
}

$   end
$ end)

$ eachEvent(function(event)
$   -- TODO(sushi) make this an explicit entity-broadcast event type or 
$   --             something 
$   if event.kind == "entity" then

/* ----------------------------------------------------------------------------
 */
template<>
void EntityEventBus::subscribeTo<$(event.typename)>(
    void* subscriber,
    void (*cb)(void*, $(event.typename)&))
{
  auto* sub = sub_lists->subscriber_arena
    .allocateType<EntitySubLists::$(event.name)Subscriber>();

  sub->subscriber = subscriber;
  sub->callback = cb;

  sub->next = sub_lists->$(event.name)_list;
  sub_lists->$(event.name)_list = sub;
}

$   end
$ end)

$ eachEvent(function(event)
$   if event.kind == "entity" then
/* ----------------------------------------------------------------------------
 */
template<>
void EntityEventBus::raise<$(event.typename)>(
    EntityId id, 
    $(event.typename)& event) const
{
$     eachComponent(function(comp)
  if (auto* comp = entmgr->tryComp<$(comp.typename)>(id))
  {
    for (auto* sub = sub_lists->$(getSubList(comp, event));
         sub;
         sub = sub->next)
    {
      sub->callback(sub->subscriber, { id, *comp }, event);
    }
  }
$     end)
}

/* ----------------------------------------------------------------------------
 */
template<>
void EntityEventBus::raise<$(event.typename)>($(event.typename)& event) const
{
  for (auto* sub = sub_lists->$(event.name)_list; sub; sub = sub->next)
    sub->callback(sub->subscriber, event);
}

$   end
$ end)

$ eachCombination(function(comp, event)
$   if event.kind == "component" then
$     local subname = getSubTypename(comp, event)
$     local listname = getSubList(comp, event)
/* ----------------------------------------------------------------------------
 */
template<>
void EntityEventBus::raise<$(comp.typename), $(event.typename)>(
    $(comp.typename)& comp,
    $(event.typename)& event) const
{
  for (auto* sub = sub_lists->$(listname); sub; sub = sub->next)
    sub->callback(sub->subscriber, comp, event);
}
$   end
$ end)

/* ----------------------------------------------------------------------------
 */
b8 EntityEventBus::init(EntityMgr* entmgr)
{
  this->entmgr = entmgr;
  sub_lists = mem::stl_allocator.construct<EntitySubLists>();
  sub_lists->init();
  return true;
}


