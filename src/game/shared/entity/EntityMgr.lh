/*
 *  Manages the creation and destruction of Entities as well as storing the 
 *  ComponentMgr that manages their Components.
 */

$ require "common"

#include "iro/Common.h"
#include "iro/containers/LinkedPool.h"

@lpp.import "game/IndexedPool.lh"

@lpp.import "game/shared/entity/Entity.lh"
@lpp.import "game/shared/entity/EntityEventBus.lh"

@lpp.import "game/shared/component/Component.lh"
@lpp.import "game/shared/component/ComponentMgr.lh"

@lpp.import "math/vec.lh"

struct AssetMgr;

namespace gfx
{
struct Renderer;
}

namespace reflect
{
struct Linker;
}

struct EntityDef;
struct EntityDefLink;

/* ============================================================================
 */
struct EntityMgr
{
  enum
  {
    c_max_entities = 4096,
  };

  typedef IndexedPool<Entity, c_max_entities> EntityPool;

  EntityEventBus eventbus;

  EntityPool ent_pool;

  ComponentMgr cmpmgr;

  b8 init();
  void deinit();

  EntityId createEntity(String name);
  
  EntityId spawnEntity(const EntityDefLink& def, vec2f pos, u32 layer);

  void notifyAssetChanged(String name, String type, reflect::Linker& linker);

  // Reloads the given entity with the provided `def` named `def_name`.
  void reloadEntity(Entity* ent, String def_name, const EntityDef& def);

  void destroyEntity(EntityId id);
  void destroyAllEntities();

  IRO_FORCE_INLINE
  Entity* getEntity(EntityId id) const
  {
    if (isnil(id))
      return nullptr;

    return ent_pool.getFromId(id.value, id.salt);
  }
 
  // Unlike the above, this doesn't assert. If this returns nullptr for some
  // given id then it should be assumed that it no longer references a valid
  // entity.
  Entity* tryGetEntity(EntityId id) const
  {
    if (isnil(id))
      return nullptr;
    return ent_pool.tryGetFromId(id.value, id.salt);
  }

  EntityId getEntityId(Entity* ent) const
  {
    if (ent == nullptr)
      return nil;
    EntityId id;
    ent_pool.formId(ent, &id.value, &id.salt);
    return id;
  }
  
  template<typename TComp>
  b8 addComp(Entity* ent, EntityId id, TComp* cmp);

  template<typename TComp>
  b8 addComp(Entity* ent, TComp* cmp)
  {
    return addComp(ent, getEntityId(ent), cmp);
  }

  template<typename TComp>
  b8 addComp(EntityId id, TComp* cmp)
  {
    return addComp(getEntity(id), id, cmp);
  }

  template<typename TComp>
  void removeComp(EntityId id, Entity* ent) const;

  template<typename TComp>
  void removeComp(Entity* ent) const
  {
    return removeComp<TComp>(getEntityId(ent), ent);
  }

  template<typename TComp>
  void removeComp(EntityId id) const
  {
    return removeComp<TComp>(id, getEntity(id));
  }

  template<typename T>
  T* tryComp(EntityId id)
  {
    if (isnil(id))
      return nullptr;
    if (!cmpmgr.entHasComp<T>(id))
      return nullptr;
    return getEntity(id)->tryComp<T>();
  }

  template<typename T, typename X>
  T* tryComp(EntComp<X> id)
  {
    return tryComp<T>(id.ent);
  }

  template<typename TComp>
  ComponentIter<TComp> iterateComp()
  {
    return cmpmgr.iterate<TComp>();
  }

  // This sucks massively.
  struct Iter
  {
    EntityPool* pool;
    EntityPool::Slot* slot;

    b8 isValid() const
    {
      return slot != pool->end();
    }

    void next()
    {
      if (!isValid())
        return;

      slot += 1;
      while (isValid() && !slot->isUsed())
        slot += 1;
    }

    EntityId current()
    {
      EntityId id;
      id.value = slot - pool->pool;
      id.salt = slot->salt;
      return id;
    }

    Iter(EntityMgr& mgr)
    {
      pool = &mgr.ent_pool;
      slot = pool->begin();
    }
  };
};
