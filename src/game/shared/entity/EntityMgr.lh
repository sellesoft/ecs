/*
 *  Manages the creation and destruction of Entities as well as storing the 
 *  ComponentMgr that manages their Components.
 */

$ require "common"

#include "iro/Common.h"
#include "iro/containers/LinkedPool.h"

@lpp.import "game/shared/entity/EntityEventBus.lh"

@lpp.import "game/shared/component/Component.lh"
@lpp.import "game/shared/Transform.comp.lh"

@lpp.import "math/vec.lh"

struct AssetMgr;

namespace gfx
{
struct Renderer;
}

namespace reflect
{
struct Linker;
}

struct EntityDef;
struct EntityDefLink;
struct EntityWorld;

/* ============================================================================
 */
struct EntityMgr
{
  enum
  {
    c_max_entities = 4096,
  };

  EntityEventBus eventbus;

  EntityWorld* world = nullptr;

  u32 next_slot = 0;

  b8 init();
  void deinit();
  
  // Reserves an Entity slot and allocates its required components (currently
  // just Transform).
  EntityId createEntity();

  // Reserves an Entity slot with the desired id.
  EntityId createEntity(u32 desired_id);

  // Loads an Entity with the provided def.
  void loadEntity(
    EntityId id,
    const EntityDef& def,
    const ComponentArray& components);

  void loadEntity(
    u32 raw_id,
    const EntityDefLink& l_def,
    const ComponentArray& components);

  void loadEntity(
    EntityId id,
    const EntityDefLink& l_def,
    const ComponentArray& components);

  void loadEntity(EntityId id, const EntityDef& def) 
    { loadEntity(id, def, {}); }
  void loadEntity(EntityId id, const EntityDefLink& l_def) 
    { loadEntity(id, l_def, {}); }
  
  // Spawns an Entity using the provided def. 
  // 
  // If `components` is not empty, they will be added to the Entity, 
  // overriding any of the same type that may be specified by the def.
  // This is primarily for use by the SceneLoader, but could maybe be used
  // in code, idk though!
  EntityId spawnEntity(
    const EntityDef& def,
    const ComponentArray& components,
    EntityId parent);

  // Similar to the above, but uses a link to an EntityDef. The provided 
  // link's target will be cached on the created Entity so that systems
  // like asset hot-reloading and the SceneEditor can identify what def
  // is relevent to an Entity.
  EntityId spawnEntity(
    const EntityDefLink& def,
    const ComponentArray& components,
    EntityId parent);
  
  // Shorthands for not specifying the Component array.
  EntityId spawnEntity(const EntityDef& def, EntityId parent)
    { return spawnEntity(def, {}, parent); }
  EntityId spawnEntity(const EntityDefLink& l_def, EntityId parent)
    { return spawnEntity(l_def, {}, parent); }

  void notifyAssetChanged(String name, String type, reflect::Linker& linker);

  void destroyEntity(EntityId id);
  void destroyAllEntities();
  
  template<typename TComp>
  TComp* addComp(EntityId id);

  template<typename TComp>
  void removeComp(EntityId id);

  template<typename T>
  T* tryComp(EntityId id);

  template<typename T, typename X>
  T* tryComp(EntComp<X> id)
  {
    return tryComp<T>(id.ent);
  }

  template<typename T>
  Slice<T> eachComp();
  
  // God I love C++.
  template<>
  Transform* tryComp<Transform>(EntityId id);
  
  // Very common and guaranteed to exist, so it gets its own helper.
  Transform& getTransform(EntityId id)
  {
    assert(notnil(id));
    return *tryComp<Transform>(id);
  }

  // Wonder how clang will optimize this one.
  vec2f computeWorldPos(EntityId id)
  {
    if (auto* transform = tryComp<Transform>(id))
      return computeWorldPos(*transform);
    return vec2f(0.f);
  }

  vec2f computeWorldPos(const Transform& transform)
  {
    return transform.pos + computeWorldPos(transform.parent);
  }

  void reparent(EntityId child, EntityId parent)
  {
    assert(notnil(child));
    assert(notnil(parent));
    getTransform(child).parent = parent;
  }

  // Retrieves the name of the def that the Entity was created from. May 
  // return `nil` if it was created through some other means, eg. a 
  // embedded SceneEntity or programatically.
  String getDefName(EntityId id) const;
};
