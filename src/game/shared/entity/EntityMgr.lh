/*
 *  Manages the creation and destruction of Entities as well as storing the 
 *  ComponentMgr that manages their Components.
 */

$ require "common"

#include "iro/Common.h"
#include "iro/containers/LinkedPool.h"

@lpp.import "game/IndexedPool.lh"

@lpp.import "game/shared/entity/Entity.lh"
@lpp.import "game/shared/entity/EntityEventBus.lh"

@lpp.import "game/shared/component/Component.lh"

@lpp.import "math/vec.lh"

struct AssetMgr;

namespace gfx
{
struct Renderer;
}

namespace reflect
{
struct Linker;
}

struct EntityDef;
struct EntityDefLink;
struct EntityWorld;

/* ============================================================================
 */
struct EntityMgr
{
  enum
  {
    c_max_entities = 4096,
  };

  EntityEventBus eventbus;

  EntityWorld* world = nullptr;

  u32 next_slot = 0;

  b8 init();
  void deinit();
  
  // Reserves an Entity slot with a plain Entity (no components) and returns
  // its id.
  EntityId createEntity();
  
  // Spawns an Entity using the provided def. 
  // 
  // If `components` is not empty, they will be added to the Entity, 
  // overriding any of the same type that may be specified by the def.
  // This is primarily for use by the SceneLoader, but could maybe be used
  // in code, idk though!
  EntityId spawnEntity(
    const EntityDef& def,
    const ComponentDefArray& components,
    EntityId parent);

  // Similar to the above, but uses a link to an EntityDef. The provided 
  // link's target will be cached on the created Entity so that systems
  // like asset hot-reloading and the SceneEditor can identify what def
  // is relevent to an Entity.
  EntityId spawnEntity(
    const EntityDefLink& def,
    const ComponentDefArray& components,
    EntityId parent);
  
  // Shorthands for not specifying the Component array.
  EntityId spawnEntity(const EntityDef& def, EntityId parent)
    { return spawnEntity(def, {}, parent); }
  EntityId spawnEntity(const EntityDefLink& l_def, EntityId parent)
    { return spawnEntity(l_def, {}, parent); }

  void notifyAssetChanged(String name, String type, reflect::Linker& linker);

  // Reloads the given entity with the provided `def` named `def_name`.
  void reloadEntity(Entity* ent, String def_name, const EntityDef& def);

  void destroyEntity(EntityId id);
  void destroyAllEntities();

  IRO_FORCE_INLINE
  Entity* getEntity(EntityId id) const
  {
    return nullptr;
  }
 
  // Unlike the above, this doesn't assert. If this returns nullptr for some
  // given id then it should be assumed that it no longer references a valid
  // entity.
  Entity* tryGetEntity(EntityId id) const
  {
    return nullptr;
  }

  EntityId getEntityId(Entity* ent) const
  {
    return nil;
  }
  
  template<typename TComp>
  TComp* addComp(EntityId id);

  template<typename TComp>
  void removeComp(EntityId id, Entity* ent) const;

  template<typename TComp>
  void removeComp(Entity* ent) const
  {
    return removeComp<TComp>(getEntityId(ent), ent);
  }

  template<typename TComp>
  void removeComp(EntityId id) const
  {
    return removeComp<TComp>(id, getEntity(id));
  }

  template<typename T>
  T* tryComp(EntityId id)
  {
    return nullptr;
  }

  template<typename T, typename X>
  T* tryComp(EntComp<X> id)
  {
    return tryComp<T>(id.ent);
  }

  template<typename T>
  Slice<T> eachComp();
};
