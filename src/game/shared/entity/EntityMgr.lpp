$ local cmn = require "common"
$ local ast = require "reflect.ast"

$$$
local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/**/*.comp.lh"
}
$$$
$(imported)

@lpp.import "game/shared/entity/EntityMgr.lh"

@lpp.import "sdata/SourceDataFile.lh"
@lpp.import "sdata/SourceDataParser.lh"
@lpp.import "reflect/Linker.lh"

@lpp.import "game/shared/entity/EntityLoader.lh"
@lpp.import "game/shared/component/Component.events.lh"

#include "iro/fs/File.h"
#include "iro/containers/StackArray.h"

$ local TEntityDef = astctx:lookupTypeDecl "EntityDef"
$ local TComponent = astctx:lookupTypeDecl "Component"
$ assert(TEntityDef and TComponent)
$ local function eachComp(f)
$   for decl in astctx.type_decls:each() do
$     if decl:is(ast.Record) and decl:isDerivedFrom(TComponent) then
$       f
$       {
$         decl = decl,
$         cname = decl:formCSafeName():get(),
$         qname = decl.type.qname,
$         arrname = "CompArray_"..decl:formCSafeName():get()
$       }
$     end
$   end
$ end

@log.import

$ -- Generate a struct containing placeholder component defs to handle cases
$ -- when Components are added to an Entity programatically. Ideally we 
$ -- shouldn't be storing pointers to defs on every component but it is 
$ -- simple and I don't have any better ideas atm.
$ -- TODO(sushi) figure out a better way to handle this, would just rather 
$ --             systems be able to assed Component::def is never nullptr 
$ --             so that they don't have to test if its there everytime they
$ --             use it.

/* ============================================================================
 */
struct ComponentDefPlaceholders
{
$ eachComp(function(comp)
  $(comp.qname)Def $(comp.cname) = {};
$ end)
};

$$$

local max_entities = 100000

local comp_counts = 
{
  Transform = max_entities,
}

local default_comp_count = 0xff

eachComp(function(comp)
  if not comp_counts[comp.cname] then
    comp_counts[comp.cname] = default_comp_count
  end
end)

$$$

$ eachComp(function(comp)
$   local capacity = comp_counts[comp.cname]
struct $(comp.arrname)
{
  static constexpr u64 capacity = $(capacity);

  $(comp.decl.qname) arr[capacity];
  u64 num;

  b8 isFull() const
  {
    return num == capacity;
  }

  struct PushResult
  {
    u64 idx = 0;
    $(comp.decl.qname)* comp;
  };

  PushResult pushFor(EntityId id)
  {
    assert(!isFull());
    
    u64 compidx = num;
    num += 1;

    auto* comp = &arr[compidx];

    // Indicates a bug with owner tracking.
    assert(isnil(comp->owner));
    
    comp->owner = id;

    return { compidx, comp };
  }
};
$ end)

/* ============================================================================
 */
struct ComponentArrays
{
$ eachComp(function(comp)
  $(comp.arrname) $(comp.cname);
$ end)
};

/* ============================================================================
 */
struct ComponentIndexes
{
$ eachComp(function(comp)
  u16 $(comp.cname);
$ end)
};

/* ============================================================================
 */
struct EntitySlot
{
  static constexpr u32 s_used_val = 0xffffffff;
  
  // Not owned (for now).
  String name;

  // TODO(sushi) manage this better. Ideally its just an id (a hash of the 
  //             def asset path) but for something like the MapEditor this is 
  //             easier for now. We should probably only store this in
  //             development builds (as a hash) and just provide a map from
  //             id to asset name stored on EntityMgr.
  String defname;

  ComponentIndexes components;

  u32 next_free = 0;
  u16 generation = 0;

  b8 isUsed() const
  {
    return next_free == s_used_val;
  }
};

/* ============================================================================
 */
struct EntityWorld
{
  ComponentArrays comp_arrays;
  EntitySlot entities[$(max_entities)];
  ComponentDefPlaceholders cdef_placeholder;
};

/* ----------------------------------------------------------------------------
 */
b8 EntityMgr::init()
{
  // TODO(sushi) take an allocator that we can save and reload.
  world = mem::stl_allocator.construct<EntityWorld>();
  if (world == nullptr)
    return @log.error(game, "failed to allocate entity world");

  @log.info(game, "allocated ", tcolor::green, 
    io::ByteUnits(sizeof(EntityWorld)), tcolor::reset, " for entity world");

  if (!eventbus.init(this))
    return @log.error(game, "failed to init entity event bus");

  next_slot = 0; 

  return true;
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::deinit()
{
  mem::stl_allocator.free(world);
  // TODO(sushi) actual clean up 
}

/* ----------------------------------------------------------------------------
 */
static EntitySlot* getEntitySlot(EntityWorld& world, EntityId id)
{
  assert(notnil(id));

  EntitySlot* slot = &world.entities[id.value - 1];
  assert(slot->generation == id.generation);

  return slot;
}

$ eachComp(function(comp)
/* ----------------------------------------------------------------------------
 */
$(comp.decl.qname)* tryComp_$(comp.cname)(
    EntityMgr& self, 
    EntityId id,
    EntitySlot& slot)
{
  u32 index = slot.components.$(comp.cname);
  if (index != 0)
    return &self.world->comp_arrays.$(comp.cname).arr[index - 1];
  return nullptr;
}

/* ----------------------------------------------------------------------------
 */
$(comp.decl.qname)* addComp_$(comp.cname)(
    EntityMgr& self, 
    EntityId id,
    EntitySlot& slot)
{
  assert(nullptr == tryComp_$(comp.cname)(self, id, slot) &&
    "addComp called on an entity that already has this Component");

  auto push_result = self.world->comp_arrays.$(comp.cname).pushFor(id);

  slot.components.$(comp.cname) = push_result.idx + 1;

  self.eventbus.raise(*push_result.comp, ComponentAdd{});

  return push_result.comp;
}

/* ----------------------------------------------------------------------------
 */
void removeComp_$(comp.cname)(
    EntityMgr& self,
    EntityId id,
    EntitySlot& slot)
{
  $(comp.arrname)* parr = &self.world->comp_arrays.$(comp.cname);

  u64 comp_index = slot.components.$(comp.cname) - 1;
  assert(comp_index < parr->capacity);
  assert(comp_index < parr->num);

  $(comp.qname)* to_remove = &parr->arr[comp_index];
  assert(to_remove->owner == id);
  
  // Notify systems that this component is going to be removed so they may 
  // clean up any state related to it.
  self.eventbus.raise(*to_remove, ComponentRemove{});

  // Unset component's owner.
  to_remove->owner = nil;

  if (comp_index != parr->num - 1)
  {
    $(comp.qname)* last_comp = &parr->arr[parr->num - 1];

    EntitySlot* moved_comp_owner = getEntitySlot(
      *self.world, last_comp->owner); 

    // Unordered removal. Swap the component at the end of the array with 
    // this one and update its owner's index into the array.
    mem::copy(to_remove, last_comp, sizeof($(comp.qname)));
    moved_comp_owner->components.$(comp.cname) = comp_index;
  }
  else
  {
    // Just decrement the array's num.
    parr->num -= 1;
  }

  // Invalidate component index for the entity.
  slot.components.$(comp.cname) = 0;
}

/* ----------------------------------------------------------------------------
 */
void tryRemoveComp_$(comp.cname)(
    EntityMgr& self,
    EntityId id,
    EntitySlot& slot)
{
  if (tryComp_$(comp.cname)(self, id, slot))
    removeComp_$(comp.cname)(self, id, slot);
}

/* ----------------------------------------------------------------------------
 */
template<>
$(comp.decl.qname)* EntityMgr::addComp<$(comp.decl.qname)>(EntityId id)
{
  return addComp_$(comp.cname)(*this, id, *getEntitySlot(*world, id));
}

/* ----------------------------------------------------------------------------
 */
template<>
$(comp.qname)* EntityMgr::tryComp<$(comp.qname)>(EntityId id)
{
  if (isnil(id))
    return nullptr;
  return tryComp_$(comp.cname)(*this, id, *getEntitySlot(*world, id));
}

/* ----------------------------------------------------------------------------
 */
template<>
void EntityMgr::removeComp<$(comp.qname)>(EntityId id)
{
  return removeComp_$(comp.cname)(*this, id, *getEntitySlot(*world, id));
}

/* ----------------------------------------------------------------------------
 */
template<>
Slice<$(comp.qname)> EntityMgr::eachComp<$(comp.qname)>()
{
  auto* comparr = &world->comp_arrays.$(comp.cname);
  return makeSlice(comparr->arr, comparr->num);
}
$ end)

/* ----------------------------------------------------------------------------
 *  Raises ComponentInit on all components of the given entity.
 *  Also, if any component does not have a `def`, then it its set to 
 *  its corresponding placeholder, which needs to be redone.
 */
static void initializeEntity(EntityMgr& self, EntityId id, EntitySlot& slot)
{
$ eachComp(function(comp)
  if (auto* comp = tryComp_$(comp.cname)(self, id, slot))
  {
    if (comp->def == nullptr)
      comp->def = &self.world->cdef_placeholder.$(comp.cname);
    self.eventbus.raise(*comp, ComponentInit{});
  }
$ end)
}

/* ----------------------------------------------------------------------------
 *  Raises ComponentStartup on all components of the given entity.
 */
static void startupEntity(EntityMgr& self, EntityId id, EntitySlot& slot)
{
$ eachComp(function(comp)
  if (auto* comp = tryComp_$(comp.cname)(self, id, slot))
    self.eventbus.raise(*comp, ComponentStartup{});
$ end)
}

/* ----------------------------------------------------------------------------
 */
EntityId EntityMgr::createEntity()
{
  if (next_slot == $(max_entities))
  {
    @log.error(game, "EntityMgr has run out of memory to spawn entities");
    return nil;
  }

  u32 entity_id = next_slot + 1;

  EntitySlot* slot = &world->entities[next_slot];

  // Indicates an error in free slot tracking.
  assert(!slot->isUsed());

  // Assert that this slot was not left with references to some component.
$ eachComp(function(comp)
  assert(slot->components.$(comp.cname) == 0 && 
    "EntitySlot was free but still references a $(comp.decl.qname) component");
$ end)
  
  // `next_free` is 0 to indicate that the next free slot follows it, otherwise
  // it is an off-by-one index into the entities array indicating the next 
  // free slot. This is done this way to prevent needing to initialize all 
  // `next_slot`s upon allocating EntityWorld.
  if (slot->next_free == 0)
    next_slot += 1;
  else
    next_slot = slot->next_free - 1;

  // Mark slot as used.
  slot->next_free = EntitySlot::s_used_val;

  // Bump generation.
  slot->generation += 1;

  @log.debug(game, "allocated entity ", entity_id, ":", slot->generation, " "
                   "next slot: ", next_slot);

  return { entity_id, slot->generation };
}

/* ----------------------------------------------------------------------------
 */
EntityId EntityMgr::spawnEntity(
    const EntityDef& def,
    const ComponentDefArray& components,
    EntityId parent)
{
  EntityId id = createEntity();
  if (isnil(id))
    return id;

  EntitySlot* slot = getEntitySlot(*world, id);

  // Apply any provided components first since they get priority.
  for (auto& compdef : components)
  {
    switch (compdef.type.val)
    {
$ eachComp(function(comp)
    case "$(comp.qname)Def"_typeid_val:
      {
        auto* comp = addComp_$(comp.cname)(*this, id, *slot);
        comp->def = compdef.getAs<$(comp.qname)Def>();
      }
      break;
$ end)
    default:
      @log.error(game, "unknown ComponentDef type");
    }
  }
  
  // Then apply components from the def if they weren't already above.
  for (auto& compdef : def.components)
  {
    switch (compdef.type.val)
    {
$ eachComp(function(comp)
    case "$(comp.qname)Def"_typeid_val:
      if (nullptr == tryComp_$(comp.cname)(*this, id, *slot))
      {
        auto* comp = addComp_$(comp.cname)(*this, id, *slot);
        comp->def = compdef.getAs<$(comp.qname)Def>();
      }
      break;
$ end)
    default:
      @log.error(game, "unknown ComponentDef type");
    }
  }
  
  // Make sure we have a Transform component, and that its parent is set
  // before initializing/starting up the entity.
  Transform* transform = tryComp<Transform>(id);
  if (nullptr == transform)
    transform = addComp<Transform>(id);

  transform->parent = parent;

  // Initialize and startup the entity, this is where we raise the 
  // ComponentInit and ComponentStartup events so that entity systems may 
  // perform any special initialization or tracking of Components.
  initializeEntity(*this, id, *slot);
  startupEntity(*this, id, *slot);

  assert(tryComp_Transform(*this, id, *slot) != nullptr);
  
  return id;
}

/* ----------------------------------------------------------------------------
 */
EntityId EntityMgr::spawnEntity(
    const EntityDefLink& def, 
    const ComponentDefArray& components,
    EntityId parent)
{
  EntityId id = spawnEntity(*def, components, parent);
  if (isnil(id))
    return id;
  
  EntitySlot* slot = getEntitySlot(*world, id);
  
  // Cache the name of the def used to load this entity on it. This is 
  // primarily for things like asset hot reloading and the SceneEditor to 
  // tell what defs are relevent to each entity.
  //
  // TODO(sushi) need to do this better eventually, and also don't need to
  //             support this outside of development builds.
  slot->defname = def.name;

  assert(tryComp_Transform(*this, id, *slot) != nullptr);

  return id;
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::notifyAssetChanged(
    String name, 
    String type, 
    reflect::Linker& linker)
{
$ if false then
  if (type != "$(TEntityDef.metadata.source_data_type).data"_str)
    return;

  @log.info(game, "asset changed: ", name, "(", name.hash(), ")\n");

  EntityDefLink new_def;
  linker.link("EntityDefLink"_typeid, name, &new_def);

  for (u32 i = 0; i < c_max_entities; ++i)
  {
    EntityPool::Slot* slot = &ent_pool.pool[i];
    if (slot->isUsed())
    {
      Entity* ent = &slot->elem;
      if (ent->def_name == name)
      {
        reloadEntity(
          ent,
          new_def.name,
          *new_def);
      }
    }
  }
$ end
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::destroyEntity(EntityId id)
{
  EntitySlot* slot = getEntitySlot(*world, id);

$ eachComp(function(comp)
  tryRemoveComp_$(comp.cname)(*this, id, *slot);
$ end)

  slot->name = nil;
  slot->defname = nil;

  slot->next_free = next_slot + 1;
  next_slot = slot - world->entities;

  @log.debug(game, 
    "destroyed entity ", id, 
  "\n        next_slot: ", next_slot,
  "\n  slot->next_free: ", slot->next_free);
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::destroyAllEntities()
{
  // TODO(sushi) iterate Transforms in reverse and call `destroyEntity` on
  //             each.

  assert(!"not implemented (sorry)");
$ if false then
  for (u32 i = 0; i < c_max_entities; ++i)
  {
    EntityPool::Slot* slot = &ent_pool.pool[i];
    if (slot->isUsed())
    {
      Entity* ent = &slot->elem;
      EntityId id;
      ent_pool.formId(ent, &id.value, &id.salt);
      destroyEntity(id);
    }
  }
$ end
}

/* ----------------------------------------------------------------------------
 */
String EntityMgr::getDefName(EntityId id) const
{
  EntitySlot* slot = getEntitySlot(*world, id);
  return slot->defname;
}
