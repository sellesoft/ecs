$ local cmn = require "common"
$ local ast = require "reflect.ast"

$$$
local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/**/*.comp.lh"
}
$$$
@imported:get

@lpp.import "game/shared/entity/EntityMgr.lh"

@lpp.import "sdata/SourceDataFile.lh"
@lpp.import "sdata/SourceDataParser.lh"
@lpp.import "reflect/Linker.lh"

@lpp.import "game/shared/entity/EntityLoader.lh"
@lpp.import "game/shared/component/Component.events.lh"

#include "iro/fs/File.h"

$ local TEntityDef = astctx:lookupTypeDecl "EntityDef"
$ local TComponent = astctx:lookupTypeDecl "Component"
$ assert(TEntityDef and TComponent)
$ local function eachComp(f)
$   for decl in astctx.type_decls:each() do
$     if decl:is(ast.Record) and decl:isDerivedFrom(TComponent) then
$       f(decl)
$     end
$   end
$ end

@log.import

/* ----------------------------------------------------------------------------
 */
b8 EntityMgr::init()
{
  if (!ent_pool.init())
    return @log.error(game, "failed to init entity pool\n");

  if (!cmpmgr.init())
    return @log.error(game, "failed to init component mgr\n");

  if (!eventbus.init(this))
    return @log.error(game, "failed to init entity event bus\n");

  return true;
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::deinit()
{
  destroyAllEntities();
  ent_pool.deinit();
  cmpmgr.deinit();
  // TODO(sushi) actual clean up 
}

/* ----------------------------------------------------------------------------
 */
EntityId EntityMgr::createEntity(String name)
{
  Entity* ent = ent_pool.add();
  ent->init(name);

  EntityId id = {};
  ent_pool.formId(ent, &id.value, &id.salt);

  @log.debug(game, 
    "created entity ", name, " (", id.value, ":", id.salt, ")\n");

  return id;
}

/* ----------------------------------------------------------------------------
 */
EntityId EntityMgr::spawnEntity(const EntityDefLink& def, vec2f pos, u32 layer)
{
  EntityId id = loadEntity(def, *this);
  if (isnil(id))
    return nil;
 
  auto* transform = tryComp<Transform>(id);
  transform->pos = pos;
  transform->placement_layer = layer;
  //
  eventbus.raise(id, ComponentInit{});
  eventbus.raise(id, ComponentStartup{});

  return id;
}


/* ----------------------------------------------------------------------------
 */
void EntityMgr::notifyAssetChanged(
    String name, 
    String type, 
    reflect::Linker& linker)
{
  if (type != "$(TEntityDef.metadata.source_data_type).data"_str)
    return;

  @log.info(game, "asset changed: ", name, "(", name.hash(), ")\n");

  u64 def_id = name.hash();

  for (u32 i = 0; i < c_max_entities; ++i)
  {
    EntityPool::Slot* slot = &ent_pool.pool[i];
    if (slot->isUsed())
    {
      Entity* ent = &slot->elem;
      if (ent->def_id == def_id)
      {
        EntityId id;
        ent_pool.formId(ent, &id.value, &id.salt);
        @log.info(game, "ent ", id, " needs reloaded\n");

        vec2f pos = {};
        f32 rotation = 0.f;
        u32 placement_layer = 0;
        if (const Transform* transform = ent->tryComp<Transform>())
        {
          pos = transform->pos;
          rotation = transform->rotation;
          placement_layer = transform->placement_layer;
        }

        for (Component& comp : ent->components)
        {
          cmpmgr.deallocateComponent(&comp);
        }

        ent->components.deinit();
        ent->components.init();

        EntityDefLink new_def;
        linker.link("EntityDefLink"_typeid, name, &new_def); 

        loadEntity(ent, new_def, *this);

        eventbus.raise(id, ComponentInit{});
        eventbus.raise(id, ComponentStartup{});

        if (Transform* transform = ent->tryComp<Transform>())
        {
          transform->pos = pos;
          transform->rotation = rotation;
          transform->placement_layer = placement_layer;
        }
      }
    }
  }
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::destroyEntity(EntityId id)
{
  if (isnil(id))
    return;

  Entity* ent = ent_pool.getFromId(id.value, id.salt);
  if (ent == nullptr)
    return;

  @log.debug(game, 
    "destroying entity ", ent->name,
    " (", id.value, ":", id.salt, ")\n");

  for (Component& cmp : ent->components)
  {
    cmpmgr.deallocateComponent(&cmp);
  }
  
  ent->deinit();

  ent_pool.remove(ent);
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::destroyAllEntities()
{
  for (u32 i = 0; i < c_max_entities; ++i)
  {
    EntityPool::Slot* slot = &ent_pool.pool[i];
    if (slot->isUsed())
    {
      Entity* ent = &slot->elem;
      EntityId id;
      ent_pool.formId(ent, &id.value, &id.salt);
      destroyEntity(id);
    }
  }
}

$ eachComp(function(decl)

/* ----------------------------------------------------------------------------
 */
template<>
b8 EntityMgr::addComp(Entity* ent, EntityId id, $(decl.type.name)* cmp)
{
  assert(isnil(cmp->owner));

  if (ent->components.find(cmp->Component::kind))
    return false;

  cmp->owner = id;
  ent->components.insert(cmp);

  cmpmgr.setEntHasComp<$(decl.type.name)>(id, true);

  @log.debug(game, 
    "added component $(decl.type.name) to entity ", id.value, "\n");

  eventbus.raise(id, ComponentAdd{});

  return true;
}

/* ----------------------------------------------------------------------------
 */
template<>
void EntityMgr::removeComp<$(decl.type.name)>(EntityId id, Entity* ent) const
{
  Component* comp = ent->components.find("$(decl.type.name)"_hashed);
  if (comp == nullptr)
    return;



  
}

$ end)



