$ local cmn = require "common"
$ local ast = require "reflect.ast"

$$$
local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/**/*.comp.lh"
}
$$$
@@imported:get

@@lpp.import "game/shared/entity/EntityMgr.lh"

@@lpp.import "sdata/SourceDataFile.lh"
@@lpp.import "sdata/SourceDataParser.lh"

@@lpp.import "game/shared/entity/EntityLoader.lh"
@@lpp.import "game/shared/component/Component.events.lh"

#include "iro/fs/File.h"

$ local TComponent = astctx:lookupTypeDecl "Component"
$ local function eachComp(f)
$   for decl in astctx.type_decls:each() do
$     if decl:is(ast.Record) and decl:isDerivedFrom(TComponent) then
$       f(decl)
$     end
$   end
$ end

@log.ger(entmgr, Info)

/* ----------------------------------------------------------------------------
 */
b8 EntityMgr::init()
{
  INFO("initializing\n");
  SCOPED_INDENT;

  if (!ent_pool.init())
    return ERROR("failed to init entity pool\n");

  if (!cmpmgr.init())
    return ERROR("failed to init component mgr\n");

  if (!eventbus.init(this))
    return ERROR("failed to init entity event bus\n");

  INFO("done!\n");
  return true;
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::deinit()
{
  destroyAllEntities();
  ent_pool.deinit();
  cmpmgr.deinit();
  // TODO(sushi) actual clean up 
}

/* ----------------------------------------------------------------------------
 */
EntityId EntityMgr::createEntity(String name)
{
  Entity* ent = ent_pool.add();
  ent->init(name);

  EntityId id = {};
  ent_pool.formId(ent, &id.value, &id.salt);

  DEBUG("created entity ", name, " (", id.value, ":", id.salt, ")\n");

  return id;
}

/* ----------------------------------------------------------------------------
 */
EntityId EntityMgr::spawnEntity(const EntityDef& def, vec2f pos, u32 layer)
{
  assert(false);

  // EntityId id = loadEntity(def, *this);
  // if (isnil(id))
  //   return nil;
  //
  // auto* transform = tryComp<Transform>(id);
  // transform->pos = pos;
  // transform->placement_layer = layer;
  //
  // eventbus.raise(id, ComponentInit{});
  // eventbus.raise(id, ComponentStartup{});

  return {};
  //return id;
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::destroyEntity(EntityId id)
{
  if (isnil(id))
    return;

  Entity* ent = ent_pool.getFromId(id.value, id.salt);
  if (ent == nullptr)
    return;

  DEBUG(
    "destroying entity ", ent->name,
    " (", id.value, ":", id.salt, ")\n");

  for (Component& cmp : ent->components)
  {
    cmpmgr.deallocateComponent(&cmp);
  }
  
  ent->deinit();

  ent_pool.remove(ent);
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::destroyAllEntities()
{
  for (u32 i = 0; i < c_max_entities; ++i)
  {
    EntityPool::Slot* slot = &ent_pool.pool[i];
    if (slot->isUsed())
    {
      Entity* ent = &slot->elem;
      EntityId id;
      ent_pool.formId(ent, &id.value, &id.salt);
      destroyEntity(id);
    }
  }
}

$ eachComp(function(decl)

/* ----------------------------------------------------------------------------
 */
template<>
b8 EntityMgr::addComp(Entity* ent, EntityId id, $(decl.type.name)* cmp) const
{
  assert(isnil(cmp->owner));

  if (ent->components.find(cmp->Component::kind))
    return false;

  cmp->owner = id;
  ent->components.insert(cmp);

  DEBUG("added component $(decl.type.name) to entity ", id.value, "\n");

  eventbus.raise(id, ComponentAdd{});

  return true;
}

/* ----------------------------------------------------------------------------
 */
template<>
b8 EntityMgr::addComp(Entity* ent, $(decl.type.name)* cmp) const
{
  EntityId id;
  ent_pool.formId(ent, &id.value, &id.salt);

  return addComp(ent, id, cmp);
}

/* ----------------------------------------------------------------------------
 */
template<>
b8 EntityMgr::addComp(EntityId id, $(decl.type.name)* cmp) const
{
  return addComp(getEntity(id), id, cmp);
}

$ end)

