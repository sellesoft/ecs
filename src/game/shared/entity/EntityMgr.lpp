$ local cmn = require "common"
$ local ast = require "reflect.ast"

$$$
local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/**/*.comp.lh"
}
$$$
$(imported)

@lpp.import "game/shared/entity/EntityMgr.lh"

@lpp.import "sdata/SourceDataFile.lh"
@lpp.import "sdata/SourceDataParser.lh"
@lpp.import "reflect/Linker.lh"

@lpp.import "game/shared/entity/EntityLoader.lh"
@lpp.import "game/shared/component/Component.events.lh"

#include "iro/fs/File.h"
#include "iro/containers/StackArray.h"

$ local TEntityDef = astctx:lookupTypeDecl "EntityDef"
$ local TComponent = astctx:lookupTypeDecl "Component"
$ assert(TEntityDef and TComponent)
$ local function eachComp(f)
$   for decl in astctx.type_decls:each() do
$     if decl:is(ast.Record) and decl:isDerivedFrom(TComponent) then
$       f
$       {
$         decl = decl,
$         cname = decl:formCSafeName():get(),
$         qname = decl.type.qname,
$         arrname = "CompArray_"..decl:formCSafeName():get()
$       }
$     end
$   end
$ end

@log.import

$$$

local max_entities = 1000000

local comp_counts = 
{
  Transform = max_entities,
}

local default_comp_count = 0xffff

eachComp(function(comp)
  if not comp_counts[comp.cname] then
    comp_counts[comp.cname] = default_comp_count
  end
end)

$$$

$ eachComp(function(comp)
$   local num = comp_counts[comp.cname]
struct $(comp.arrname)
{
  $(comp.decl.qname) arr[$(num)];
  u64 num;

  b8 isFull() const
  {
    return num == $(num);
  }

  struct PushResult
  {
    u64 idx = 0;
    $(comp.decl.qname)* comp;
  };

  PushResult pushFor(EntityId id)
  {
    assert(!isFull());
    
    u64 compidx = num;
    num += 1;

    auto* comp = &arr[compidx];

    // Indicates a bug with owner tracking.
    assert(isnil(comp->owner));
    
    comp->owner = id;

    return { compidx, comp };
  }
};
$ end)

/* ============================================================================
 */
struct ComponentArrays
{
$ eachComp(function(comp)
  $(comp.arrname) $(comp.cname);
$ end)
};

/* ============================================================================
 */
struct ComponentIndexes
{
$ eachComp(function(comp)
  u16 $(comp.cname);
$ end)
};

/* ============================================================================
 */
struct EntitySlot
{
  static constexpr u32 s_used_val = 0xffffffff;
  
  // Not owned (for now).
  String name;

  // TODO(sushi) manage this better. Ideally its just an id (a hash of the 
  //             def asset path) but for something like the MapEditor this is 
  //             easier for now. We should probably only store this in
  //             development builds (as a hash) and just provide a map from
  //             id to asset name stored on EntityMgr.
  String defname;

  ComponentIndexes components;

  u32 next_free = 0;
  u16 generation = 0;

  b8 isUsed() const
  {
    return next_free == s_used_val;
  }
};

/* ============================================================================
 */
struct EntityWorld
{
  ComponentArrays comp_arrays;
  EntitySlot entities[$(max_entities)];
};

/* ----------------------------------------------------------------------------
 */
b8 EntityMgr::init()
{
  // TODO(sushi) take an allocator that we can save and reload.
  world = mem::stl_allocator.construct<EntityWorld>();
  if (world == nullptr)
    return @log.error(game, "failed to allocate entity world");

  @log.info(game, "allocated ", tcolor::green, 
    io::ByteUnits(sizeof(EntityWorld)), tcolor::reset, " for entity world");

  if (!eventbus.init(this))
    return @log.error(game, "failed to init entity event bus");

  next_slot = 0; 

  return true;
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::deinit()
{
  mem::stl_allocator.free(world);
  // TODO(sushi) actual clean up 
}

/* ----------------------------------------------------------------------------
 */
static EntitySlot* getEntitySlot(EntityWorld& world, EntityId id)
{
  assert(notnil(id));

  EntitySlot* slot = &world.entities[id.value - 1];
  assert(slot->generation == id.generation);

  return slot;
}

$ eachComp(function(comp)
/* ----------------------------------------------------------------------------
 */
$(comp.decl.qname)* tryComp_$(comp.cname)(
    EntityMgr& self, 
    EntityId id,
    EntitySlot& slot)
{
  u32 index = slot.components.$(comp.cname);
  if (index != 0)
    return &self.world->comp_arrays.$(comp.cname).arr[index - 1];
  return nullptr;
}

/* ----------------------------------------------------------------------------
 */
$(comp.decl.qname)* addComp_$(comp.cname)(
    EntityMgr& self, 
    EntityId id,
    EntitySlot& slot)
{
  assert(nullptr == tryComp_$(comp.cname)(self, id, slot) &&
    "addComp called on an entity that already has this Component");

  auto push_result = self.world->comp_arrays.$(comp.cname).pushFor(id);

  slot.components.$(comp.cname) = push_result.idx + 1;

  self.eventbus.raise(*push_result.comp, ComponentAdd{});
  
  return push_result.comp;
}

/* ----------------------------------------------------------------------------
 */
template<>
$(comp.decl.qname)* EntityMgr::addComp<$(comp.decl.qname)>(EntityId id)
{
  return addComp_$(comp.cname)(*this, id, *getEntitySlot(*world, id));
}

/* ----------------------------------------------------------------------------
 */
template<>
$(comp.qname)* EntityMgr::tryComp<$(comp.qname)>(EntityId id)
{
  return tryComp_$(comp.cname)(*this, id, *getEntitySlot(*world, id));
}

/* ----------------------------------------------------------------------------
 */
template<>
Slice<$(comp.qname)> EntityMgr::eachComp<$(comp.qname)>()
{
  auto* comparr = &world->comp_arrays.$(comp.cname);
  return makeSlice(comparr->arr, comparr->num);
}
$ end)

/* ----------------------------------------------------------------------------
 *  Raises ComponentInit on all components of the given entity.
 */
static void initializeEntity(EntityMgr& self, EntityId id, EntitySlot& slot)
{
$ eachComp(function(comp)
  if (auto* comp = tryComp_$(comp.cname)(self, id, slot))
    self.eventbus.raise(*comp, ComponentInit{});
$ end)
}

/* ----------------------------------------------------------------------------
 *  Raises ComponentStartup on all components of the given entity.
 */
static void startupEntity(EntityMgr& self, EntityId id, EntitySlot& slot)
{
$ eachComp(function(comp)
  if (auto* comp = tryComp_$(comp.cname)(self, id, slot))
    self.eventbus.raise(*comp, ComponentStartup{});
$ end)
}

/* ----------------------------------------------------------------------------
 */
EntityId EntityMgr::createEntity()
{
  if (next_slot == $(max_entities))
  {
    @log.error(game, "EntityMgr has run out of memory to spawn entities");
    return nil;
  }

  u32 entity_id = next_slot + 1;

  EntitySlot* slot = &world->entities[next_slot];

  // Indicates an error in free slot tracking.
  assert(!slot->isUsed());

  // Assert that this slot was not left with references to some component.
$ eachComp(function(comp)
  assert(slot->components.$(comp.cname) == 0 && 
    "EntitySlot was free but still references a $(comp.decl.qname) component");
$ end)
  
  // `next_free` is 0 to indicate that the next free slot follows it, otherwise
  // it is an off-by-one index into the entities array indicating the next 
  // free slot. This is done this way to prevent needing to initialize all 
  // `next_slot`s upon allocating EntityWorld.
  if (slot->next_free == 0)
    next_slot += 1;
  else
    next_slot = slot->next_free - 1;

  // Mark slot as used.
  slot->next_free = EntitySlot::s_used_val;

  // Bump generation.
  slot->generation += 1;

  return { entity_id, slot->generation };
}

/* ----------------------------------------------------------------------------
 */
EntityId EntityMgr::spawnEntity(
    const EntityDef& def,
    const ComponentDefArray& components,
    EntityId parent)
{
  EntityId id = createEntity();
  if (isnil(id))
    return id;

  EntitySlot* slot = getEntitySlot(*world, id);

  // Apply any provided components first since they get priority.
  for (auto& compdef : components)
  {
    switch (compdef.type.val)
    {
$ eachComp(function(comp)
    case "$(comp.qname)Def"_typeid_val:
      {
        auto* comp = addComp_$(comp.cname)(*this, id, *slot);
        comp->def = compdef.getAs<$(comp.qname)Def>();
      }
      break;
$ end)
    default:
      @log.error(game, "unknown ComponentDef type");
    }
  }
  
  // Then apply components from the def if they weren't already above.
  for (auto& compdef : def.components)
  {
    switch (compdef.type.val)
    {
$ eachComp(function(comp)
    case "$(comp.qname)Def"_typeid_val:
      if (nullptr == tryComp_$(comp.cname)(*this, id, *slot))
      {
        auto* comp = addComp_$(comp.cname)(*this, id, *slot);
        comp->def = compdef.getAs<$(comp.qname)Def>();
      }
      break;
$ end)
    default:
      @log.error(game, "unknown ComponentDef type");
    }
  }
  
  // Make sure we have a Transform component, and that its parent is set
  // before initializing/starting up the entity.
  Transform* transform = tryComp<Transform>(id);
  if (nullptr == transform)
    transform = addComp<Transform>(id);

  transform->parent = parent;

  // Initialize and startup the entity, this is where we raise the 
  // ComponentInit and ComponentStartup events so that entity systems may 
  // perform any special initialization or tracking of Components.
  initializeEntity(*this, id, *slot);
  startupEntity(*this, id, *slot);
  
  return id;
}

/* ----------------------------------------------------------------------------
 */
EntityId EntityMgr::spawnEntity(
    const EntityDefLink& def, 
    const ComponentDefArray& components,
    EntityId parent)
{
  EntityId id = spawnEntity(*def, components, parent);
  if (isnil(id))
    return id;
  
  EntitySlot* slot = getEntitySlot(*world, id);
  
  // Cache the name of the def used to load this entity on it. This is 
  // primarily for things like asset hot reloading and the SceneEditor to 
  // tell what defs are relevent to each entity.
  //
  // TODO(sushi) need to do this better eventually, and also don't need to
  //             support this outside of development builds.
  slot->defname = def.name;

  return id;
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::notifyAssetChanged(
    String name, 
    String type, 
    reflect::Linker& linker)
{
$ if false then
  if (type != "$(TEntityDef.metadata.source_data_type).data"_str)
    return;

  @log.info(game, "asset changed: ", name, "(", name.hash(), ")\n");

  EntityDefLink new_def;
  linker.link("EntityDefLink"_typeid, name, &new_def);

  for (u32 i = 0; i < c_max_entities; ++i)
  {
    EntityPool::Slot* slot = &ent_pool.pool[i];
    if (slot->isUsed())
    {
      Entity* ent = &slot->elem;
      if (ent->def_name == name)
      {
        reloadEntity(
          ent,
          new_def.name,
          *new_def);
      }
    }
  }
$ end
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::reloadEntity(
    Entity* ent,
    String def_name,
    const EntityDef& def)
{
$ if false then
  EntityId id;
  ent_pool.formId(ent, &id.value, &id.salt);
  @log.info(game, "ent ", id, " needs reloaded\n");

  vec2f pos = {};
  f32 rotation = 0.f;
  u32 placement_layer = 0;
  // if (const Transform* transform = ent->tryComp<Transform>())
  // {
  //   pos = transform->pos;
  //   rotation = transform->rotation;
  //   placement_layer = transform->placement_layer;
  // }

  for (Component& comp : ent->components)
  {
    cmpmgr.deallocateComponent(&comp);
  }

  ent->components.deinit();
  ent->components.init();

  loadEntity(
    ent, 
    def_name,
    def, 
    *this);

  eventbus.raise(id, ComponentInit{});
  eventbus.raise(id, ComponentStartup{});

  // if (Transform* transform = ent->tryComp<Transform>())
  // {
  //   transform->pos = pos;
  //   transform->rotation = rotation;
  //   transform->placement_layer = placement_layer;
  // }
$ end
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::destroyEntity(EntityId id)
{
$ if false then
  if (isnil(id))
    return;

  Entity* ent = ent_pool.getFromId(id.value, id.salt);
  if (ent == nullptr)
    return;

  @log.debug(game, 
    "destroying entity ", ent->name,
    " (", id.value, ":", id.salt, ")\n");

  for (Component& cmp : ent->components)
  {
    cmpmgr.deallocateComponent(&cmp);
  }
  
  ent->deinit();

  ent_pool.remove(ent);
$ end
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::destroyAllEntities()
{
$ if false then
  for (u32 i = 0; i < c_max_entities; ++i)
  {
    EntityPool::Slot* slot = &ent_pool.pool[i];
    if (slot->isUsed())
    {
      Entity* ent = &slot->elem;
      EntityId id;
      ent_pool.formId(ent, &id.value, &id.salt);
      destroyEntity(id);
    }
  }
$ end
}





