$ local cmn = require "common"
$ local ast = require "reflect.ast"

$$$
local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/**/*.comp.lh"
}
$$$
$(imported)

@lpp.import "game/shared/entity/EntityMgr.lh"

@lpp.import "sdata/SourceDataFile.lh"
@lpp.import "sdata/SourceDataParser.lh"
@lpp.import "reflect/Linker.lh"

@lpp.import "game/shared/entity/EntityLoader.lh"
@lpp.import "game/shared/component/Component.events.lh"

#include "iro/fs/File.h"
#include "iro/containers/StackArray.h"

$ local TEntityDef = astctx:lookupTypeDecl "EntityDef"
$ local TComponent = astctx:lookupTypeDecl "Component"
$ assert(TEntityDef and TComponent)
$ local function eachComp(f)
$   for decl in astctx.type_decls:each() do
$     if decl:is(ast.Record) and decl:isDerivedFrom(TComponent) then
$       f
$       {
$         decl = decl,
$         cname = decl:formCSafeName():get(),
$         qname = decl.type.qname,
$         arrname = "CompArray_"..decl:formCSafeName():get()
$       }
$     end
$   end
$ end

@log.import

$ -- Generate a struct containing placeholder component defs to handle cases
$ -- when Components are added to an Entity programatically. Ideally we 
$ -- shouldn't be storing pointers to defs on every component but it is 
$ -- simple and I don't have any better ideas atm.
$ -- TODO(sushi) figure out a better way to handle this, would just rather 
$ --             systems be able to assed Component::def is never nullptr 
$ --             so that they don't have to test if its there everytime they
$ --             use it.

$$$

local max_entities = 100000

local comp_counts = 
{
  Transform = max_entities,
}

local default_comp_count = 0xff

eachComp(function(comp)
  if not comp_counts[comp.cname] then
    comp_counts[comp.cname] = default_comp_count
  end
end)

$$$

$ eachComp(function(comp)
$   local capacity = comp_counts[comp.cname]
struct $(comp.arrname)
{
  static constexpr u64 capacity = $(capacity);

  $(comp.decl.qname) arr[capacity];
  u64 num;

  b8 isFull() const
  {
    return num == capacity;
  }

  struct PushResult
  {
    u64 idx = 0;
    $(comp.decl.qname)* comp;
  };

  PushResult pushFor(EntityId id, const $(comp.qname)* prototype)
  {
    assert(!isFull());
    
    u64 compidx = num;
    num += 1;

    auto* comp = &arr[compidx];

    // Indicates a bug with owner tracking.
    assert(isnil(comp->owner));

    if (prototype != nullptr)
      mem::copy(comp, prototype, sizeof($(comp.qname)));
    
    comp->owner = id;

    return { compidx, comp };
  }
};
$ end)

/* ============================================================================
 */
struct ComponentArrays
{
$ eachComp(function(comp)
  $(comp.arrname) $(comp.cname);
$ end)
};

/* ============================================================================
 */
struct ComponentIndexes
{
$ eachComp(function(comp)
  u16 $(comp.cname);
$ end)
};

/* ============================================================================
 */
struct EntitySlot
{
  static constexpr u32 s_used_val = 0xffffffff;
  
  // Not owned (for now).
  String name;

  // TODO(sushi) manage this better. Ideally its just an id (a hash of the 
  //             def asset path) but for something like the MapEditor this is 
  //             easier for now. We should probably only store this in
  //             development builds (as a hash) and just provide a map from
  //             id to asset name stored on EntityMgr.
  String defname;

  ComponentIndexes components;

  u32 next_free = 0;
  u16 generation = 0;

  b8 isUsed() const
  {
    return next_free == s_used_val;
  }
};

/* ============================================================================
 */
struct EntityWorld
{
  ComponentArrays comp_arrays;
  EntitySlot entities[$(max_entities)];
};

/* ----------------------------------------------------------------------------
 */
b8 EntityMgr::init()
{
  // TODO(sushi) take an allocator that we can save and reload.
  world = mem::stl_allocator.construct<EntityWorld>();
  if (world == nullptr)
    return @log.error(game, "failed to allocate entity world");

  @log.info(game, "allocated ", tcolor::green, 
    io::ByteUnits(sizeof(EntityWorld)), tcolor::reset, " for entity world");

  for (u32 slot_idx = 0; slot_idx < $(max_entities); ++slot_idx)
    world->entities[slot_idx].next_free = slot_idx + 1;

  if (!eventbus.init(this))
    return @log.error(game, "failed to init entity event bus");

  next_slot = 0; 

  return true;
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::deinit()
{
  mem::stl_allocator.free(world);
  // TODO(sushi) actual clean up 
}

/* ----------------------------------------------------------------------------
 *  Gets an EntitySlot ignoring the generation validation.
 */
static EntitySlot* getEntitySlotById(EntityWorld& world, u32 id)
{
  assert(id != 0); 
  assert(id <= $(max_entities));
  return &world.entities[id - 1];
}

/* ----------------------------------------------------------------------------
 */
static EntitySlot* getEntitySlot(EntityWorld& world, EntityId id)
{
  assert(notnil(id));

  EntitySlot* slot = getEntitySlotById(world, id.value);
  assert(slot->generation == id.generation);

  return slot;
}


$ eachComp(function(comp)
/* ----------------------------------------------------------------------------
 */
$(comp.decl.qname)* tryComp_$(comp.cname)(
    EntityMgr& self, 
    EntityId id,
    EntitySlot& slot)
{
  u32 index = slot.components.$(comp.cname);
  if (index != 0)
    return &self.world->comp_arrays.$(comp.cname).arr[index - 1];
  return nullptr;
}

/* ----------------------------------------------------------------------------
 */
$(comp.decl.qname)* addComp_$(comp.cname)(
    EntityMgr& self, 
    EntityId id,
    EntitySlot& slot,
    const $(comp.decl.qname)* prototype)
{
  assert(nullptr == tryComp_$(comp.cname)(self, id, slot) &&
    "addComp called on an entity that already has this Component");

  auto push_result = self.world->comp_arrays.$(comp.cname).pushFor(
    id, prototype);

  slot.components.$(comp.cname) = push_result.idx + 1;

  self.eventbus.raise(*push_result.comp, ComponentAdd{});

  return push_result.comp;
}

/* ----------------------------------------------------------------------------
 */
void removeComp_$(comp.cname)(
    EntityMgr& self,
    EntityId id,
    EntitySlot& slot)
{
  $(comp.arrname)* parr = &self.world->comp_arrays.$(comp.cname);

  u64 comp_index = slot.components.$(comp.cname) - 1;
  assert(comp_index < parr->capacity);
  assert(comp_index < parr->num);

  $(comp.qname)* to_remove = &parr->arr[comp_index];
  assert(to_remove->owner == id);
  
  // Notify systems that this component is going to be removed so they may 
  // clean up any state related to it.
  self.eventbus.raise(*to_remove, ComponentRemove{});

  // Unset component's owner.
  to_remove->owner = nil;

  if (comp_index != parr->num - 1)
  {
    $(comp.qname)* last_comp = &parr->arr[parr->num - 1];

    EntitySlot* moved_comp_owner = getEntitySlot(
      *self.world, last_comp->owner); 

    // Unordered removal. Swap the component at the end of the array with 
    // this one and update its owner's index into the array.
    mem::copy(to_remove, last_comp, sizeof($(comp.qname)));
    moved_comp_owner->components.$(comp.cname) = comp_index;
  }
  else
  {
    // Just decrement the array's num.
    parr->num -= 1;
  }

  // Invalidate component index for the entity.
  slot.components.$(comp.cname) = 0;
}

/* ----------------------------------------------------------------------------
 */
void tryRemoveComp_$(comp.cname)(
    EntityMgr& self,
    EntityId id,
    EntitySlot& slot)
{
  if (tryComp_$(comp.cname)(self, id, slot))
    removeComp_$(comp.cname)(self, id, slot);
}

/* ----------------------------------------------------------------------------
 */
template<>
$(comp.decl.qname)* EntityMgr::addComp<$(comp.decl.qname)>(EntityId id)
{
  return addComp_$(comp.cname)(
    *this, 
    id, 
    *getEntitySlot(*world, id),
    nullptr);
}

/* ----------------------------------------------------------------------------
 */
template<>
$(comp.qname)* EntityMgr::tryComp<$(comp.qname)>(EntityId id)
{
  if (isnil(id))
    return nullptr;
  return tryComp_$(comp.cname)(*this, id, *getEntitySlot(*world, id));
}

/* ----------------------------------------------------------------------------
 */
template<>
void EntityMgr::removeComp<$(comp.qname)>(EntityId id)
{
  return removeComp_$(comp.cname)(*this, id, *getEntitySlot(*world, id));
}

/* ----------------------------------------------------------------------------
 */
template<>
Slice<$(comp.qname)> EntityMgr::eachComp<$(comp.qname)>()
{
  auto* comparr = &world->comp_arrays.$(comp.cname);
  return makeSlice(comparr->arr, comparr->num);
}
$ end)

/* ----------------------------------------------------------------------------
 *  Raises ComponentInit on all components of the given entity.
 *  Also, if any component does not have a `def`, then it its set to 
 *  its corresponding placeholder, which needs to be redone.
 */
static void initializeEntity(EntityMgr& self, EntityId id, EntitySlot& slot)
{
$ eachComp(function(comp)
  if (auto* comp = tryComp_$(comp.cname)(self, id, slot))
    self.eventbus.raise(*comp, ComponentInit{});
$ end)
}

/* ----------------------------------------------------------------------------
 *  Raises ComponentStartup on all components of the given entity.
 */
static void startupEntity(EntityMgr& self, EntityId id, EntitySlot& slot)
{
$ eachComp(function(comp)
  if (auto* comp = tryComp_$(comp.cname)(self, id, slot))
    self.eventbus.raise(*comp, ComponentStartup{});
$ end)
}

/* ----------------------------------------------------------------------------
 */
static void removeSlotFromFreeList(
    EntityMgr& self,
    EntitySlot& slot)
{
  u32 slot_idx = &slot - self.world->entities;

  if (slot_idx == self.next_slot)
  {
    // Fast case where the slot is at the head of the free list.
    self.next_slot = slot.next_free;
  }
  else
  {
    // Slow case where we need to find the preceeding slot in the list
    // and set its `next_free` to this one's.
    u32 current_slot = self.next_slot;
    EntitySlot* free_slot = nullptr;
    for (;;)
    {
      free_slot = &self.world->entities[current_slot];

      if (free_slot->next_free == slot_idx)
      {
        free_slot->next_free = slot.next_free;
        break;
      }
      
      current_slot = free_slot->next_free;

      assert(current_slot != $(max_entities));
    }
  }

  slot.next_free = EntitySlot::s_used_val;
  slot.generation += 1;
}

/* ----------------------------------------------------------------------------
 */
static void initializeUnusedSlot(
    EntityMgr& self, 
    EntitySlot& slot)
{
  removeSlotFromFreeList(self, slot);

  // Assert that this slot was not left with references to some component.
$ eachComp(function(comp)
  assert(slot.components.$(comp.cname) == 0 && 
    "EntitySlot was free but still references a $(comp.decl.qname) component");
$ end)
}

/* ----------------------------------------------------------------------------
 */
static void ensureHasRequiredComponents(
    EntityMgr& self,
    EntityId id,
    EntitySlot& slot)
{
  if (!tryComp_Transform(self, id, slot))
    addComp_Transform(self, id, slot, nullptr);
}

/* ----------------------------------------------------------------------------
 */
EntityId EntityMgr::createEntity()
{
  if (next_slot == $(max_entities))
  {
    @log.error(game, "EntityMgr has run out of memory to spawn entities");
    return nil;
  }

  u32 entity_id = next_slot + 1;

  EntitySlot* slot = &world->entities[next_slot];

  // Indicates an error in free slot tracking.
  assert(!slot->isUsed());

  initializeUnusedSlot(*this, *slot);

  EntityId id = { entity_id, slot->generation };

  ensureHasRequiredComponents(*this, id, *slot);
  
  @log.debug(game, "allocated entity ", entity_id, ":", slot->generation, " "
                   "next slot: ", next_slot);

  return id;
}

/* ----------------------------------------------------------------------------
 */
EntityId EntityMgr::createEntity(u32 desired_id)
{
  EntitySlot* slot = getEntitySlotById(*world, desired_id);

  // Check if the slot was not already in use. If not, then we need to 
  // initialize the slot for loading a new entity.
  if (!slot->isUsed())
    initializeUnusedSlot(*this, *slot);

  EntityId id = { desired_id, slot->generation };

  ensureHasRequiredComponents(*this, id, *slot);

  @log.debug(game, "allocated entity ", id, 
                   "next slot: ", next_slot);

  return id;
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::loadEntity(
    EntityId id,
    const EntityDef& def,
    const ComponentArray& components)
{
  EntitySlot* slot = getEntitySlot(*world, id);

  // Apply any provided components first since they get priority.
  for (auto& comp : components)
  {
    switch (comp.type.val)
    {
$ eachComp(function(comp)
$   if comp.qname == "Transform" then
    case "Transform"_typeid_val:
      {
        // TODO(sushi) add a helper for applying a prototype to a Component
        //             w/o overriding its owner id so we aren't doing this.
        Transform& transform = getTransform(id);
        Transform* prototype = (Transform*)comp.ptr;
        transform.pos = prototype->pos;
        transform.rotation = prototype->rotation;
      }
      break;
$   else
    case "$(comp.qname)"_typeid_val:
      {
        addComp_$(comp.cname)(
          *this, 
          id, 
          *slot,
          ($(comp.qname)*)comp.ptr);
      }
      break;
$   end
$ end)
    default:
      @log.error(game, "unknown Component type");
    }
  }
  
  // Then apply components from the def if they weren't already above.
  for (auto& comp : def.components)
  {
    switch (comp.type.val)
    {
$ eachComp(function(comp)
    case "$(comp.qname)"_typeid_val:
      if (nullptr == tryComp_$(comp.cname)(*this, id, *slot))
      {
        addComp_$(comp.cname)(
          *this, 
          id, 
          *slot,
          ($(comp.qname)*)comp.ptr);
      }
      break;
$ end)
    default:
      @log.error(game, "unknown Component type");
    }
  }
  
  // Initialize and startup the entity, this is where we raise the 
  // ComponentInit and ComponentStartup events so that entity systems may 
  // perform any special initialization or tracking of Components.
  initializeEntity(*this, id, *slot);
  startupEntity(*this, id, *slot);

  assert(tryComp_Transform(*this, id, *slot) != nullptr);
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::loadEntity(
    EntityId id,
    const EntityDefLink& l_def,
    const ComponentArray& components)
{
  loadEntity(id, *l_def, components); 

  EntitySlot* slot = getEntitySlot(*world, id);
  slot->defname = l_def.name.allocateCopy();
}

/* ----------------------------------------------------------------------------
 */
EntityId EntityMgr::spawnEntity(
    const EntityDef& def,
    const ComponentArray& components,
    EntityId parent)
{
  EntityId id = createEntity();
  if (isnil(id))
    return id;

  loadEntity(id, def, components);

  return id;
}

/* ----------------------------------------------------------------------------
 */
EntityId EntityMgr::spawnEntity(
    const EntityDefLink& def, 
    const ComponentArray& components,
    EntityId parent)
{
  EntityId id = spawnEntity(*def, components, parent);
  if (isnil(id))
    return id;
  
  EntitySlot* slot = getEntitySlot(*world, id);
  
  // Cache the name of the def used to load this entity on it. This is 
  // primarily for things like asset hot reloading and the SceneEditor to 
  // tell what defs are relevent to each entity.
  //
  // TODO(sushi) need to do this better eventually, and also don't need to
  //             support this outside of development builds.
  slot->defname = def.name.allocateCopy();

  return id;
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::notifyAssetChanged(
    String name, 
    String type, 
    reflect::Linker& linker)
{
$ if false then
  if (type != "$(TEntityDef.metadata.source_data_type).data"_str)
    return;

  @log.info(game, "asset changed: ", name, "(", name.hash(), ")\n");

  EntityDefLink new_def;
  linker.link("EntityDefLink"_typeid, name, &new_def);

  for (u32 i = 0; i < c_max_entities; ++i)
  {
    EntityPool::Slot* slot = &ent_pool.pool[i];
    if (slot->isUsed())
    {
      Entity* ent = &slot->elem;
      if (ent->def_name == name)
      {
        reloadEntity(
          ent,
          new_def.name,
          *new_def);
      }
    }
  }
$ end
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::destroyEntity(EntityId id)
{
  EntitySlot* slot = getEntitySlot(*world, id);

$ eachComp(function(comp)
  tryRemoveComp_$(comp.cname)(*this, id, *slot);
$ end)

  slot->name = nil;
  slot->defname = nil;

  slot->next_free = next_slot + 1;
  next_slot = slot - world->entities;

  @log.debug(game, 
    "destroyed entity ", id, 
  "\n        next_slot: ", next_slot,
  "\n  slot->next_free: ", slot->next_free);
}

/* ----------------------------------------------------------------------------
 */
void EntityMgr::destroyAllEntities()
{
  // TODO(sushi) iterate Transforms in reverse and call `destroyEntity` on
  //             each.

  assert(!"not implemented (sorry)");
$ if false then
  for (u32 i = 0; i < c_max_entities; ++i)
  {
    EntityPool::Slot* slot = &ent_pool.pool[i];
    if (slot->isUsed())
    {
      Entity* ent = &slot->elem;
      EntityId id;
      ent_pool.formId(ent, &id.value, &id.salt);
      destroyEntity(id);
    }
  }
$ end
}

/* ----------------------------------------------------------------------------
 */
String EntityMgr::getDefName(EntityId id) const
{
  EntitySlot* slot = getEntitySlot(*world, id);
  return slot->defname;
}
