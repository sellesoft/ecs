/*
 *  The actual state of a game map, usually loaded from some MapDef.
 */

$ require "common"

@lpp.import "game/shared/map/Map.defs.lh"
@lpp.import "game/shared/Transform.comp.lh"

@log.import

struct EntityMgr;

/* ============================================================================
 */
struct Tile
{
  TileKindLink kind;
};

/* ============================================================================
 */
struct Layer
{
  vec2i pos;
  vec2i size;
  Array<Tile> tiles;

  u32 getTileIndex(const Tile& tile) const
  {
    assert(&tile >= tiles.arr && &tile < tiles.arr + tiles.len());
    return &tile - tiles.arr;
  }

  // Returns the coordinate of a Tile from this Layer in Layer space.
  // Asserts if the given Tile does not belong to this Layer.
  vec2f getTilePos(const Tile& tile) const;

  // Returns a Tile at the given position, which must be local to the
  // Layer. If the given index is out of bounds, nullptr is returned.
  Tile* getTileAtPos(s32 x, s32 y)
  {
    return (Tile*)((const Layer*)this)->getTileAtPos(x, y);
  }

  const Tile* getTileAtPos(s32 x, s32 y) const;

  Tile* getTileAtPos(vec2f pos)
  {
    return getTileAtPos(s32(pos.x), s32(pos.y));
  }

  const Tile* getTileAtPos(vec2f pos) const
  {
    return getTileAtPos(s32(pos.x), s32(pos.y));
  }
};

/* ============================================================================
 */
struct MapState
{
  Array<Layer> layers;

  u32 getLayerIndex(const Layer& layer) const
  {
    assert(&layer >= layers.arr && &layer < layers.arr + layers.len());
    return &layer - layers.arr;
  }

  // Attempts to get a Layer by some index. If the index is out of bounds
  // nullptr is returned, and an error is printed.
  Layer* getLayerByIndex(u32 index);

  // Outputs a Tile as well as the Layer it belongs to at the given pos.
  // Returns false if no tile was at the given pos.
  b8 getTileAndLayerAtPos(Layer** out_layer, Tile** out_tile, vec2f pos);

  // Returns the coordinates of a Tile from the given Layer in world space.
  // Asserts if the Tile does not belong to the given Layer.
  vec2f getTilePos(const Layer& layer, const Tile& tile) const;

  b8 getLayerAndTileFromTransform(
      this MapState& self,
      Layer** out_layer, 
      Tile** out_tile, 
      const Transform& transform)
  {
    Layer* layer = self.getLayerByIndex(transform.placement_layer);
    if (layer == nullptr)
      return false;

    Tile* tile = layer->getTileAtPos(transform.pos);
    if (tile == nullptr)
      return false;

    *out_layer = layer;
    *out_tile = tile;

    return true;
  }
};

/* ============================================================================
 */
struct MapLoadParams
{
  EntityMgr& entmgr;
  logging::Channel* log;
};

b8 loadMap(MapState* state, const MapDef& def, const MapLoadParams& params);
