$ require "common"

@lpp.import "game/shared/map/MapState.lh"
@lpp.import "game/shared/entity/EntityMgr.lh"

#include "math/util.h"

/* ----------------------------------------------------------------------------
 */
vec2f Layer::getTilePos(const Tile& tile) const
{
  u32 tile_idx = getTileIndex(tile);
  return { f32(tile_idx % size.x), f32(tile_idx / size.x) };
}

/* ----------------------------------------------------------------------------
 */
const Tile* Layer::getTileAtPos(s32 x, s32 y) const
{ 
  if (x < 0 || x >= size.x ||
      y < 0 || y >= size.y)
    return nullptr;

  u32 tile_idx = x + size.x * y;
  if (tile_idx < size.y * size.x)
    return &tiles[tile_idx];
  return nullptr;
}

/* ----------------------------------------------------------------------------
 */
Layer* MapState::getLayerByIndex(u32 index)
{
  if (index > layers.len)
    return nullptr;

  return &layers[index];
}

/* ----------------------------------------------------------------------------
 */
b8 MapState::getTileAndLayerAtPos(
    Layer** out_layer,
    Tile**  out_tile,
    vec2f   pos)
{
  for (s32 layer_idx = layers.len-1; layer_idx >= 0; --layer_idx)
  {
    Layer* layer = &layers[layer_idx];
    vec2f layer_pos = vec2f(layer->pos);
    vec2f layer_size = vec2f(layer->size);
    if (math::pointInRect<f32>(pos, layer_pos, layer_size))
    {
      for (s32 tile_idx = layer->tiles.len-1; tile_idx >= 0; --tile_idx)
      {
        Tile* tile = &layer->tiles[tile_idx];
        vec2f tile_pos = layer->getTilePos(*tile);

        if (math::pointInRect<f32>(
              pos,
              layer_pos + tile_pos,
              {1,1}))
        {
          if (out_layer)
            *out_layer = layer;
          if (out_tile)
            *out_tile = tile;
          return true;
        }
      }
    }
  }
  return false;
}

/* ----------------------------------------------------------------------------
 */
vec2f MapState::getTilePos(const Layer& layer, const Tile& tile) const
{
  return vec2f(layer.pos) + layer.getTilePos(tile);
}

/* ============================================================================
 */
struct QueuedEnt
{
  const EntityDefLink* ref;
  vec2f pos;
  u32 layer;
};

/* ============================================================================
 */
struct LoadCtx
{
  SmallArray<QueuedEnt, 64> entities;

  MapState* state;
  EntityMgr* entmgr;
  logging::Channel* log;
};

/* ----------------------------------------------------------------------------
 */
static b8 loadTile(
    LoadCtx& self,
    Tile* tile,
    u32 layer_idx,
    vec2f tile_pos,
    const MapTileDef& def)
{
  tile->kind = def.kind;

  for (const EntityDefLink& ent : def.entities)
  {
    self.entities.push(
    {
      .ref = &ent,
      .pos = tile_pos,
      .layer = layer_idx,
    });
  }

  return true;
}

/* ----------------------------------------------------------------------------
 */
static b8 loadLayer(
    LoadCtx& self, 
    u32 layer_idx,
    Layer* layer,
    const MapLayerDef& def)
{
  if (!layer->tiles.init())
    return @log.chan.error(self.log, game, 
      "failed to initialize layer tiles array (", layer_idx, ")");

  layer->pos = def.pos;
  layer->size = def.size;
  layer->tiles.resize(def.size.x * def.size.y);

  if (layer->tiles.len != def.tiles.len)
    return @log.chan.error(self.log, game,
      "expected ", layer->tiles.len, " tiles in layer ", layer_idx, " but "
      "got ", def.tiles.len);

  for (u32 tile_idx = 0; tile_idx < def.tiles.len; ++tile_idx)
  {
    const MapTileDef* tile_def = def.tiles.arr + tile_idx;
    Tile* tile = layer->tiles.arr + tile_idx;

    if (!loadTile(self, tile, layer_idx, layer->getTilePos(*tile), *tile_def))
      return false;
  }

  return true;
}

/* ----------------------------------------------------------------------------
 */
static b8 loadMap(LoadCtx& self, const MapDef& def)
{
  if (!self.state->layers.init())
    return @log.chan.error(self.log, game, 
      "failed to initialize map layers array");

  self.state->layers.resize(def.layers.len);

  for (u32 layer_idx = 0; layer_idx < def.layers.len; ++layer_idx)
  {
    const MapLayerDef* layer_def = def.layers.arr + layer_idx;
    Layer* layer = self.state->layers.arr + layer_idx;

    if (!loadLayer(self, layer_idx, layer, *layer_def))
      return false;
  }

  // Load deferred entities. This is done so that systems that rely on 
  // the positions of entities during their initialization can use the
  // map properly.
  for (auto& qent : self.entities)
  {
    if (isnil(self.entmgr->spawnEntity(*qent.ref, qent.pos, qent.layer)))
      return @log.chan.error(self.log, game, "failed to spawn map entity");
  }

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 loadMap(MapState* state, const MapDef& def, const MapLoadParams& params)
{
  LoadCtx ctx = {};
  ctx.state = state;
  ctx.entmgr = &params.entmgr;
  ctx.log = params.log;

  return loadMap(ctx, def);
}
