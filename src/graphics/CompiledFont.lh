/*
 *  A font loaded from disk.
 *
 *  TODO(sushi) we can likely organize our font data more appropriately than
 *              just copying what stbtt does. We don't even support TTF fonts
 *              at time of writing. Eventually, we'll want to move towards 
 *              fonts being defined from glyph sets anyways, rather than just 
 *              a single font file.
 */

$ local cmn = require "common"
$ local metadata = require "reflect.Metadata"

#include "iro/Common.h"
#include "iro/Unicode.h"
#include "iro/traits/Nil.h"
#include "iro/containers/Slice.h"
#include "math/vec.h"

using namespace iro;

@lpp.import "asset/Asset.lh"
@lpp.import "core/OffsetPtr.lh"
@lpp.import "graphics/Font.defs.lh"

namespace build { struct Rule; struct Result; }

namespace gfx 
{ 

struct CompiledTexture;

/* ==========================================================================
 *  This mirrors stbtt_aligned_quad
 */
struct AlignedQuad
{
  f32 x0, y0, u0, v0;
  f32 x1, y1, u1, v1;
};

/* ==========================================================================
 *  This mirrors stbtt_packedchar
 */
struct PackedChar
{
  unsigned short x0, y0, x1, y1;
  f32 xoff, yoff, xadvance;
  f32 xoff2, yoff2;
  f32 u0, v0, u1, v1;
};

/* ==========================================================================
 *  This mirrors stbtt_pack_range
 */
struct PackRange
{
  f32 font_size;
  s32 first_codepoint;
  OffsetSlice<PackedChar> chars;
};

/* ============================================================================
 *  NOTE(sushi) we will eventually want to get rid of this distinction 
 *              as Fonts should be compiled from glyph sets that mix 
 *              different fonts and arbitrary textures together.
 */
enum class FontKind
{
  BDF,
  // NOTE(sushi) not currently supported.
  // TODO(sushi) get supported once we get to displaying fonts other 
  //             than gohu :)
  // TTF,
};

/* ============================================================================
 *  Compiled font data saved to disk. 
 */
struct CompiledFont
{
  FontKind kind;

  u32 count;
  f32 height;
  s32 size_x;
  s32 size_y;
  f32 ascent;
  f32 descent;
  f32 line_gap;

  OffsetSlice<PackRange> ranges;

  // It's recommended to use this to find the proper range for a given
  // codepoint and then passing it to getPackedChar() when you know what
  // ranges you'll be working with.
  // Returns nullptr if no range exists in this font for the given codepoint.
  PackRange* getRangeOfCodepoint(u32 codepoint) const;

  // Returns false if the given codepoint doesn't exist in any range 
  // stored by this font.
  b8 getPackedChar(PackedChar* out, u32 codepoint) const;

  // TODO(sushi) this is a dangerous function that needs to be redone.
  void getPackedChar(PackedChar* out, PackRange* range, u32 codepoint) const;

  vec2f getGlyphSize(u32 codepoint) const;
};

@metadata.links(font.compiled)
struct CompiledFontLink : TypedAssetLink<CompiledFont> {};

struct CompileFontParams
{
  String input_path;
  String output_path;
  String texture_output_path;

  build::Result* result;
};

b8 compileFont(const CompileFontParams& params);

build::Rule getFontBuildRule();

}
