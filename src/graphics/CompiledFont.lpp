$ local cmn = require "common"

#include "math.h"

#include "iro/io/Stream.h"
#include "iro/fs/File.h"
#include "iro/fs/fs.h"
#include "iro/Scanner.h"
#include "iro/memory/BinaryDataBuilder.h"

@lpp.import "graphics/CompiledFont.lh"
@lpp.import "graphics/CompiledTexture.lh"
@lpp.import "graphics/TextureParams.lh"
@lpp.import "reflect/CompiledData.lh"
@lpp.import "build/Result.lh"

#include "iro/memory/Bump.h"

@log.import

typedef io::StaticBuffer<512> PathBuffer;

namespace gfx
{

/* ----------------------------------------------------------------------------
 */
template<typename... Args>
b8 buildError(build::Result* result, Args... args)
{
  if (result != nullptr)
    result->pushError(args...);
  else
    @log.error(gfx, args..., '\n');

  return false;
}

/* ----------------------------------------------------------------------------
 */
static b8 codepointInRange(PackRange range, u32 codepoint)
{
  return codepoint >= range.first_codepoint &&
         codepoint < range.first_codepoint + range.chars.len;
}

/* ----------------------------------------------------------------------------
 */
PackRange* CompiledFont::getRangeOfCodepoint(u32 codepoint) const
{
  const Slice<PackRange> ranges = this->ranges.getSlice();

  if (ranges.len == 1)
  {
    if (codepointInRange(*ranges.ptr, codepoint))
      return ranges.ptr;
    else
      return nullptr;
  }

  for (s32 rangeidx = 0; rangeidx < ranges.len; ++rangeidx)
  {
    PackRange* range = ranges.ptr + rangeidx;
    
    if (codepointInRange(*range, codepoint))
      return range;
  }

  return nullptr;
}

/* ----------------------------------------------------------------------------
 */
b8 CompiledFont::getPackedChar(PackedChar* out, u32 codepoint) const
{
  PackRange* range = getRangeOfCodepoint(codepoint);
  if (!range)
    return false;
  getPackedChar(out, range, codepoint);
  return true;
}

/* ----------------------------------------------------------------------------
 */
vec2f CompiledFont::getGlyphSize(u32 codepoint) const
{
  PackedChar pc;
  if (!getPackedChar(&pc, codepoint))
    return {};

  return vec2f(pc.x1 - pc.x0, pc.y1 - pc.y0);
}

/* ----------------------------------------------------------------------------
 */
void CompiledFont::getPackedChar(
    PackedChar* out, 
    PackRange* range, 
    u32 codepoint) const
{
  *out = *(range->chars.ptr.get() + codepoint - range->first_codepoint);
}

/* ----------------------------------------------------------------------------
 */
static b8 compileFontBDF(
    const FontDef& def,
    mem::BinaryDataBuilder* data_buffer,
    mem::BinaryDataBuilder* pixels_buffer,
    vec2i* out_texture_size,
    ImageFormat* out_format,
    build::Result* result)
{
  using namespace fs;

  String source_path = def.asset_path;

  auto file = File::openForRead(source_path);
  if (isnil(file))
    return false;
  defer { file.close(); };

  Scanner scanner = {};
  if (!scanner.init(&file))
    return buildError(result, "failed to initialize Scanner\n");
  defer { scanner.deinit(); };

  auto err = [&](auto... args)
  {
    buildError(result, source_path, ':', scanner.line, ':', scanner.column, ": ", 
          args...);
    return false;
  };
    
  if ("STARTFONT"_str != scanner.scanIdentifier())
    return err("font does not start with STARTFONT");

  scanner.skipLine();

  enum class Section
  {
    Global,
    FontProperties,
    Chars,
    Char,
  } section = Section::Global;

  vec4i bbx = {};

  auto consumeNumber = [&](auto* x)
  {
    scanner.skipWhitespace();
    io::StaticBuffer<16> buf;

    if (0 == scanner.scanNumber(&buf))
      return err("expected a number");
    *x = atoi((char*)buf.arr);
    return true;
  };

  // Determine the number of codepoints we want to compile.
  u32 num_codepoints = 0;
  for (auto& range : def.ranges)
    num_codepoints += range.num_codepoints;

  // Allocate the full buffer.
  u64 data_size = 
    sizeof(CompiledFont) + 
    sizeof(PackRange) * def.ranges.len + 
    sizeof(PackedChar) * num_codepoints;

  data_buffer->writeZeroed(data_size);
  auto* data = (CompiledFont*)data_buffer->data.ptr;
  data->kind = FontKind::BDF;

  auto* ranges = (PackRange*)(data + 1);
  data->ranges.setSlice(ranges, def.ranges.len);

  auto* chars = (PackedChar*)(ranges + def.ranges.len);

  u32 chars_offset = 0;
  for (s32 i = 0; i < def.ranges.len; ++i)
  {
    PackRange* out_range = ranges + i;
    const CodepointRange* in_range = &def.ranges[i];
    
    out_range->first_codepoint = in_range->first_codepoint;
    out_range->chars.setSlice(chars + chars_offset, in_range->num_codepoints);

    chars_offset += in_range->num_codepoints;
  }

  // Figure out how many codepoints we want per row.
  u64 codepoints_per_row = 
    roundUpToPower2(u64(sqrt((f32)num_codepoints)));

  // And how many rows.
  u64 row_count = 1 + num_codepoints / codepoints_per_row;

  u8* pixels = nullptr;
  vec2i texture_size = {};
  u32 width_aligned = 0;

  static const u32 max_bitmap_rows = 32;

  struct Char
  {
    u64   encoding;
    vec4i bbx;
    vec2i dwidth;
    u64   bitmap_rows[max_bitmap_rows];
  };

  // The current character we are parsing.
  Char curchar = {};

  // The number of characters reported by the font.
  u64 bdf_chars_count = 0;

  // Keep around the last range we wrote to to avoid looking up the same
  // range repeatedly.
  PackRange* currange = ranges;

  auto getPackedChar = [&]() -> PackedChar*
  {
    // Check if curchar is within the cached range.
    if (curchar.encoding < currange->first_codepoint ||
        curchar.encoding > currange->first_codepoint + currange->chars.len)
    {
      // Search for a range containing curchar.
      b8 found = false;
      for (PackRange& range : data->ranges.getSlice())
      {
        if (curchar.encoding > range.first_codepoint &&
            curchar.encoding < range.first_codepoint + range.chars.len)
        {
          currange = &range;
          found = true;
          break;
        }
      }
      
      if (!found)
        return nullptr;
    }

    return 
      currange->chars.ptr.get() + 
      (curchar.encoding - currange->first_codepoint);
  };

  auto getCharPixelsOffset = [&]()
  {
    u32 offset = 0;

    auto* irange = ranges;
    while (irange != currange)
    {
      offset += irange->chars.len;
      irange += 1;
    }

    offset += (curchar.encoding - currange->first_codepoint);
    
    vec2i pos;
    pos.x = offset % codepoints_per_row;
    pos.y = offset / codepoints_per_row;
    return pos.x * bbx.z + bbx.w * pos.y * texture_size.x;
  };

  for (b8 done = false; !done;)
  {
    scanner.skipWhitespace();

    if (scanner.eof())
      return err("unexpected end of file");

    String keyword = scanner.scanIdentifier();
    if (isnil(keyword))
      return err("expected a keyword");

    if ("COMMENT"_str == keyword)
    {
      scanner.skipLine();
      continue;
    }

    u64 keyword_hash = keyword.hash();

    switch (section)
    {
    case Section::Global:
      switch (keyword_hash)
      {
      case "FONTBOUNDINGBOX"_hashed:
        if (!consumeNumber(&bbx.z)) return false;
        if (!consumeNumber(&bbx.w)) return false;
        if (!consumeNumber(&bbx.x)) return false;
        if (!consumeNumber(&bbx.y)) return false;

        data->height = bbx.w;
        
        width_aligned = u64(ceil(bbx.z / 2.f) * 2.f);

        // We have enough information to setup the texture now.
        texture_size = vec2i(
          codepoints_per_row * width_aligned, row_count * bbx.w);

        data->size_x = texture_size.x;
        data->size_y = texture_size.y;

        pixels_buffer->writeZeroed(u64(texture_size.x) * texture_size.y);
        pixels = pixels_buffer->data.ptr;

        // Set the font height of each range (not sure if this is actually 
        // used ever).
        for (s32 i = 0; i < def.ranges.len; ++i)
          ranges[i].font_size = bbx.w;
        break;

      case "STARTPROPERTIES"_hashed:
        section = Section::FontProperties;
        scanner.skipLine();
        break;

      case "CHARS"_hashed:
        if (!consumeNumber(&bdf_chars_count))
          return false;
        section = Section::Chars;
        break;

      default:
        scanner.skipLine();
        break;
      }
      break;
    
    case Section::FontProperties:
      switch (keyword_hash)
      {
      case "FONT_ASCENT"_hashed:
        if (!consumeNumber(&data->ascent))
          return false;
        break;
      case "FONT_DESCENT"_hashed:
        if (!consumeNumber(&data->descent))
          return false;
        break;
      case "ENDPROPERTIES"_hashed:
        section = Section::Global;
        break;
      default:
        scanner.skipLine();
        break;
      }
      break;

    case Section::Chars:
      switch (keyword_hash)
      {
      case "STARTCHAR"_hashed:
        section = Section::Char;
        scanner.skipLine();
        curchar = {};
        break;

      case "ENDFONT"_hashed:
        done = true;
        break;

      default:
        if (bdf_chars_count != 0)
          return err("expected STARTCHAR (", bdf_chars_count, " remaining)");
        section = Section::Global;
        break;
      }
      break;

    case Section::Char:
      switch (keyword_hash)
      {
      case "ENCODING"_hashed:
        if (!consumeNumber(&curchar.encoding))
          return false;
        break;
      case "DWIDTH"_hashed:
        if (!consumeNumber(&curchar.dwidth.x))
          return false;
        if (!consumeNumber(&curchar.dwidth.y))
          return false;
        break;
      case "BBX"_hashed:
        if (!consumeNumber(&curchar.bbx.z)) return false;
        if (!consumeNumber(&curchar.bbx.w)) return false;
        if (!consumeNumber(&curchar.bbx.x)) return false;
        if (!consumeNumber(&curchar.bbx.y)) return false;
        assert(curchar.bbx.w < max_bitmap_rows);
        break;
      case "BITMAP"_hashed:
        scanner.skipLine();
        for (s32 row = 0; row < curchar.bbx.w; ++row)
        {
          String val = scanner.scanLine();
          curchar.bitmap_rows[row] = strtoll((char*)val.ptr, nullptr, 16);
        }
        break;
      case "ENDCHAR"_hashed:
        if (PackedChar* pchar = getPackedChar())
        {
          /*
             bbx.z (6)
      bbx.w  `------->
      (11) `  ________  
            | |      | ,-- cbbx.w (8)
            | | #    | | 
            | | #    | |
            | | #    | |
            | | #    | |
            | | #    | |
            | | #    | |
            | |      | |
            | * #    | v<-- cbbx.y (0)
            | |      |
   bbx.y -> v |______|
   (-2)       ^ ^
              bbx.x (0)
                |
                cbbx.x (2) & cbbx.z (1)
              
              top = 11 - (0 - (-2)) - 8 = 1

           */

          u32 top_offset = bbx.w - (curchar.bbx.y - bbx.y) - curchar.bbx.w;
          u32 left_offset = curchar.bbx.x - bbx.x;

          u32 pix_offset = getCharPixelsOffset();

          auto pos = 
            vec2i(pix_offset % texture_size.x, pix_offset / texture_size.x);

          pchar->x0 = pos.x;
          pchar->y0 = pos.y;
          pchar->x1 = pos.x + bbx.z;
          pchar->y1 = pos.y + bbx.w;
          pchar->xadvance = curchar.dwidth.x;
          pchar->xoff = pchar->yoff = pchar->xoff2 = pchar->yoff2 = 0.f;
          pchar->u0 = f32(pchar->x0) / texture_size.x;
          pchar->v0 = f32(pchar->y0) / texture_size.y;
          pchar->u1 = f32(pchar->x1) / texture_size.x;
          pchar->v1 = f32(pchar->y1) / texture_size.y;

          u8* tl = pixels + pix_offset;
          u8* ctl = tl + top_offset * texture_size.x + left_offset;

          for (u32 rowi = 0; rowi < curchar.bbx.w; ++rowi)
          {
            u8* row = ctl + (rowi * texture_size.x);

            for (u32 coli = 0; coli < curchar.bbx.z; ++coli)
            {
              if (curchar.bitmap_rows[rowi] & (1 << (bbx.z - coli + 1)))
                *(row + coli) = 0xff;
            }
          }
        }
        section = Section::Chars;
        bdf_chars_count -= 1;
        break;
      default:
        scanner.skipLine();
        break;
      }
      break;
    }
  }

  *out_texture_size = texture_size;
  *out_format = ImageFormat::BW;

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 compileFont(const CompileFontParams& params)
{
   using namespace fs;

   String input_path = params.input_path;
   String output_path = params.output_path;
   String texture_output_path = params.texture_output_path;
   build::Result* result = params.result;
  
  if (isnil(input_path))
    return buildError(result, "compileFont called with a nil input path");

  if (isnil(output_path))
    return buildError(result, "compileFont called with a nil output path");

  if (isnil(texture_output_path))
    return buildError(result, 
      "compileFont called with a nil texture output path");

  // Immediately open (and thus lock) the desired output file to quickly 
  // catch any possible errors with doing so.
  File out_file = File::createForTruncatedWriting(output_path);
  if (isnil(out_file))
    return buildError(result, 
      "failed to open file for writing compiled font at '",output_path, "'");
  defer { out_file.close(); };

  // Do the same with the texture.
  File texture_out_file = File::createForTruncatedWriting(texture_output_path);
  if (isnil(texture_out_file))
    return buildError(result, 
      "failed to open file for writing compiled font texture at '",
                 texture_output_path, "'");
  defer { texture_out_file.close(); };

  // Load the FontDef.
  mem::LenientBump compiled_data_allocator;
  if (!compiled_data_allocator.init())
    return buildError(result, 
      "failed to initialize temp compiled_data_allocator");
  defer { compiled_data_allocator.deinit(); };

  auto* compiled_def = 
    reflect::CompiledData::load(input_path, &compiled_data_allocator, result);
  if (compiled_def == nullptr)
    return buildError(result, 
      "failed to load compiled data from '", input_path, "'");
  compiled_def->fixPointers();

  auto* def = compiled_def->getRootAs<FontDef>();
  if (isnil(def->asset_path))
    return buildError(result, 
      "font def '", input_path, "' does not specify a font asset"); 

  String ext = path::getLastExtension(def->asset_path);
  if (isnil(ext))
    return buildError(result, 
      "def asset path '", def->asset_path, "' has no extension");
  
  mem::BinaryDataBuilder font_data_buffer;
  if (!font_data_buffer.init(512))
    return buildError(result, "failed to initialize font_data_buffer");
  defer { font_data_buffer.deinit(); };

  mem::BinaryDataBuilder font_pixels_buffer;
  if (!font_pixels_buffer.init(512))
    return buildError(result, "failed to initialize font_pixels_buffer");
  defer { font_pixels_buffer.deinit(); };

  vec2i texture_size;
  ImageFormat texture_format;

  if (ext == "bdf"_str)
  {
    if (!compileFontBDF(
          *def, 
          &font_data_buffer, 
          &font_pixels_buffer,
          &texture_size,
          &texture_format,
          result))
      return buildError(result, 
        "failed to compile font BDF '", def->asset_path, "'");
  }
  else
  {
    return buildError(result, "unsupported font asset type '", ext, "'");
  }

  out_file.write(font_data_buffer.data);

  if (!compileTextureFromMemory(
        font_pixels_buffer.data.ptr,
        &texture_out_file,
        texture_size.x,
        texture_size.y,
        texture_format,
        result))
    return false;

  return true;
}

}
