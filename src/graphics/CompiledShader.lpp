$ require "common"

#include "iro/io/Stream.h"
#include "iro/fs/File.h"
#include "iro/fs/fs.h"
#include "iro/io/Memory.h"

#include <shaderc/shaderc.h>

@lpp.import "asset/AssetMgr.lh"
@lpp.import "reflect/CompiledData.lh"
@lpp.import "graphics/Renderer.lh"
@lpp.import "graphics/CompiledShader.lh"
@lpp.import "graphics/Shader.defs.lh"
@lpp.import "build/Result.lh"

@log.import

namespace gfx
{

/* ----------------------------------------------------------------------------
 */
template<typename... Args>
b8 buildError(build::Result* result, Args... args)
{
  if (result != nullptr)
    result->pushError(args...);
  else
    @log.error(gfx, args..., '\n');

  return false;
}

/* ----------------------------------------------------------------------------
 */
static shaderc_shader_kind shaderKindToShaderc(ShaderStage stage)
{
  switch (stage)
  {
    case ShaderStage::Vertex:   return shaderc_vertex_shader;
    case ShaderStage::Fragment: return shaderc_fragment_shader;
    case ShaderStage::Compute:  return shaderc_compute_shader;
    case ShaderStage::Geometry: return shaderc_geometry_shader;
    default: return shaderc_glsl_infer_from_source;
  }
}

/* ----------------------------------------------------------------------------
 */
b8 compileShader(const CompileShaderParams& params)
{
  using namespace fs;

  String in = params.input_path;
  String out = params.output_path;

  if (isnil(in))
    return buildError(params.result, 
      "compileShader was not given an input path");

  if (isnil(out))
    return buildError(params.result, 
      "compileShader was not given an output path");

  // Open (and lock) the destination file immediately to catch any errors 
  // with doing so early (such as the containing directory not existing).
  File data_file = File::createForTruncatedWriting(out);
  if (isnil(data_file))
    return buildError(params.result, 
      "failed to open output file '", out, "'");
  defer { data_file.close(); };

  auto failsafe_delete_datafile = deferWithCancel
  {
    fs::unlink(out);
  };

  // Load the compiled ShaderDef.
  mem::LenientBump compiled_data_allocator;
  if (!compiled_data_allocator.init())
    return buildError(params.result, 
      "failed to initialize compiled_data_allocator to load ShaderDef for " 
      "shader '", in, "'");
  defer { compiled_data_allocator.deinit(); };

  auto* compiled_def = reflect::CompiledData::load(
    in, 
    &compiled_data_allocator,
    params.result);

  if (compiled_def == nullptr)
    return buildError(params.result, 
      "failed to load compiled ShaderDef for shader '", in, "'");
  compiled_def->fixPointers();

  ShaderDef* def = compiled_def->getRootAs<ShaderDef>();
  if (isnil(def->source))
    return buildError(params.result, 
      "shader def for shader '", in, "' does not specify a source path");

  io::Memory source_buffer;
  if (!source_buffer.init())
    return buildError(params.result, 
      "failed to init memory buffer for reading shader");
  defer { source_buffer.deinit(); };

  if (!File::openAndRead(&source_buffer, def->source))
    return buildError(params.result, 
      "failed to open/read shader source file '", def->source, "'");

  shaderc_compiler_t compiler = shaderc_compiler_initialize();
  if (compiler == nullptr)
    return buildError(params.result, 
      "failed to create shader compiler");
  defer { shaderc_compiler_release(compiler); };

  shaderc_compile_options_t options = shaderc_compile_options_initialize();
  if (options == nullptr)
  {
    return buildError(params.result, 
      "failed to create shader compile options");
  }
  defer { shaderc_compile_options_release(options); };

$ if ECS_DEBUG then
  shaderc_compile_options_set_generate_debug_info(options);
$ else -- if ECS_DEBUG
  shaderc_compile_options_set_optimization_level(
    options, shaderc_optimization_level_performance);
$ end -- if ECS_DEBUG

  shaderc_compilation_result_t result = shaderc_compile_into_spv(
    compiler,
    (const char*)source_buffer.ptr, source_buffer.len,
    shaderKindToShaderc(def->stage),
    (const char*)in.ptr, "main",
    options);
  defer { shaderc_result_release(result); };

  if (   shaderc_result_get_compilation_status(result)
      != shaderc_compilation_status_success)
    return buildError(params.result, 
      shaderc_result_get_error_message(result));

  u8* spv_binary_bytes = (u8*)shaderc_result_get_bytes(result);
  u64 spv_binary_length = shaderc_result_get_length(result);

  CompiledShader data;
  data.stage = def->stage;
  data.binary.setSlice(
    (u8*)&data + sizeof(CompiledShader),
    spv_binary_length);

  data_file.write((u8*)&data, sizeof(CompiledShader));
  data_file.write(spv_binary_bytes, spv_binary_length);

  failsafe_delete_datafile.cancel();
  return true;
}

} // namespace gfx
