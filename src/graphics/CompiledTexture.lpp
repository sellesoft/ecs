$ local cmn = require "common"

#include "iro/io/IO.h"
#include "iro/fs/File.h"
#include "iro/fs/fs.h"
#include "iro/Platform.h"
#include "iro/Logger.h"

@@lpp.import "asset/AssetMgr.lh"
@@lpp.import "graphics/Renderer.lh"
@@lpp.import "graphics/CompiledTexture.lh"
@@lpp.import "graphics/DescriptorSetLayout.lh"
@@lpp.import "graphics/DescriptorSet.lh"
@@lpp.import "graphics/Texture.defs.lh"

#include "cassert"

#define STB_IMAGE_IMPLEMENTATION
#include "external/stb_image.h"

namespace gfx
{

@defFileLogger(ecs.texture, Debug)

// TODO(sushi) put somewhere common.
typedef io::StaticBuffer<512> PathBuffer;

/* ----------------------------------------------------------------------------
 */
CompiledTexture* CompiledTexture::load(
    String name,
    AssetMgr& assetmgr,
    gfx::Renderer& renderer)
{
  assert(false);
  return nullptr;
}

/* ----------------------------------------------------------------------------
 */
void CompiledTexture::unload(AssetMgr& assetmgr, Renderer& renderer)
{
  // image.destroy(renderer);
  // view.destroy(renderer);
  // sampler.destroy(renderer);
  // texture.set.destroy(renderer);
  //
  // if (asset.isValid())
  // {
  //   assetmgr.unloadAsset(asset.asset);
  //   asset.invalidate();
  // }
}

/* ----------------------------------------------------------------------------
 */
b8 CompiledTexture::compileFromMemory(void* pixels, CompileParams& params)
{
  using namespace fs;

  String in = params.input_path;
  String out = params.output_path;

  if (isnil(in))
    return ERROR(
      "CompiledTexture::compileFromMemory called with nil input path\n");

  if (isnil(out))
    return ERROR(
      "CompiledTexture::compileFromMemory called with nil output path\n");

  CompiledTextureData data;

  data.format = params.format;
  data.width  = params.width;
  data.height = params.height;

  assert(data.width != 0 && data.height != 0);

  data.pixels.set(&data + 1);

  u64 pixel_stride = 0;
  switch (data.format)
  {
    case ImageFormat::BW:   pixel_stride = 1; break;
    case ImageFormat::BWA:  pixel_stride = 2; break;
    case ImageFormat::RGB:  pixel_stride = 3; break;
    case ImageFormat::RGBA: pixel_stride = 4; break;
  }
  u64 pixels_size = pixel_stride * data.width * data.height;

  auto data_file = File::createForTruncatedWriting(out);
  if (isnil(data_file))
    return ERROR("failed to open file for writing compiled texture at '",
                 out, "'\n");

  data_file.write({(u8*)&data, sizeof(CompiledTextureData)});
  data_file.write({(u8*)pixels, pixels_size});

  data_file.close();

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 CompiledTexture::compileFromMemory(
    void* pixels,
    fs::File* file,
    CompileParams& params)
{
  CompiledTextureData data;

  data.format = params.format;
  data.width  = params.width;
  data.height = params.height;

  assert(data.width != 0 && data.height != 0);

  data.pixels.set(&data + 1);

  u64 pixel_stride = 0;
  switch (data.format)
  {
    case ImageFormat::BW:   pixel_stride = 1; break;
    case ImageFormat::BWA:  pixel_stride = 2; break;
    case ImageFormat::RGB:  pixel_stride = 3; break;
    case ImageFormat::RGBA: pixel_stride = 4; break;
  }
  u64 pixels_size = pixel_stride * data.width * data.height;

  file->write({(u8*)&data, sizeof(CompiledTextureData)});
  file->write({(u8*)pixels, pixels_size});

  return true;

}

/* ----------------------------------------------------------------------------
 */
b8 compileTexture(String data_path, String output_path)
{
  using namespace fs;

  if (isnil(data_path))
    return ERROR("compileTexture called with nil data path\n");

  if (isnil(output_path))
    return ERROR("compileTexture called with nil output path\n");

  File out_file = File::createForTruncatedWriting(output_path);
  if (isnil(out_file))
    return ERROR("failed to open file for writing compiled texture at '",
                 output_path, "'\n");
  defer { out_file.close(); };

  mem::LenientBump compiled_data_allocator;
  if (!compiled_data_allocator.init())
    return ERROR("failed to initialize temp compiled_data_allocator\n");
  defer { compiled_data_allocator.deinit(); };
  
  auto* compiled_def = CompiledData::load(data_path, &compiled_data_allocator);
  if (compiled_def == nullptr)
    return ERROR("failed to load compiled data from '", data_path, "'\n");
  compiled_def->fixPointers();

  auto* def = compiled_def->getRootAs<TextureDef>();
  if (isnil(def->name))
    return ERROR("texture def '", data_path, "' has no name\n");

  io::Memory buffer;
  if (!buffer.open())
    return ERROR("failed to initialize buffer for reading texture file\n");
  defer { buffer.close(); };
  
  if (!File::openAndRead(&buffer, def->name))
    return ERROR("failed to open/read texture ", def->name, '\n');

  int desired_channels = 0;
  switch (def->format)
  {
    case ImageFormat::BW:   desired_channels = STBI_grey;       break;
    case ImageFormat::BWA:  desired_channels = STBI_grey_alpha; break;
    case ImageFormat::RGB:  desired_channels = STBI_rgb;        break;
    case ImageFormat::RGBA: desired_channels = STBI_rgb_alpha;  break;
  }

  if (desired_channels == 0)
    return ERROR("invalid or missing texture format\n");

  int width, height, channels;
  stbi_uc* pixels = stbi_load_from_memory(
    buffer.ptr,
    buffer.len,
    &width,
    &height,
    &channels,
    desired_channels);
  defer { mem::stl_allocator.free(pixels); };

  CompiledTexture::CompileParams compile_params = 
  {
    .output_path = output_path,
    .format = def->format,
    .width = u32(width),
    .height = u32(height),
  };

  if (!CompiledTexture::compileFromMemory(pixels, &out_file, compile_params))
    return false;

  return true;
}

}
