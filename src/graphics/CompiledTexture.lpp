$ local cmn = require "common"

#include "iro/io/IO.h"
#include "iro/fs/File.h"
#include "iro/fs/fs.h"
#include "iro/Platform.h"
#include "iro/memory/Bump.h"

@@lpp.import "reflect/CompiledData.lh"
@@lpp.import "graphics/CompiledTexture.lh"
@@lpp.import "graphics/DescriptorSetLayout.lh"
@@lpp.import "graphics/DescriptorSet.lh"
@@lpp.import "graphics/Texture.defs.lh"
@@lpp.import "build/Result.lh"

#include "cassert"

#define STB_IMAGE_IMPLEMENTATION
#include "external/stb_image.h"

@log.import

$ local function log_err(...)
  $(log.error("gfx", ...))
$ end

namespace gfx
{

// TODO(sushi) put somewhere common.
typedef io::StaticBuffer<512> PathBuffer;

/* ----------------------------------------------------------------------------
 */
template<typename... Args>
b8 buildError(build::Result* result, Args... args)
{
  if (result != nullptr)
    result->pushError(args...);
  else
    @log_err(args..., '\n');

  return false;
}

/* ----------------------------------------------------------------------------
 */
b8 compileTextureFromMemory(
    String output_path,
    void* pixels, 
    u32 width,
    u32 height,
    ImageFormat format,
    build::Result* result)
{
  using namespace fs;

  if (isnil(output_path))
    return buildError(result,
      "compileTextureFromMemory called with nil output path");

  if (width == 0)
    return buildError(result, "compileTextureFromMemory passed 0 width");

  if (height == 0)
    return buildError(result, "compileTextureFromMemory passed 0 height");

  CompiledTexture data;

  data.format = format;
  data.width  = width;
  data.height = height;

  data.pixels.set(&data + 1);

  u64 pixel_stride = 0;
  switch (data.format)
  {
    case ImageFormat::BW:   pixel_stride = 1; break;
    case ImageFormat::BWA:  pixel_stride = 2; break;
    case ImageFormat::RGB:  pixel_stride = 3; break;
    case ImageFormat::RGBA: pixel_stride = 4; break;
  }
  u64 pixels_size = pixel_stride * data.width * data.height;

  auto data_file = File::createForTruncatedWriting(output_path);
  if (isnil(data_file))
    return buildError(result, 
      "failed to open file for writing compiled texture at '",
      output_path, "'");

  data_file.write({(u8*)&data, sizeof(CompiledTexture)});
  data_file.write({(u8*)pixels, pixels_size});

  data_file.close();

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 compileTextureFromMemory(
    void* pixels,
    fs::File* file,
    u32 width,
    u32 height,
    ImageFormat format,
    build::Result* result)
{
  CompiledTexture data;

  assert(file != nullptr);

  if (height == 0)
    return buildError(result, "compileTextureFromMemory passed 0 height");

  if (width == 0)
    return buildError(result, "compileTextureFromMemory passed 0 width");

  data.format = format;
  data.width  = width;
  data.height = height;

  data.pixels.set(&data + 1);

  u64 pixel_stride = 0;
  switch (data.format)
  {
    case ImageFormat::BW:   pixel_stride = 1; break;
    case ImageFormat::BWA:  pixel_stride = 2; break;
    case ImageFormat::RGB:  pixel_stride = 3; break;
    case ImageFormat::RGBA: pixel_stride = 4; break;
  }
  u64 pixels_size = pixel_stride * data.width * data.height;

  file->write({(u8*)&data, sizeof(CompiledTexture)});
  file->write({(u8*)pixels, pixels_size});

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 compileTexture(const CompileTextureParams& params)
{
  using namespace fs;

  String data_path = params.data_path;
  String output_path = params.output_path;
  build::Result* result = params.result;

  if (isnil(data_path))
    return buildError(result, "compileTexture called with nil data path");

  if (isnil(output_path))
    return buildError(result, "compileTexture called with nil output path");

  File out_file = File::createForTruncatedWriting(output_path);
  if (isnil(out_file))
    return buildError(result, 
      "failed to open file for writing compiled texture at '", 
      output_path, "'");
  defer { out_file.close(); };

  mem::LenientBump compiled_data_allocator;
  if (!compiled_data_allocator.init())
    return buildError(result, 
      "failed to initialize temp compiled_data_allocator");
  defer { compiled_data_allocator.deinit(); };
  
  auto* compiled_def = reflect::CompiledData::load(
    data_path, 
    &compiled_data_allocator,
    params.result);

  if (compiled_def == nullptr)
    return buildError(result, 
      "failed to load compiled data from '", data_path, "'");

  compiled_def->fixPointers();

  auto* def = compiled_def->getRootAs<TextureDef>();
  if (isnil(def->name))
    return buildError(result, "texture def '", data_path, "' has no name\n");

  io::Memory buffer;
  if (!buffer.open())
    return buildError(result, 
      "failed to initialize buffer for reading texture file");
  defer { buffer.close(); };
  
  if (!File::openAndRead(&buffer, def->name))
    return buildError(result, "failed to open/read texture ", def->name);

  int desired_channels = 0;
  switch (def->format)
  {
    case ImageFormat::BW:   desired_channels = STBI_grey;       break;
    case ImageFormat::BWA:  desired_channels = STBI_grey_alpha; break;
    case ImageFormat::RGB:  desired_channels = STBI_rgb;        break;
    case ImageFormat::RGBA: desired_channels = STBI_rgb_alpha;  break;
  }

  if (desired_channels == 0)
    return buildError(result, "invalid or missing texture format");

  int width, height, channels;
  stbi_uc* pixels = stbi_load_from_memory(
    buffer.ptr,
    buffer.len,
    &width,
    &height,
    &channels,
    desired_channels);
  defer { mem::stl_allocator.free(pixels); };

  if (!compileTextureFromMemory(pixels, &out_file, width, height, def->format))
    return false;

  return true;
}

}
