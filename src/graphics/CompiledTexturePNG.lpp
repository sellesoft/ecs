$ require "common"

@@lpp.import "asset/AssetMgr.lh"

@@lpp.import "graphics/Font.lh"
@@lpp.import "graphics/CompiledTexture.lh"

#include "iro/fs/File.h"
#include "iro/fs/fs.h"
#include "iro/fs/Path.h"
#include "iro/Logger.h"
#include "iro/memory/Bump.h"

#define STB_IMAGE_IMPLEMENTATION
#include "external/stb_image.h"

@log.ger(cmptexture.png, Info)

namespace gfx
{

/* ----------------------------------------------------------------------------
 */
b8 CompiledTexture::compilePNG(CompileParams& params)
{
  // We must make sure our paths are null-terminated when passing to iro.
  io::StaticBuffer<512> input_path_nullterm;
  io::format(&input_path_nullterm, params.input_path);

  String in = String(input_path_nullterm);
  String out = params.output_path;

  if (isnil(in))
    return ERROR("CompiledTexture::compilePNG called with nil input path\n");

  if (isnil(out))
    return ERROR("CompiledTexture::compilePNG called with nil output path\n");

  DEBUG("compiling png texture at '", in, "' to '", out, "'\n");

  if (!fs::path::exists(in))
    return 
      ERROR("no file '", in, "' to compile as a png texture\n");

  auto asset_file = fs::File::openForRead(in);
  if (isnil(asset_file))
    return ERROR("failed to open png texture file at '", in, "'\n");
  defer { asset_file.close(); };

  mem::LenientBump allocator;
  if (!allocator.init())
    return ERROR("failed to initialize temp allocator\n");
  defer { allocator.deinit(); };

  fs::Stat file_stat;
  if (!fs::stat(in, &file_stat))
    return ERROR("failed to stat png texture file at '", in, "'\n");

  u64 asset_file_size = file_stat.byte_size;

  auto data_file = fs::File::createForTruncatedWriting(out);
  if (isnil(data_file))
    return ERROR(
      "failed to open data file for writing at '", out, "'\n");
  defer { data_file.close(); };

  auto failsafe_delete_data_file = deferWithCancel
  {
    data_file.close();
    fs::unlink(out);
  };

  // TODO(sushi) change to BinaryDataBuilder maybe.
  io::Memory buffer;
  if (!buffer.open(asset_file_size, &allocator))
    return ERROR("failed to open buffer for reading file data\n");
  defer { buffer.close(); };

  if (asset_file_size != buffer.consume(&asset_file, asset_file_size))
    return ERROR("failed to read entire asset file\n");

  int desired_channels = 0;
  switch (params.format)
  {
    case ImageFormat::BW:   desired_channels = STBI_grey;       break;
    case ImageFormat::BWA:  desired_channels = STBI_grey_alpha; break;
    case ImageFormat::RGB:  desired_channels = STBI_rgb;        break;
    case ImageFormat::RGBA: desired_channels = STBI_rgb_alpha;  break;
  }
  assert(desired_channels != 0);

  int width, height, channels;
  stbi_uc* pixels = stbi_load_from_memory(
    buffer.ptr,
    asset_file_size,
    &width,
    &height,
    &channels,
    desired_channels);
  defer { mem::stl_allocator.free(pixels); };

  params.width = width;
  params.height = height;

  if (!CompiledTexture::compileFromMemory(pixels, &data_file, params))
    return false;
  
  failsafe_delete_data_file.cancel();
  return true;
}

}
