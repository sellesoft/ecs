$ local cmn = require "common"

#include "math.h"

#include "iro/io/IO.h"
#include "iro/fs/File.h"
#include "iro/fs/fs.h"
#include "iro/Platform.h"
#include "iro/Logger.h"
#include "iro/Scanner.h"

#include "math/util.h"

@@lpp.import "graphics/Font.lh"
@@lpp.import "graphics/Renderer.lh"

@@lpp.import "asset/AssetMgr.lh"

@defFileLogger(font, Debug)

typedef io::StaticBuffer<512> PathBuffer;

namespace gfx
{

/* ----------------------------------------------------------------------------
 */
static b8 codepointInRange(PackRange* range, u32 codepoint)
{
  return codepoint >= range->first_codepoint &&
         codepoint < range->first_codepoint + range->chars.len;
}

/* ----------------------------------------------------------------------------
 */
PackRange* Font::getRangeOfCodepoint(u32 codepoint) const
{
  const FontData& data = getData();
  const Slice<PackRange> ranges = data.ranges.getSlice();

  if (ranges.len == 1)
  {
    if (codepointInRange(ranges.ptr, codepoint))
      return ranges.ptr;
    else
      return nullptr;
  }

  for (s32 rangeidx = 0; rangeidx < ranges.len; ++rangeidx)
  {
    PackRange* range = ranges.ptr + rangeidx;
    
    if (codepointInRange(range, codepoint))
      return range;
  }

  return nullptr;
}

/* ----------------------------------------------------------------------------
 */
b8 Font::getPackedChar(PackedChar* out, u32 codepoint) const
{
  PackRange* range = getRangeOfCodepoint(codepoint);
  if (!range)
    return false;
  getPackedChar(out, range, codepoint);
  return true;
}

/* ----------------------------------------------------------------------------
 */
vec2f Font::getGlyphSize(u32 codepoint) const
{
  PackedChar pc;
  if (!getPackedChar(&pc, codepoint))
    return {};

  return vec2f(pc.x1 - pc.x0, pc.y1 - pc.y0);
}

/* ----------------------------------------------------------------------------
 */
void Font::getPackedChar(
    PackedChar* out, 
    PackRange* range, 
    u32 codepoint) const
{
  *out = *(range->chars.ptr.get() + codepoint - range->first_codepoint);
}

/* ----------------------------------------------------------------------------
 */
Font* Font::load(
    String name, 
    AssetMgr& assetmgr,
    gfx::Renderer& renderer)
{
  return nullptr;

  // using namespace fs;
  //
  // if (Font* existing = renderer.resource_mgr.findFont(name))
  //   return existing;
  //
  // PathBuffer data_path_buf;
  // writeDataPath(&data_path_buf, name, assetmgr);
  //
  // String data_path = data_path_buf.asStr();
  //
  // assert(nullptr == assetmgr.findAsset(data_path));
  //
  // if (!fs::path::exists(data_path))
  // {
  //   ERROR("attempt to load font '", name, "' but there is no data at "
  //         "path '", data_path, "'\n");
  //   return nullptr;
  // }
  //
  // Asset* asset = assetmgr.loadAssetFromDisk(data_path);
  // if (asset == nullptr)
  // {
  //   @log.error("failed to load font asset '", data_path, "'\n");
  //   return nullptr;
  // }
  //
  // // TODO(sushi) need somewhere to put these.
  // auto* font = renderer.resource_mgr.createFont(name);
  // if (font == nullptr)
  // {
  //   ERROR("failed to allocate font asset\n");
  //   return nullptr;
  // }
  //
  // font->asset.asset = asset;
  //
  // INFO("loading font's texture\n");
  //
  // // Load the texture.
  // font->texture = gfx::CompiledTexture::load(name, assetmgr, renderer);
  // if (font->texture == nullptr)
  // {
  //   ERROR("failed to load font texture\n");
  //   return nullptr;
  // }
  //
  // return font;
}

/* ----------------------------------------------------------------------------
 */
void Font::unload(AssetMgr& assetmgr, Renderer& renderer)
{
  // texture->unload(assetmgr, renderer);
  // assetmgr.unloadAsset(asset.asset);
}

/* ----------------------------------------------------------------------------
 */
static b8 compileFontBDF(
    const FontDef& def,
    io::Memory* data_buffer,
    io::Memory* pixels_buffer,
    vec2i* out_texture_size,
    ImageFormat* out_format)
{
  using namespace fs;

  String source_path = def.asset_path;

  auto file = File::openForRead(source_path);
  if (isnil(file))
    return false;
  defer { file.close(); };

  Scanner scanner = {};
  if (!scanner.init(&file))
    return ERROR("failed to initialize Scanner\n");
  defer { scanner.deinit(); };

  auto err = [&](auto... args)
  {
    ERROR(source_path, ':', scanner.line, ':', scanner.column, ": ", 
          args..., '\n');
    return false;
  };
    
  if ("STARTFONT"_str != scanner.scanIdentifier())
    return err("font does not start with STARTFONT");

  scanner.skipLine();

  enum class Section
  {
    Global,
    FontProperties,
    Chars,
    Char,
  } section = Section::Global;

  vec4i bbx = {};

  auto consumeNumber = [&](auto* x)
  {
    scanner.skipWhitespace();
    io::StaticBuffer<16> buf;

    if (0 == scanner.scanNumber(&buf))
      return err("expected a number");
    *x = atoi((char*)buf.buffer);
    return true;
  };

  // Determine the number of codepoints we want to compile.
  u32 num_codepoints = 0;
  for (auto& range : def.ranges)
    num_codepoints += range.num_codepoints;

  // Allocate the full buffer.
  u64 data_size = 
    sizeof(FontData) + 
    sizeof(PackRange) * def.ranges.len + 
    sizeof(PackedChar) * num_codepoints;

  auto* data = (FontData*)data_buffer->allocateBytes(data_size);
  data->kind = FontKind::BDF;

  auto* ranges = (PackRange*)(data + 1);
  data->ranges.setSlice(ranges, def.ranges.len);

  auto* chars = (PackedChar*)(ranges + def.ranges.len);

  u32 chars_offset = 0;
  for (s32 i = 0; i < def.ranges.len; ++i)
  {
    PackRange* out_range = ranges + i;
    const CodepointRange* in_range = &def.ranges[i];
    
    out_range->first_codepoint = in_range->first_codepoint;
    out_range->chars.setSlice(chars + chars_offset, in_range->num_codepoints);

    chars_offset += in_range->num_codepoints;
  }

  // Figure out how many codepoints we want per row.
  u64 codepoints_per_row = 
    math::roundUpToPower2(u64(sqrt((f32)num_codepoints)));

  // And how many rows.
  u64 row_count = 1 + num_codepoints / codepoints_per_row;

  u8* pixels = nullptr;
  vec2i texture_size = {};
  u32 width_aligned = 0;

  static const u32 max_bitmap_rows = 32;

  struct Char
  {
    u64   encoding;
    vec4i bbx;
    vec2i dwidth;
    u64   bitmap_rows[max_bitmap_rows];
  };

  // The current character we are parsing.
  Char curchar = {};

  // The number of characters reported by the font.
  u64 bdf_chars_count = 0;

  // Keep around the last range we wrote to to avoid looking up the same
  // range repeatedly.
  PackRange* currange = ranges;

  auto getPackedChar = [&]() -> PackedChar*
  {
    // Check if curchar is within the cached range.
    if (curchar.encoding < currange->first_codepoint ||
        curchar.encoding > currange->first_codepoint + currange->chars.len)
    {
      // Search for a range containing curchar.
      b8 found = false;
      for (PackRange& range : data->ranges.getSlice())
      {
        if (curchar.encoding > range.first_codepoint &&
            curchar.encoding < range.first_codepoint + range.chars.len)
        {
          currange = &range;
          found = true;
          break;
        }
      }
      
      if (!found)
        return nullptr;
    }

    return 
      currange->chars.ptr.get() + 
      (curchar.encoding - currange->first_codepoint);
  };

  auto getCharPixelsOffset = [&]()
  {
    u32 offset = 0;

    auto* irange = ranges;
    while (irange != currange)
    {
      offset += irange->chars.len;
      irange += 1;
    }

    offset += (curchar.encoding - currange->first_codepoint);
    
    vec2i pos;
    pos.x = offset % codepoints_per_row;
    pos.y = offset / codepoints_per_row;
    return pos.x * bbx.z + bbx.w * pos.y * texture_size.x;
  };

  for (b8 done = false; !done;)
  {
    scanner.skipWhitespace();

    if (scanner.eof())
      return err("unexpected end of file");

    String keyword = scanner.scanIdentifier();
    if (isnil(keyword))
      return err("expected a keyword");

    if ("COMMENT"_str == keyword)
    {
      scanner.skipLine();
      continue;
    }

    u64 keyword_hash = keyword.hash();

    switch (section)
    {
    case Section::Global:
      switch (keyword_hash)
      {
      case "FONTBOUNDINGBOX"_hashed:
        if (!consumeNumber(&bbx.z)) return false;
        if (!consumeNumber(&bbx.w)) return false;
        if (!consumeNumber(&bbx.x)) return false;
        if (!consumeNumber(&bbx.y)) return false;

        data->height = bbx.w;
        
        width_aligned = u64(ceil(bbx.z / 2.f) * 2.f);

        // We have enough information to setup the texture now.
        texture_size = vec2i(
          codepoints_per_row * width_aligned, row_count * bbx.w);

        data->size_x = texture_size.x;
        data->size_y = texture_size.y;

        pixels = pixels_buffer->allocateBytes(
          u64(texture_size.x) * texture_size.y);

        // Set the font height of each range (not sure if this is actually 
        // used ever).
        for (s32 i = 0; i < def.ranges.len; ++i)
          ranges[i].font_size = bbx.w;
        break;

      case "STARTPROPERTIES"_hashed:
        section = Section::FontProperties;
        scanner.skipLine();
        break;

      case "CHARS"_hashed:
        if (!consumeNumber(&bdf_chars_count))
          return false;
        section = Section::Chars;
        break;

      default:
        scanner.skipLine();
        break;
      }
      break;
    
    case Section::FontProperties:
      switch (keyword_hash)
      {
      case "FONT_ASCENT"_hashed:
        if (!consumeNumber(&data->ascent))
          return false;
        break;
      case "FONT_DESCENT"_hashed:
        if (!consumeNumber(&data->descent))
          return false;
        break;
      case "ENDPROPERTIES"_hashed:
        section = Section::Global;
        break;
      default:
        scanner.skipLine();
        break;
      }
      break;

    case Section::Chars:
      switch (keyword_hash)
      {
      case "STARTCHAR"_hashed:
        section = Section::Char;
        scanner.skipLine();
        curchar = {};
        break;

      case "ENDFONT"_hashed:
        done = true;
        break;

      default:
        if (bdf_chars_count != 0)
          return err("expected STARTCHAR (", bdf_chars_count, " remaining)");
        section = Section::Global;
        break;
      }
      break;

    case Section::Char:
      switch (keyword_hash)
      {
      case "ENCODING"_hashed:
        if (!consumeNumber(&curchar.encoding))
          return false;
        break;
      case "DWIDTH"_hashed:
        if (!consumeNumber(&curchar.dwidth.x))
          return false;
        if (!consumeNumber(&curchar.dwidth.y))
          return false;
        break;
      case "BBX"_hashed:
        if (!consumeNumber(&curchar.bbx.z)) return false;
        if (!consumeNumber(&curchar.bbx.w)) return false;
        if (!consumeNumber(&curchar.bbx.x)) return false;
        if (!consumeNumber(&curchar.bbx.y)) return false;
        assert(curchar.bbx.w < max_bitmap_rows);
        break;
      case "BITMAP"_hashed:
        scanner.skipLine();
        for (s32 row = 0; row < curchar.bbx.w; ++row)
        {
          String val = scanner.scanLine();
          curchar.bitmap_rows[row] = strtoll((char*)val.ptr, nullptr, 16);
        }
        break;
      case "ENDCHAR"_hashed:
        if (PackedChar* pchar = getPackedChar())
        {
          /*
             bbx.z (6)
      bbx.w  `------->
      (11) `  ________  
            | |      | ,-- cbbx.w (8)
            | | #    | | 
            | | #    | |
            | | #    | |
            | | #    | |
            | | #    | |
            | | #    | |
            | |      | |
            | * #    | v<-- cbbx.y (0)
            | |      |
   bbx.y -> v |______|
   (-2)       ^ ^
              bbx.x (0)
                |
                cbbx.x (2) & cbbx.z (1)
              
              top = 11 - (0 - (-2)) - 8 = 1

           */

          u32 top_offset = bbx.w - (curchar.bbx.y - bbx.y) - curchar.bbx.w;
          u32 left_offset = curchar.bbx.x - bbx.x;

          u32 pix_offset = getCharPixelsOffset();

          auto pos = 
            vec2i(pix_offset % texture_size.x, pix_offset / texture_size.x);

          pchar->x0 = pos.x;
          pchar->y0 = pos.y;
          pchar->x1 = pos.x + bbx.z;
          pchar->y1 = pos.y + bbx.w;
          pchar->xadvance = curchar.dwidth.x;
          pchar->xoff = pchar->yoff = pchar->xoff2 = pchar->yoff2 = 0.f;

          u8* tl = pixels + pix_offset;
          u8* ctl = tl + top_offset * texture_size.x + left_offset;

          for (u32 rowi = 0; rowi < curchar.bbx.w; ++rowi)
          {
            u8* row = ctl + (rowi * texture_size.x);

            for (u32 coli = 0; coli < curchar.bbx.z; ++coli)
            {
              if (curchar.bitmap_rows[rowi] & (1 << (bbx.z - coli + 1)))
                *(row + coli) = 0xff;
            }
          }
        }
        section = Section::Chars;
        bdf_chars_count -= 1;
        break;
      default:
        scanner.skipLine();
        break;
      }
      break;
    }
  }

  *out_texture_size = texture_size;
  *out_format = ImageFormat::BW;

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 compileFont(
    String input_path, 
    String output_path,
    String texture_output_path)
{
   using namespace fs;
  
  if (isnil(input_path))
    return ERROR("compileFont called with a nil input path\n");

  if (isnil(output_path))
    return ERROR("compileFont called with a nil output path\n");

  if (isnil(texture_output_path))
    return ERROR("compileFont called with a nil texture output path\n");

  // Immediately open (and thus lock) the desired output file to quickly 
  // catch any possible errors with doing so.
  File out_file = File::createForTruncatedWriting(output_path);
  if (isnil(out_file))
    return ERROR("failed to open file for writing compiled font at '",
                 output_path, "'\n");
  defer { out_file.close(); };

  // Do the same with the texture.
  File texture_out_file = File::createForTruncatedWriting(texture_output_path);
  if (isnil(texture_out_file))
    return ERROR("failed to open file for writing compiled font texture at '",
                 texture_output_path, "'\n");
  defer { texture_out_file.close(); };

  // Load the FontDef.
  mem::LenientBump compiled_data_allocator;
  if (!compiled_data_allocator.init())
    return ERROR("failed to initialize temp compiled_data_allocator\n");
  defer { compiled_data_allocator.deinit(); };

  auto* compiled_def = 
    CompiledData::load(input_path, &compiled_data_allocator);
  if (compiled_def == nullptr)
    return ERROR("failed to load compiled data from '", input_path, "'\n");
  compiled_def->fixPointers();

  auto* def = compiled_def->getRootAs<FontDef>();
  if (isnil(def->asset_path))
    return ERROR(
      "font def '", input_path, "' does not specify a font asset\n"); 

  String ext = path::getLastExtension(def->asset_path);
  if (isnil(ext))
    return ERROR("def asset path '", def->asset_path, "' has no extension\n");

  io::Memory font_data_buffer;
  if (!font_data_buffer.open())
    return ERROR("failed to open font_data_buffer\n");
  defer { font_data_buffer.close(); };

  io::Memory font_pixels_buffer;
  if (!font_pixels_buffer.open())
    return ERROR("failed to open font_pixels_buffer\n");
  defer { font_pixels_buffer.close(); };

  vec2i texture_size;
  ImageFormat texture_format;

  if (ext == "bdf"_str)
  {
    if (!compileFontBDF(
          *def, 
          &font_data_buffer, 
          &font_pixels_buffer,
          &texture_size,
          &texture_format))
      return ERROR("failed to compile font BDF '", def->asset_path, "'\n");
  }
  else
  {
    return ERROR("unsupported font asset type '", ext, "'\n");
  }

  out_file.write(font_data_buffer.asBytes());

  // Compile the texture to our format.
  gfx::CompiledTexture::CompileParams texture_params = 
  {
    .width = u32(texture_size.x),
    .height = u32(texture_size.y),
    .format = texture_format,
  };

  if (!CompiledTexture::compileFromMemory(
        font_pixels_buffer.ptr, &texture_out_file, texture_params))
    return ERROR(
      "failed to compile font texture '", def->asset_path, "'\n");

  return true;
}

}
