/*
 *  For drawing things to the screen.
 */

$ require "common"

#include "iro/Common.h"
#include "iro/containers/Array.h"
#include "iro/containers/StackArray.h"
#include "iro/Unicode.h"
#include "math/mat.h"
#include "math/vec.h"
#include "math/Rect.h"

@lpp.import "graphics/DescriptorSetLayout.lh"
@lpp.import "graphics/ResourceMgr.lh"
@lpp.import "graphics/TextureHandle.lh"

using namespace iro;

struct Client;
struct WindowResized;
struct Window;
struct PostReload;
struct Color;

namespace gfx
{

struct RenderTarget;
struct Pipeline;
struct Vulkan;

/* ============================================================================
 *  TODO(sushi) remove ownership of Vulkan from this. We should probably also
 *              just rework this to be an interface to emitting render 
 *              commands to Vulkan, where it can just be created on the 
 *              stack and used temporarily.
 */
struct Renderer
{
  mem::Allocator* allocator;
  
  // TODO(sushi) does this need to be here? it can probably just be stored
  //             on Vulkan.
  u32 next_image;

  struct InitParams
  {
    Window& window;
    mem::Allocator& allocator;
  };

  b8 init(InitParams& params);
  void deinit(mem::Allocator* allocator);

  void waitForDeviceIdle();

  b8 beginFrame();
  void endFrame(); 

  // Attempts to retrieve a RenderTarget representing the currently acquired 
  // swapchain image. Anything performing a 'final' render should pass this 
  // as its target. Fails if not currently in a frame.
  // TODO(sushi) rework all of this to store the data for rendering in
  //             a different object so we don't have to pass around 
  //             RenderTargets and can just pass that around instead. 
  //             RenderTarget stores more information than we need for this 
  //             case, and should probably be reworked into that object 
  //             storing more opaque information or something.
  b8 getSwapchainRenderTarget(RenderTarget* out);

  b8 beginRenderPass(
    vec2i render_area_pos,
    vec2u render_area_size,
    RenderTarget& target,
    Color clear_color);

  void endRenderPass();

  b8 submitQueue();
  b8 present();

  void setScissor(vec2i pos, vec2u size);
  void setViewport(vec2f pos, vec2f size);
  void bindPipeline(Pipeline pipeline);
  void bindDescriptorSet(u32 set_idx, DescriptorSet set);
  void bindVertexBuffer(Buffer buffer);
  void bindIndexBuffer(Buffer buffer);
  void bindUniformBuffer(Buffer buffer);

  void bindTexture(TextureHandle texture)
  {
    bindDescriptorSet(1, texture.set);
  }

  void pushConstant(
    void* data, 
    u32 size, 
    u32 offset,
    ShaderStage stage);

  void draw(u32 index_start, u32 index_count, u32 vertex_start);

  // NOTE(sushi) a hacky way to get an image into a state where it can be 
  //             sampled by a shader, for use when wanting to display a 
  //             RenderTarget image. Needs to be done better later.
  void prepareImageForSampling(Image image);

  void debugBeginLabel(Color color, utf8::String label);
  void debugEndLabel();
  void debugInsertLabel(Color color, utf8::String label);

  void onWindowResized(vec2u size);

  // NOTE(sushi) explicitly deleting the copy constructor of Renderer
  //             to prevent accidental copies since operating on a copy
  //             of it has potential to cause really really awesome bugs
  //             that are hard to find.
  Renderer() {}
  Renderer(const Renderer& rhs) = delete;
  Renderer operator=(const Renderer& rhs) = delete;

  Vulkan* vk;

private:
  b8 updateSwapchain(vec2i viewport_size);
};

}
