/*
 *  A manager for GPU resources that originate from assets.
 */

$ require "common"

#include "iro/containers/AVL.h"
#include "iro/containers/Array.h"
#include "iro/Unicode.h"

@@lpp.import "graphics/Texture.resource.lh"
@@lpp.import "graphics/Shader.resource.lh"
@@lpp.import "graphics/Font.resource.lh"
@@lpp.import "graphics/Pipeline.resource.lh"

using namespace iro;

namespace gfx
{

struct Vulkan;

/* ============================================================================
 */
struct ResourceMgr
{
  template<typename T>
  struct Resource
  {
    String name = nil;
    T  resource;
    b8 is_loaded = false;

    struct ContainedAsset
    {
      String name; 
      String type;
    };

    iro::Array<ContainedAsset> contained_assets;

    static u64 getAVLKey(const Resource<T>& x) { return x.name.hash(); }

    static Resource<T>* fromResource(T* x)
    {
      return (Resource<T>*)((u8*)x - offsetof(Resource<T>, resource));
    }
  };

  // TODO(sushi) we can manage the memory of these better.
  //             Should prob just use indexed pools or something.
  //             Just doesn't need to be so dynamic, nor use 2 pools 
  //             as this currently does.
  template<typename T>
  struct ResourcePool
  {
    AVL<Resource<T>> map;
    Pool<Resource<T>> pool;

    b8 init()
    {
      if (!map.init())
        return false;

      if (!pool.init())
        return false;
    
      return true;
    }

    void deinit()
    {
      map.deinit();
      pool.deinit();
    }

    Resource<T>* find(String name) { return map.find(name.hash()); }

    Resource<T>* create(String name)
    {
      Resource<T>* r = pool.add();

      r->name = name.allocateCopy();
      r->contained_assets.init();
      map.insert(r);

      return r;
    }
  };

  ResourcePool<TextureResource> textures;
  ResourcePool<ShaderResource> shaders;
  ResourcePool<FontResource> fonts;
  ResourcePool<PipelineResource> pipelines;

  b8 init(Vulkan* vk);
  void deinit();

  // Gets a resource if it already exists, or creates a new (uninitialized)
  // resource.
  TextureResource*  getOrCreateTextureResource(String name);
  // TODO(sushi) I don't think there's any reason to have these as a resource
  //             anymore since reloading them isnt possible w/o reloading the 
  //             entire pipeline.
  ShaderResource*   getOrCreateShaderResource(String name);
  FontResource*     getOrCreateFontResource(String name);
  PipelineResource* getOrCreatePipelineResource(String name);

  // Loads the given resource onto the GPU and such, or does nothing if its 
  // already loaded.
  b8 loadTextureResource(TextureResource* texture);
  b8 loadShaderResource(ShaderResource* shader);
  b8 loadFontResource(FontResource* font);
  b8 loadPipelineResource(PipelineResource* pipeline);

  void unloadTextureResource(TextureResource* texture);
  void unloadShaderResource(ShaderResource* shader);
  void unloadFontResource(FontResource* font);
  void unloadPipelineResource(PipelineResource* pipeline);

  void notifyAssetChanged(String name, String type);

  // TODO(sushi) it is a bit weird to store Vulkan like this, but I would 
  //             prefer to avoid needing gfx::Renderer to properly load 
  //             resources. For now, it's whatever, since Vulkan is the only
  //             backend we support, and I don't want to introduce an opaque
  //             backend type that I have to constantly cast when there's no 
  //             reason to yet.
  Vulkan* vk;
};

}
