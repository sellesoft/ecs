/*
 *  A manager for GPU resources that originate from assets.
 */

$ require "common"

#include "iro/containers/AVL.h"
#include "iro/Unicode.h"

@@lpp.import "graphics/TextureResource.lh"
@@lpp.import "graphics/ShaderResource.lh"
@@lpp.import "graphics/FontResource.lh"

using namespace iro;

namespace gfx
{

struct Vulkan;

/* ============================================================================
 */
struct ResourceMgr
{
  template<typename T>
  struct Resource
  {
    String name;
    T  resource;

    static u64 getAVLKey(const Resource<T>& x) { return x.name.hash(); }
  };

  // TODO(sushi) use indexed pools once vulkan is merged
  //             well vulkan is merged now sooo.
  template<typename T>
  using ResourceMap = AVL<Resource<T>>;

  ResourceMap<TextureResource> textures;
  ResourceMap<ShaderResource> shaders;
  ResourceMap<FontResource> fonts;

  b8 init();
  void deinit();

  template<typename T>
  b8 loadLink(TypedResourceLink<T>* link, AssetMgr& asset_mgr);

  // TODO(sushi) it is a bit weird to store Vulkan like this, but I would 
  //             prefer to avoid needing gfx::Renderer to properly load 
  //             resources. For now, it's whatever, since Vulkan is the only
  //             backend we support, and I don't want to introduce an opaque
  //             backend type that I have to constantly cast when there's no 
  //             reason to yet.
  Vulkan* vk;
};

}
