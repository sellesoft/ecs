$ require "common"

@@lpp.import "graphics/ResourceMgr.lh"
@@lpp.import "graphics/Vulkan.lh"
@@lpp.import "graphics/DescriptorSetLayout.lh"

#include "iro/Logger.h"

namespace gfx
{

@log.ger(gfx.rsrcmgr, Debug)

/* ----------------------------------------------------------------------------
 */
b8 ResourceMgr::init(Vulkan* vk)
{
  this->vk = vk;

  if (!textures.init())
    return false;

  if (!shaders.init())
    return false;

  if (!fonts.init())
    return false;

  if (!pipelines.init())
    return false;

  return true;
}

/* ----------------------------------------------------------------------------
 */
void ResourceMgr::deinit()
{
  textures.deinit();
  shaders.deinit();
  fonts.deinit();
  pipelines.deinit();
}

/* ----------------------------------------------------------------------------
 */
TextureResource* ResourceMgr::getOrCreateTextureResource(String name)
{
  auto* r = textures.find(name);

  if (r == nullptr)
    r = textures.create(name);

  return &r->resource;
}

/* ----------------------------------------------------------------------------
 */
ShaderResource* ResourceMgr::getOrCreateShaderResource(String name)
{
  auto* r = shaders.find(name);

  if (r == nullptr)
    r = shaders.create(name);

  return &r->resource;
}

/* ----------------------------------------------------------------------------
 */
FontResource* ResourceMgr::getOrCreateFontResource(String name)
{
  auto* r = fonts.find(name);

  if (r == nullptr)
    r = fonts.create(name);

  return &r->resource;
}

/* ----------------------------------------------------------------------------
 */
PipelineResource* ResourceMgr::getOrCreatePipelineResource(String name)
{
  auto* r = pipelines.find(name);

  if (r == nullptr)
    r = pipelines.create(name);

  return &r->resource;
}

/* ----------------------------------------------------------------------------
 */
b8 ResourceMgr::loadTextureResource(TextureResource* texture)
{
  auto* r = Resource<TextureResource>::fromResource(texture);

  if (r->is_loaded)
  {
    r->contained_assets.clear();
    unloadTextureResource(texture);
  }

  r->contained_assets.push(
    {texture->compiled_texture.name, "texture.compiled"_str});

  const CompiledTexture& compiled = texture->compiled_texture.get();
  
  texture->image = Image::create(*vk,
  {
    .usage = ImageUsage::Sampled,
    .format = compiled.format,
    .pixels = compiled.pixels.get(),
    .size = vec2u(compiled.width, compiled.height),
    .debug_name = r->name,
  });

  if (isnil(texture->image))
    return false;

  texture->view = ImageView::create(*vk,
  {
    .image = texture->image,
    .format = compiled.format,
    .debug_name = r->name,
  });

  if (isnil(texture->view))
    return false;

  // TODO(sushi) need a way to make these parameterized again. I removed 
  //             them from CompiledTexture because I didn't think it made
  //             sense to compile that in, but realizing now we don't have 
  //             the TextureDef here. Not sure how to get at that nicely 
  //             with all this stuff being so automated....
  texture->sampler = Sampler::create(*vk,
  {
    .filter = ImageFilter::Nearest,
    .address_mode = ImageAddressMode::ClampToBlack,
    .debug_name = r->name,
  });

  if (isnil(texture->sampler))
    return false;

  texture->descriptor_set = DescriptorSet::create(
    *vk,
    DescriptorSetLayout{vk->default_sampler_set_layout},
    r->name);

  if (isnil(texture->descriptor_set))
    return false;

  ImageDescriptor descriptor = 
  {
    .view = texture->view,
    .sampler = texture->sampler,
  };

  texture->descriptor_set.update(
    *vk,
    0,
    0,
    makeSlice(&descriptor, 1));

  r->is_loaded = true;
  return true;
}

/* ----------------------------------------------------------------------------
 */
void ResourceMgr::unloadTextureResource(TextureResource* texture)
{
  texture->image.destroy(*vk);
  texture->view.destroy(*vk);
  texture->sampler.destroy(*vk);
  texture->descriptor_set.destroy(*vk);
}

/* ----------------------------------------------------------------------------
 */
b8 ResourceMgr::loadShaderResource(ShaderResource* shader)
{
  auto* r = Resource<ShaderResource>::fromResource(shader);
  if (r->is_loaded)
  {
    r->contained_assets.clear();
    unloadShaderResource(shader);
  }

  r->contained_assets.push(
    {shader->compiled_shader.name, "shader.compiled"_str});

  const CompiledShader& compiled = shader->compiled_shader.get();

  shader->handle = Shader::create(*vk,
  {
    .stage = compiled.stage,
    .spv_binary = compiled.binary.getSlice(),
    .debug_name = r->name,
  });

  if (isnil(shader->handle))
    return false;

  r->is_loaded = true;
  return true;
}

/* ----------------------------------------------------------------------------
 */
void ResourceMgr::unloadShaderResource(ShaderResource* shader)
{
  shader->handle.destroy(*vk);
}

/* ----------------------------------------------------------------------------
 */
b8 ResourceMgr::loadFontResource(FontResource* font)
{
  auto* r = Resource<FontResource>::fromResource(font);
  if (r->is_loaded)
  {
    r->contained_assets.clear();
    unloadFontResource(font);
  }

  r->contained_assets.push({font->compiled_font.name, "font.compiled"_str});
  r->contained_assets.push(
    {font->compiled_texture.name, "font.texture.compiled"_str});

  const CompiledTexture& compiled = font->compiled_texture.get();
  
  font->image = Image::create(*vk,
  {
    .usage = ImageUsage::Sampled,
    .format = compiled.format,
    .pixels = compiled.pixels.get(),
    .size = vec2u(compiled.width, compiled.height),
    .debug_name = r->name,
  });

  if (isnil(font->image))
    return false;

  font->view = ImageView::create(*vk,
  {
    .image = font->image,
    .format = compiled.format,
    .debug_name = r->name,
  });

  if (isnil(font->view))
    return false;

  // TODO(sushi) need a way to make these parameterized again. I removed 
  //             them from CompiledTexture because I didn't think it made
  //             sense to compile that in, but realizing now we don't have 
  //             the TextureDef here. Not sure how to get at that nicely 
  //             with all this stuff being so automated....
  font->sampler = Sampler::create(*vk,
  {
    .filter = ImageFilter::Nearest,
    .address_mode = ImageAddressMode::ClampToBlack,
    .debug_name = r->name,
  });

  if (isnil(font->sampler))
    return false;

  font->descriptor_set = DescriptorSet::create(
    *vk,
    DescriptorSetLayout{vk->default_sampler_set_layout},
    r->name);

  if (isnil(font->descriptor_set))
    return false;

  ImageDescriptor descriptor = 
  {
    .view = font->view,
    .sampler = font->sampler,
  };

  font->descriptor_set.update(
    *vk,
    0,
    0,
    makeSlice(&descriptor, 1));

  r->is_loaded = true;
  return true;
}

/* ----------------------------------------------------------------------------
 */
void ResourceMgr::unloadFontResource(FontResource* font)
{
  font->descriptor_set.destroy(*vk);
  font->view.destroy(*vk);
  font->sampler.destroy(*vk);
  font->image.destroy(*vk);
}

/* ----------------------------------------------------------------------------
 */
b8 ResourceMgr::loadPipelineResource(PipelineResource* pipeline)
{
  auto* r = Resource<PipelineResource>::fromResource(pipeline);
  if (r->is_loaded)
  {
    r->contained_assets.clear();
    unloadPipelineResource(pipeline);
  }

  const PipelineDef& def = *pipeline->data;

  r->contained_assets.push({
    pipeline->data.name, "pipeline.data"_str});

  r->contained_assets.push(
    {def.vertex_shader->compiled_shader.name.allocateCopy(), 
    "shader.compiled"_str});

  r->contained_assets.push(
    {def.fragment_shader->compiled_shader.name.allocateCopy(), 
    "shader.compiled"_str});

  pipeline->handle = gfx::Pipeline::create(*vk, def);
  if (isnil(pipeline->handle))
    return false;

  r->is_loaded = true;
  return true;
}

/* ----------------------------------------------------------------------------
 */
void ResourceMgr::unloadPipelineResource(PipelineResource* pipeline)
{
  pipeline->handle.destroy(*vk);
}

/* ----------------------------------------------------------------------------
 */
void ResourceMgr::notifyAssetChanged(String name, String type)
{
  // NOTE(sushi) the way this is done is very bad, I'm just lazy.
  //             All this is doing is searching all loaded resources for if
  //             they 'contain' an asset matching the given name and type
  //             and reloads it if so. This information needs stored better 
  //             so we can actually look these up quickly and only deal with
  //             what actually deals with a given asset. Or it should be done
  //             a completely different way, idk.

  for (auto& texture : textures.map)
  {
    for (auto& contained : texture.contained_assets)
    {
      if (contained.name == name && contained.type == type)
      {
        INFO("reloading ", texture.name, " because it contains ", 
             name, '.', type, '\n');
        loadTextureResource(&texture.resource);
      }
    }
  }

  for (auto& shader : shaders.map)
  {
    for (auto& contained : shader.contained_assets)
    {
      if (contained.name == name && contained.type == type)
      {
        INFO("reloading ", shader.name, " because it contains ", 
             name, '.', type, '\n');
        loadShaderResource(&shader.resource);
      }
    }
  }

  for (auto& font : fonts.map)
  {
    for (auto& contained : font.contained_assets)
    {
      if (contained.name == name && contained.type == type)
      {
        INFO("reloading ", font.name, " because it contains ", 
             name, '.', type, '\n');
        loadFontResource(&font.resource);
      }
    }
  }

  for (auto& pipeline : pipelines.map)
  {
    INFO(pipeline.name, '\n');
    for (auto& contained : pipeline.contained_assets)
    {
      INFO(contained.name, ' ', contained.type, "\n");

      if (contained.name == name && contained.type == type)
      {
        INFO("reloading ", pipeline.name, " because it contains ", 
             name, '.', type, '\n');
        loadPipelineResource(&pipeline.resource);
      }
    }
  }
}

}
