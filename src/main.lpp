$ local cmn = require "common"

#include "iro/time/Time.h"
#include "iro/fs/fs.h"
#include "iro/fs/File.h"
#include "iro/io/Memory.h"
#include "iro/print.h"
#include "iro/sort.h"

$ if ECS_HOT_RELOAD then
#include "iro/os/Process.h"
$ end

@lpp.import "Engine.lh"

$ if IRO_LINUX then
#include "iro/GDBScriptDef.h"
$ end

#if ECS_HOT_RELOAD
#include "hreload/hreload.h"
#include "dlfcn.h"
#endif

@log.import

@lpp.import "Profiling.lh"

#include "iro/containers/BitArray.h"

/* ----------------------------------------------------------------------------
 */
void doReload(hr::Reloader* r)
{
#if ECS_HOT_RELOAD
  @log.info(main, "want hr\n");
  
  io::SmallBuffer<32> patchnumbuf;
  io::format(&patchnumbuf, hr::getPatchNumber(r));

  String args[] = 
  {
    "patch"_str,
    String(patchnumbuf),
  };

  auto lake = os::Process::spawn(
  {
    .file = "lake"_str,
    .args = makeSlice(args),
    .cwd = nil,
    .non_blocking = false,
    .redirect_err_to_out = true,
    .pty = false,
  });

  if (isnil(lake))
  {
    @log.error(main, "failed to spawn lake\n");
    return;
  }

  while (!lake.closed || lake.hasOutput())
  {
    if (lake.hasOutput())
    {
      io::StaticBuffer<512> output_buffer;
      output_buffer.len = lake.read(output_buffer.asBytesBuffer());
      print(String(output_buffer));
    }
    lake.hasExited();
  }

  io::StaticBuffer<512> patch_path;
  io::formatv(&patch_path, "_build/ecs_patch", hr::getPatchNumber(r));

  println(String(patch_path));

  hr::reload(r, String(patch_path));
#endif
}

/* ----------------------------------------------------------------------------
 */
int main(int argc, const char** args)
{

$ if ECS_WAIT_FOR_TRACY_CONNECTION then
  while (!TracyIsConnected)
    platform::sleep(TimeSpan::fromMilliseconds(1));
$ end

  LaunchArgs launch_args = {};
  if (argc > 1)
  {
    launch_args.init();
    for (int i = 1; i < argc; i++)
    {
      String key = iro::String::fromCStr(args[i]);
      if (!key.startsWith('-'))
        continue;

      LaunchArg arg = { .key = key.hash() };
      if (i + 1 < argc && args[i+1][0] != '-')
      {
        arg.value = iro::String::fromCStr(args[i+1]);
        i++;
      }
      else
      {
        launch_args.insert(&arg);
      }
    }
  }

#if ECS_HOT_RELOAD
  void* dlhandle = dlopen(nullptr, RTLD_LAZY);

  hr::Reloader* reloader = hr::createReloader(
    dlhandle, String::fromCStr(args[0]));

  io::StackMemory filter;
  fs::File::openAndRead(&filter, "_build/ecs.hrf"_str);

  hr::setReloaderFilter(reloader, String(filter));
#endif

  Engine engine = { .launch_args = launch_args };
  if (!engine.init())
    return @log.fatal(main, "failed to initialize Engine\n");

  auto program_start_time = TimePoint::now();

  for (;;)
  {
#if ECS_HOT_RELOAD
    // TODO(sushi) call back into the Engine telling it if the reload was
    //             successful or not.
    if (engine.wantHotReload())
      doReload(reloader);
#endif
    Engine::UpdateResult engine_result = engine.update();

    if (engine_result.should_close)
      break;
  }

  engine.deinit();

  return 0;
}
