$ local cmn = require "common"
$ local minfo = require "math.info"

#include "iro/Common.h"
#include "iro/io/format.h"

@lpp.import "math/basic.lh"

$ -- See math/info.lua for the definition of what vec types we generate.
$ local vec_types = minfo.vec_types

$ local comps = cmn.List { "x", "y", "z", "w" }

$ -- NOTE(sushi) only support up to vec4 for now as I don't believe we
$ --             will ever have a reason to support more.
$ local function makeVec(name, t, n)
$   n = tonumber(n)
$   local function eachComp(f)
$     for i=1,n do
$       f(comps[i], i == n, i)
$     end
$   end
$   local these_comps = comps:sub(1, n)
/* ============================================================================
 */
struct $(name)
{
  // Alias typenames in C++ to make writing it easier than \$(name).
  using S = $(name);
  using T = $(t);

$ eachComp(function(comp)
  T $(comp) = 0;
$ end)

  $(name)() = default;

  $(name)(T v)
  {
$ eachComp(function(comp)
    this->$(comp) = v;
$ end)
  }

  $(name)($(cmn.joinp(",", "T %", these_comps)))
  {
$ eachComp(function(comp)
    this->$(comp) = $(comp);
$ end)
  }

$ for vt in vec_types:each() do
$   if vt.len == n and vt.t ~= t then
  explicit operator $(vt.name)() const;
$   end
$ end

$ -- TODO(sushi) we could also generate constructors that take smaller vec
$ --             types + a scalar at each position like what you can do in 
$ --             glsl but I think all the swizzling is already a bit much,
$ --             so won't worry about it for now.

  /* --------------------------------------------------------------------------
   */
  b8 isZero(this const S self)
  {
    return $(cmn.joinp("&&", "self.% == 0", comps:sub(1,n)));
  }

$ local function binop(op)
  /* --------------------------------------------------------------------------
   */
  S operator $(op) (this const S lhs, S rhs)
  {
    S result;
$   eachComp(function(comp)
    result.$(comp) = lhs.$(comp) $(op) rhs.$(comp);
$   end)
    return result;
  }

  /* --------------------------------------------------------------------------
   */
  void operator $(op)=(S rhs)
  {
    *this = *this $(op) rhs;
  }
$ end

  @binop "+"
  @binop "-"
  @binop "*"
  @binop "/"

  /* --------------------------------------------------------------------------
   */
  S operator / (this const S self, T rhs)
  {
    S result;
$ eachComp(function(comp)
    result.$(comp) = self.$(comp) / rhs;
$ end)
    return result;
  }

  friend S operator * (T lhs, S rhs);

  /* --------------------------------------------------------------------------
   */
  S operator - (this const S self)
  {
    S result;
$ eachComp(function(comp)
    result.$(comp) = -self.$(comp);
$ end)
    return result;
  }

$ local set_args = cmn.buffer.new()
$ eachComp(function(comp, is_last)
$   set_args:put("T "..comp)
$   if not is_last then
$     set_args:put ","
$   end
$ end)

  /* --------------------------------------------------------------------------
   */
  S& set(this S& self, $(set_args))
  {
$ eachComp(function(comp)
    self.$(comp) = $(comp);
$ end)
    return self;
  }

$ eachComp(function(comp)
  /* --------------------------------------------------------------------------
   */
  S& set$(comp)(this S& self, T v)
  {
    self.$(comp) = v;
    return self;
  }
$ end)

  /* --------------------------------------------------------------------------
   */
  T dot(this const S self, S rhs)
  {
    T r = 0;
$ eachComp(function(comp)
    r += self.$(comp) * rhs.$(comp);
$ end)
    return r;
  }

$ if n == 2 then
  /* --------------------------------------------------------------------------
   */
  S perp(this const S self)
  {
    return { -self.y, self.x };
  }
$ end

  /* --------------------------------------------------------------------------
   */
  T magSq(this const S self)
  {
    T result = 0;
$ eachComp(function(comp)
    result += self.$(comp) * self.$(comp);
$ end)
    return result;
  }

  /* --------------------------------------------------------------------------
   */
  T mag(this const S self)
  {
    return math::sqrt(self.magSq());
  }

  /* --------------------------------------------------------------------------
   */
  S normalized(this const S self)
  {
$ local non_zero_check = cmn.buffer.new()
$ eachComp(function(comp, is_last)
$   non_zero_check:put("self.",comp, " != 0 ")
$   if not is_last then
$     non_zero_check:put("||")
$   end
$ end)
    if ($(non_zero_check))
      return self / self.mag();
    else
      return self;
  }

  /* --------------------------------------------------------------------------
   */
  S& normalize(this S& self)
  {
    self = self.normalized();
    return self;
  }

  /* --------------------------------------------------------------------------
  */
  S clampedMag(this const S self, T min, T max)
  {
    T m = self.mag();
    if (m < min || m > max)
      return m * self.normalized();
    return self;
  }

  /* --------------------------------------------------------------------------
   */
  S& clampMag(this S& self, T min, T max)
  {
    self = self.clampedMag(min, max);
    return self;
  }

$ eachComp(function(comp)
  /* --------------------------------------------------------------------------
   */
  S $(comp)add(this const S self, T v)
  {
    S r = self;
    r.$(comp) += v;
    return r;
  }

  /* --------------------------------------------------------------------------
   */
  S $(comp)neg(this const S self)
  {
    S r = self;
    r.$(comp) = -r.$(comp);
    return r;
  }
$ end)

$ -- Generate swizzling functions via a cartesian product of this vec's 
$ -- components.
$ -- Definitely not necessary but its neat.

$ local function cartesianRecur(f, clist, depth, limit)
$   if depth ~= limit then
$     eachComp(function(comp)
$       clist[depth + 1] = comp
$       cartesianRecur(f, clist, depth + 1, limit)
$     end)
$   else
$     f(clist)
$   end
$ end

$ -- Wrap swizzler definitions in a macro to help the files not becoming 
$ -- TOO long.
$ local function swizzlerMacro(n)
$   local result_t
$   for vt in vec_types:each() do
$     if vt.t == t and vt.len == n then
$       result_t = vt.name
$     end
$   end
$   if not result_t then
$     return false
$   end
$   local scomps = these_comps:sub(1, n)
#define swizzler($(cmn.join(",", scomps))) \
  $(result_t) $(cmn.join("##", scomps))(this S self) \
  { return {$(cmn.joinp(",", "self.%", scomps))}; }
$   return true
$ end

$ local function cartesian(f)
$   for i=2,n do
$     if swizzlerMacro(i) then
$       cartesianRecur(f, cmn.List {}, 0, i)
#undef swizzler
$     end
$   end
$ end

$ cartesian(function(list)
  swizzler($(cmn.join(",", list)));
$ end)
  
};

/* ----------------------------------------------------------------------------
 */
inline $(name) operator * ($(t) lhs, $(name) rhs)
{
  $(name) r;
$ eachComp(function(comp)
  r.$(comp) = lhs * rhs.$(comp);
$ end)
  return r;
}

$ if t == "f32" then
/* ----------------------------------------------------------------------------
 */
static inline $(name) floor($(name) v)
{
  return $(name)($(cmn.joinp(",", "math::floor(v.%)", these_comps)));
}

/* ----------------------------------------------------------------------------
 */
static inline $(name) round($(name) v)
{
  return $(name)($(cmn.joinp(",", "math::round(v.%)", these_comps)));
}
$ end

namespace iro::io
{
static s64 format(WStream* out, $(name) v)
{
  return io::formatv(out,
    '(',
$ eachComp(function(comp, is_last)
    v.$(comp),
$   if not is_last then
    ',',
$   end
$ end)
    ')');
}
}

$ end

$ -- Forward declare types so that we can declare methods that use other 
$ -- vec types.
$ for type in vec_types:each() do
struct $(type.name);
$ end

$ -- Define the actual vector types.
$ for type in vec_types:each() do
$   makeVec(type.name, type.t, type.len)
$ end

$ -- Generate the explicit conversion operators between vectors of equal
$ -- size.
$ for t1 in vec_types:each() do
$   for t2 in vec_types:each() do
$     if t1.len == t2.len and t1.t ~= t2.t then
inline $(t1.name)::operator $(t2.name) () const
{
  return $(t2.name)($(cmn.join(",", comps:sub(1,t1.len))));
}
$     end
$   end
$ end
