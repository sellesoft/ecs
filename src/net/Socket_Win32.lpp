$ require "common"

$ if IRO_WIN32 then

#define WIN32_LEAN_AND_MEAN
#include <Winsock2.h>
#include <Ws2ipdef.h>
#include "iro/os/Helpers_Win32.h"

@lpp.import "net/Socket.lh"
@lpp.import "net/Address.lh"
@log.import

$ local function log_dbg(...) return log.debug("net", ...) end
$ local function log_err(...) return log.error("net", ...) end

namespace net
{

typedef int socklen_t;

static int s_ipv6_socket = 0;
static b8  s_ipv6_socket_bound = false;

/* ----------------------------------------------------------------------------
 */
b8 isSocketOpen()
{
  return s_ipv6_socket != 0;
}

/* ----------------------------------------------------------------------------
 */
b8 isSocketBound()
{
  return s_ipv6_socket_bound;
}

/* ----------------------------------------------------------------------------
 */
b8 openSocket()
{
  assert(not isSocketOpen());
  assert(not isSocketBound());

  @log_dbg("opening ipv6 socket\n");

  WSADATA wsa_data;
  if (NO_ERROR != WSAStartup(MAKEWORD(2, 2), &wsa_data))
    return @log_err("failed to initialize winsock: ",
                    iro::Win32ErrMsg(WSAGetLastError()), '\n');

  // Create the socket.
  s_ipv6_socket = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
  if (INVALID_SOCKET == s_ipv6_socket)
    return @log_err("failed to open ipv6 socket: ",
                    iro::Win32ErrMsg(WSAGetLastError()), '\n');
  @log_dbg("opened ipv6 socket (", s_ipv6_socket, ")\n");

  auto failsafe_close_socket = deferWithCancel
  {
    closesocket(s_ipv6_socket);
  };

  // Set socket to non-blocking.
  u_long non_blocking = true;
  if (SOCKET_ERROR == ioctlsocket(s_ipv6_socket, FIONBIO, &non_blocking))
    return @log_err("failed to set ipv6 socket to non-blocking: ",
                    iro::Win32ErrMsg(WSAGetLastError()), '\n');
  @log_dbg("set ipv6 socket to non-blocking\n");

  // Set socket options.
  {
    int optval;

    // Enable broadcast capability.
    optval = 1;
    if (SOCKET_ERROR == setsockopt(s_ipv6_socket, SOL_SOCKET, SO_BROADCAST,
                                   (char*)&optval, sizeof(optval)))
      return @log_err("failed to set ipv6 socket to broadcast capable: ",
                      iro::Win32ErrMsg(WSAGetLastError()), '\n');
    @log_dbg("enabled broadcast capability\n");

    // Disable ipv6-only mode to allow ipv4 connections.
    optval = 0;
    if (SOCKET_ERROR == setsockopt(s_ipv6_socket, IPPROTO_IPV6, IPV6_V6ONLY,
                                   (char*)&optval, sizeof(optval)))
      return @log_err("failed to set ipv6 socket to disable ipv6-only mode: ",
                      iro::Win32ErrMsg(WSAGetLastError()), '\n');
    @log_dbg("disabled ipv6-only mode\n");
  }
  @log_dbg("finished setting socket options\n");

  failsafe_close_socket.cancel();
  return true;
}

/* ----------------------------------------------------------------------------
 */
void closeSocket()
{
  assert(isSocketOpen());

  @log_dbg("closing ipv6 socket\n");

  closesocket(s_ipv6_socket);
  WSACleanup();

  s_ipv6_socket = 0;
}

/* ----------------------------------------------------------------------------
 */
b8 bindSocket(u16 port)
{
  assert(isSocketOpen());
  assert(not isSocketBound());

  @log_dbg("binding ipv6 socket to port ", port, '\n');

  sockaddr_in6 ipv6_socket_address;
  memset(&ipv6_socket_address, 0, sizeof(ipv6_socket_address));
  ipv6_socket_address.sin6_family = AF_INET6;
  ipv6_socket_address.sin6_port = htons(port);
  ipv6_socket_address.sin6_addr = in6addr_any;

  if (SOCKET_ERROR == bind(s_ipv6_socket, (sockaddr*)&ipv6_socket_address,
                           sizeof(ipv6_socket_address)))
    return @log_err("failed to bind ipv6 socket to port ", port, ": ",
                    iro::Win32ErrMsg(WSAGetLastError()), '\n');

  @log_dbg("bound ipv6 socket to port ", port, '\n');
  s_ipv6_socket_bound = true;
  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 sendPacket(const Address& address, void* data, u64 size)
{
  assert(isSocketOpen());
  assert(isSocketBound());

  sockaddr_in6 socket_address;
  memset(&socket_address, 0, sizeof(socket_address));
  socket_address.sin6_family = AF_INET6;
  socket_address.sin6_port = htons(address.port);
  if (address.type == AddressType::Local)
  {
    // IPv6 loopback address (::1)
    socket_address.sin6_addr.s6_addr[15] = 1;
  }
  else
  {
    memcpy(&socket_address.sin6_addr, &address.ipv6,
           sizeof(socket_address.sin6_addr));
  }

  int bytes_sent = sendto(s_ipv6_socket, (const char*)data, size, 0,
                          (sockaddr*)&socket_address, sizeof(socket_address));
  if (SOCKET_ERROR == bytes_sent)
  {
    int error = WSAGetLastError();
    if (WSAEWOULDBLOCK == error)
      return false;
    else
      return @log_err("failed to send packet: ", iro::Win32ErrMsg(error), "\n");
  }

  @log_dbg("sent ", bytes_sent, " bytes to: ", address, "\n");
  assert(size == (u16)bytes_sent);
  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 receivePacket(
    Address* out_address, 
    void* data, 
    u64 size, 
    s32* out_bytes_received)
{
  if (!isSocketOpen())
    return false;

  sockaddr_in6 from;
  socklen_t from_len = sizeof(from);
  int bytes_received = recvfrom(s_ipv6_socket, (char*)data, size, 0,
                                (sockaddr*)&from, &from_len);
  if (SOCKET_ERROR == bytes_received)
  {
    int error = WSAGetLastError();
    if (WSAEWOULDBLOCK != error)
      @log_err("encountered error in attempt to recieve a packet: ",
               iro::Win32ErrMsg(error), '\n');

    return false;
  }

  *out_bytes_received = (s32)bytes_received;

  u8 ipv6[16];
  iro::mem::copy(ipv6, &from.sin6_addr, 16);
  *out_address = Address(ipv6, ntohs(from.sin6_port));

  return true;
}

} // namespace net

$ end -- if IRO_WIN32