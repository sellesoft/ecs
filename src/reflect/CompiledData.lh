/*
 *  Represents some packed data storable on disk.
 */

$ require "common"
$ local m = require "reflect.Metadata"

@lpp.import "core/OffsetPtr.lh"
@lpp.import "reflect/TypeId.lh"
@lpp.import "asset/Asset.lh"

#include "iro/Common.h"
#include "iro/containers/SmallArray.h"
#include "iro/Unicode.h"

struct Asset;
struct Ref;
struct SourceData;

namespace build { struct Rule; struct Result; }

namespace reflect
{

/* ============================================================================
 *  Note that this structure reprensents the header of the compiled data 
 *  as written to disk.
 */
struct CompiledData
{
  rtr::TypeId type;

  enum class PointerState
  {
    Offset,
    Absolute,
  };
  
  // TODO(sushi) see about also compiling out a table of pointers that need
  //             fixed as well. That would get rid of the fixPointers internals
  //             that we have now, like this got rid of the getRefs stuff. 
  //             This would help reduce generated code size, as well as 
  //             simplifying the process of fixing pointers. Might also make
  //             that faster too, since we would just be iterating an array.
  // TODO(sushi) investigate if we can actually store refs and pointers as 
  //             separate maps compiled to disk. I'm thinking that we could 
  //             possibly keep the convenience of being able to iterate over
  //             them linearly while also preventing CompiledData from having 
  //             its size bloated if we just compile out the maps separately.
  //             We could maybe load those maps, use them to find the refs
  //             and unfixed pointers in compiled data, fix up the data, then
  //             discard them once we don't need them anymore. Honestly, we
  //             could probably get away with just writing out the 
  //             CompiledRef/CompiledPointer structs defined in the lpp file, 
  //             since they just store offsets into the buffer where those 
  //             things are (to avoid usage of OffsetPtr and such).
  //             My main concern is when we go to package data. We don't really 
  //             want to have to store all refs and pointers in that data 
  //             for every compiled source data asset. For a package we would
  //             probably want to do something similar, where we can load all
  //             of the packaged data plus some data telling us how to fix
  //             pointers throughout the entire package, then discard the 
  //             pointers map once we're done.
  struct Ref
  {
    rtr::TypeId type;
    OffsetPtr<void> ptr;
    OffsetString target;
  };

  PointerState pointer_state;

  OffsetSlice<u8> root;
  OffsetSlice<u8> data;
  OffsetSlice<u8> strings;
  OffsetSlice<Ref> refs;

  struct CompileParams
  {
    // The type to compile the provided data into.
    rtr::TypeId type;
    
    // A pointer to the data to compile.
    // TODO(sushi) change this to Bytes and assert if size does not match.
    void* dataptr;

    // Where the compiled data should be output to.
    // TODO(sushi) we should support something like an IO* here, but for now 
    //             this is simpler and I believe our only usecase. I would 
    //             rather wait until iro's IO model is rewritten or otherwise
    //             improved before trying to use that here.
    String output_path;

    build::Result* result;
  };

  static b8 compile(const CompileParams& params);

  // TODO(sushi) it kinda blows that we need to pass an allocator in here. 
  //             Really, the size needed to load some CompiledData is the 
  //             size of the file on disk, but that's not totally clear 
  //             and its just easier to handle that stuff internally.
  //             Maybe add a thing to get the required size later (which
  //             also sucks cause that would be checking something on disk
  //             to do so).
  static CompiledData* load(
    String path, 
    mem::Allocator* allocator,
    build::Result* result);

  // Gets the loaded data as the specified C++ type. Note that currently there 
  // are no safety checks for if the provided 'T' actually matches the type the 
  // data was compiled for. 
  // TODO(sushi) implement those checks.
  // NOTE(sushi) the checks in question are kinda difficult to properly handle
  //             since this is templated, and C++ loses information in
  //             templates. This should be changed to be a macro instead 
  //             which takes the typename, transforms it to a typeid, checks
  //             that it matches 'type' and then casts the root pointer.
  //             Specifically, if we tried to use a typedef here and had 
  //             checks that would get the typeid from T, it would return
  //             the typeid of the typedef'd type, not the desired type, which
  //             would break. Not that it would necessarily be wrong (the 
  //             data would be the same), but we would want to make sure that 
  //             if a type is compiled as typedef B A;, and we ask for A, 
  //             we are going to only allow getting compiled data of type A,
  //             NOT B.
  // NOTE(sushi) I have just discovered that we can actually use rtr::TypeId
  //             as a template argument... Though I suppose we can't really 
  //             utilize that here cause we can't determine what the return
  //             type should be unless we have an in-header mapping of 
  //             typeids to their types. Don't really want to start generating
  //             code like that in headers. Just make it a macro.
  template<typename T>
  T* getRootAs() const
  {
    return (T*)root.getSlice().ptr;
  }
  
  // Fixes all pointers in the loaded data to absolute addresses.
  // This must be called before trying to use the data!!
  void fixPointers(); 

  static build::Rule getBuildRule();
};

struct CompiledDataLink : TypedAssetLink<CompiledData> { };

template<typename T>
struct TypedCompiledDataLink : CompiledDataLink
{
  // TODO(sushi) idk maybe just don't use operators at this point.
  T* operator -> () { return get().template getRootAs<T>(); }
  const T* operator -> () const { return get().template getRootAs<T>(); }
  T& operator * () { return *get().template getRootAs<T>(); }
  const T& operator * () const { return *get().template getRootAs<T>(); }
};

}
