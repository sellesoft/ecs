$ local cmn = require "common"
$ local ast = require "reflect.ast"
$ local List = require "iro.List"
$ local glob = require "iro.fs.glob"
$ local dumpValue = require "iro.util".dumpValue

$$$

local AstContext = require "reflect.AstContext"

local imported = require "string.buffer" .new()
local function importpattern(pattern)
  glob(pattern):each(function(path)
    imported:put((lpp.import(path)) or "")
  end)
end

importpattern "src/**/*.defs.lh"
importpattern "src/**/*.comp.lh"

local astctx = require "reflect.AstContext".fromString(tostring(imported))

-- io.write(ast.dump(astctx.translation_unit), '\n')

-- Shorthand helper for looking up a declaration by name.
local function lookup(name)
  return astctx:lookupTypeDecl(name)
end

$$$
@@imported:get

@@lpp.import "reflect/CompiledData.lh"
@@lpp.import "reflect/Packing.lh"
@@lpp.import "reflect/TypeId.lh"
@@lpp.import "build/Target.lh"
@@lpp.import "build/Rule.lh"
@@lpp.import "build/Result.lh"
@@lpp.import "build/BuildSystem.lh"
@@lpp.import "sdata/SourceDataFile.lh"

#include "iro/fs/fs.h"
#include "iro/fs/File.h"
#include "iro/memory/BinaryDataBuilder.h"

@log.import

namespace reflect
{

/* ============================================================================
 */
struct CompiledPtr
{
  u64 offset;
  u64 count;
  u64 size;
  rtr::TypeId type;
};

typedef SmallArray<CompiledPtr, 64> CompiledPtrs;

struct CompiledString
{
  u64 buffer_offset;
  u64 table_offset;
  // Note that the length of the string is stored in the String actually 
  // written to the data buffer.
};

typedef SmallArray<CompiledString, 64> CompiledStrings;

struct CompiledRef
{
  // The offset of the ref in the data buffer.
  u64 offset;
  // The type of the ref.
  rtr::TypeId type;
  // Index into the compiled strings array that represents the target
  // of the ref.
  u64 string_index;
};

typedef SmallArray<CompiledRef, 64> CompiledRefs;

/* ----------------------------------------------------------------------------
 */
template<typename... Args>
b8 buildError(build::Result* result, Args... args)
{
  if (result != nullptr)
    result->pushError(args...);
  else
    @log.error(reflect, args..., '\n');
  return false;
}

/* ============================================================================
 *  Data compiler state and interface, this provides the actual implementations
 *  of compilation of different types. Compiled data is written incrementally
 *  to 'data_buffer', strings are stored in 'string_buffer' to be indexed as 
 *  as a table in the resulting output. 'strings' and 'pointers' are small
 *  arrays storing pointers and strings to be handled after root/pointer 
 *  data have been compiled.
 *
 *  This also unfortunately doubles as a handler for fixing pointers and 
 *  finding references. Primarily because otherwise I would need to duplicate
 *  a lot of the ast walking code and declaration naming helpers to have 
 *  that be separate. 
 *
 *  TODO(sushi) pass the pointers here as separate context structs OR set 
 *              up an AST visitor api like clang as for walking our ast.
 *              The latter is probably a better approach and I can't believe
 *              I never thought of handling this problem (which has been a 
 *              problem FOREVER) like that until now.
 */
struct Compiler
{
  mem::BinaryDataBuilder* buffer;
  mem::BinaryDataBuilder* strings;
  CompiledStrings* compiled_strings;
  CompiledPtrs* compiled_pointers;
  CompiledRefs* compiled_refs;

$ -- Forward declared such that these may be called back into from within 
$ -- compiler placing functions, eg. a Struct calls this for the type of 
$ -- each of its fields.
$ local putDeclCompiler
$ local putTypeCompiler

$ -- * ------------------------------------------------------------------------

$ local function recordPlaced(decl)
$   decl.user.compiler_placed = true
$ end

$ -- * ------------------------------------------------------------------------

$ local function getDeclCompilerName(decl)
$   return "compile_"..decl:formCSafeName()
$ end

$ -- * ------------------------------------------------------------------------

$ local function getTypeCompilerName(type)
$   type = type:desugar()
$   if type:is(ast.TagType) then
$     return (getDeclCompilerName(type.decl))
$   elseif type:is(ast.Builtin) then
$     return "compile_"..type:formCSafeName()
$   elseif type:is(ast.Pointer) then
$     return "compile_voidptr"
$   else
$     error("unhandled type passed to getTypeCompilerName: "..
$           tostring(type)..'\n')
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ local function getDeclCompilerSig(decl)
$   return getDeclCompilerName(decl).."(const "..decl.type.name.."& data)"
$ end

$ -- * ------------------------------------------------------------------------

$ local function declareDeclCompiler(decl)
$   recordPlaced(decl)
$   return "void "..getDeclCompilerSig(decl)
$ end

$ -- * ------------------------------------------------------------------------

$ local function declareDeclCompilerFromName(name)
$   local decl = lookup(name)
$   if not decl then
$     error("could not find declaration with name "..name)
$   end
$   return declareDeclCompiler(decl)
$ end

$ -- * ------------------------------------------------------------------------

$ local function getDeclFixPointersName(decl)
$   return "fixPointers_"..decl:formCSafeName()
$ end

$ -- * ------------------------------------------------------------------------

$ local function getTypeFixPointersName(type)
$   type = type:desugar()
$   if type:is(ast.TagType) then
$     return (getDeclFixPointersName(type.decl))
$   elseif type:is(ast.Builtin) then
$     return "fixPointers_"..type:formCSafeName()
$   elseif type:is(ast.Pointer) then
$     return "fixPointers_voidptr"
$   else
$     error("unhandled type passed to getTypeFixPointersName: "..
$           tostring(type)..'\n')
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ local function getDeclFixPointersSig(decl)
$   return getDeclFixPointersName(decl).."("..decl.type.name.."* data)"
$ end

$ -- * ------------------------------------------------------------------------

$ local function declareDeclFixPointers(decl)
$   recordPlaced(decl)
$   return "void "..getDeclFixPointersSig(decl)
$ end

$ -- * ------------------------------------------------------------------------

$ local function declareDeclFixPointersFromName(name)
$   local decl = lookup(name)
$   if not decl then
$     error("could not find declaration with name "..name)
$   end
$   return declareDeclFixPointers(decl)
$ end

$ -- * ------------------------------------------------------------------------

$ local function putDeclFixPointersNoop(decl)
  /* --------------------------------------------------------------------------
   *  Fix pointers noop case.
   */
  $(declareDeclFixPointers(decl))
  {
  }
$ end

$ -- * ------------------------------------------------------------------------

$ local function putDeclFixPointersNoopFromName(name)
$   local decl = lookup(name)
$   if not decl then
$     error("could not find declaration with name "..name)
$   end
$   return putDeclFixPointersNoop(decl)
$ end

$ -- * ------------------------------------------------------------------------

$ local function putNumberCompiler(name)
  /* -------------------------------------------------------------------------
   */
  $(declareDeclCompilerFromName(name))
  {
    buffer->writeT(data);
  }
$  putDeclFixPointersNoopFromName(name)
$ end

$ putNumberCompiler "b8"
$ putNumberCompiler "u8"
$ putNumberCompiler "u16"
$ putNumberCompiler "u32"
$ putNumberCompiler "u64"
$ putNumberCompiler "s8"
$ putNumberCompiler "s16"
$ putNumberCompiler "s32"
$ putNumberCompiler "s64"
$ putNumberCompiler "f32"
$ putNumberCompiler "f64"

$ -- * ------------------------------------------------------------------------

  /* -------------------------------------------------------------------------
   *  Strings are specially handled since we need to compile them into their 
   *  own table that data points into using OffsetStrings. 
   * 
   *  TODO(sushi) once data size becomes a concern (hopefully never) we should 
   *              optimize strings by only storing them once. Should be quite 
   *              easy to just store a mapping of string hashes to their
   *              offset in the string table. Or something.
   */
  $(declareDeclCompilerFromName "iro::utf8::String")
  {
    // Record the string if its not nil.
    if (notnil(data))
    {
      compiled_strings->push(
      {
        // Mark where this String will appear in the compiled data.
        .buffer_offset = buffer->currentOffset(),
        // Mark where this String will appear in the string table.
        .table_offset = strings->currentOffset(),
      });

      // Copy the contents into the String table.
      strings->writeString(data);

      // Null-terminate the String. Even though we don't care for 
      // null-termination of strings throughout the project, things we have
      // to use unfortunately do (eg. OS functions). Doing this helps make 
      // writing tools easier, eg. the build system doesn't have to 
      // null-terminate every path in data before asking something to compile 
      // something.
      strings->writeByte(0);
    }
    
    // Write a String with a null ptr and its length in the table.
    buffer->writeT<String>({nullptr, data.len});
  }

  /* --------------------------------------------------------------------------
   */
  $(declareDeclFixPointersFromName "iro::utf8::String")
  {
    *data = OffsetString::getStringAsOffsetString(data);
  }

$ -- * ------------------------------------------------------------------------

  /* --------------------------------------------------------------------------
   *  Colors are handled specifically since they are a union, and we do not 
   *  handle those in reflected data for now (since their usage is ambiguous,
   *  similar to plain void*).
   */
  $(declareDeclCompilerFromName "Color")
  {
    buffer->writeT(data);
  }

$ putDeclFixPointersNoopFromName "Color"

$ -- * ------------------------------------------------------------------------

  /* --------------------------------------------------------------------------
   *  void pointers are a special case as they may have use in reflected data
   *  such as Component and ResourceRef. These should never show up as 
   *  something specifyable in data, though! Eventually, these types should 
   *  probably try to eliminate usage of void* (Component) or use a type with
   *  better semantics (ResourceRef).
   *
   *  We simply write out a nullptr when we come across these.
   */
  void compile_voidptr(const void* data)
  {
    buffer->writeZeroedT<void*>();
  }

  void fixPointers_voidptr(void*)
  {
    // Noop 
  }

$ -- * ------------------------------------------------------------------------

$ local function putVec2Compiler(name)
  /* --------------------------------------------------------------------------
   *  Special handling because vec2's use unions.
   */
  $(declareDeclCompilerFromName(name))
  {
    buffer->writeT(data);
  }

$   putDeclFixPointersNoopFromName(name)
$ end

$ putVec2Compiler "vec2<int>"
$ putVec2Compiler "vec2<float>"

$ -- * ------------------------------------------------------------------------

$ local function putStructCompiler(decl)
$   for field in decl:eachField() do
$     putTypeCompiler(field.type)
$   end
$ 
$   for nested in decl:eachNestedRecord() do
$     putDeclCompiler(nested)
$   end

  /* --------------------------------------------------------------------------
   */
  $(declareDeclCompiler(decl))
  {
    // Record what offset we're compiling this struct to, so that at the 
    // end we may assert that the resulting data is the same size as this 
    // type.
    u64 start_offset = buffer->currentOffset();

    @log.trace(reflect, "compile $(decl.type.name)\n");

$ local is_ref = decl:findMetadata "ref"

$ if is_ref then
    // This is a ref type, so we want to store the index of the 'name' field
    // as it will appear in the compiled_strings array once it is compiled.
    // We do this so that we may reference it in the CompiledRef we will be 
    // pushing after all the fields have been compiled.
    u64 compiled_ref_name_index = -1;
$ end

$ -- Write out each field of this struct, keeping track of the last field
$ -- we compiled such that we may insert whatever padding may be there.
$   local last_field
$   for field, record in decl:allFields() do
$     if last_field then
$       -- Compute possible padding of the last field and insert it if needed.
$       local diff = field.offset - last_field.offset
$       if diff > last_field.type.size then
    // Allocate padded space from previous field.
    buffer->writeZeroed($(diff - last_field.type.size));
$       end
$     end
$     last_field = field
    // Fine grained asserts!
    assert(buffer->currentOffset() - start_offset == $(field.offset));
$   if is_ref and field.name == "name" then
    // Mark the index in the compiled_strings array where this ref type's 
    // target will appear.
    compiled_ref_name_index = compiled_strings->len;
$   end
    // field '$(field.name)'
    //   offset: $(field.offset)
    //     size: $(field.type.size)
    //     type: $(field.type.name)
    $(getTypeCompilerName(field.type))(data.$(field.name));
$   end

$   if last_field then
$     local this_size = decl.type.size 
$     local last_extent = last_field.type.size + last_field.offset
$     if this_size > last_extent then
    // Trailing padding.
    buffer->writeZeroed($(this_size - last_extent));
$     end
$   end

$ if 0 ~= decl:countFields() then
$   -- Check that the size of data we wrote matches the size of this type,
$   -- to catch improper compilation at runtime. Note that we do not do this
$   -- for empty structs as for whatever reason in C++ sizeof an empty type
$   -- results in 1, not 0. C++ is so fucking stupid!!!
    assert(
      buffer->currentOffset() - start_offset == sizeof($(decl.type.name)));
$ end

$ if decl:findMetadata "ref" then
$   -- If this is a ref type, we want to record the compiled ref's target,
$   -- type, and its address so that we can compile it into a table for 
$   -- easier iteration when this data is eventually loaded. Note that we 
$   -- also only do this when the ref actually has a target, to make iterating
$   -- them easier later (can assume all refs are valid) and to save on some
$   -- memory.
    if (notnil(data.name))
    {
      assert(compiled_ref_name_index != -1);
      compiled_refs->push(
        {start_offset, "$(decl.type.name)"_typeid, compiled_ref_name_index});
    }
$ end

  }

  /* --------------------------------------------------------------------------
   */
  $(declareDeclFixPointers(decl))
  {
$ if decl.base then
    $(getDeclFixPointersName(decl.base))(data);
$ end

$ for field in decl:eachField() do
    $(getTypeFixPointersName(field.type))(&data->$(field.name));
$ end
  }
$ end

$ -- * ------------------------------------------------------------------------

$ local function putArrayDefCompiler(decl)
$   local subtype = decl.args[1]
$   putTypeCompiler(subtype)
  /* --------------------------------------------------------------------------
   */
  $(declareDeclCompiler(decl))
  {
    @log.trace(reflect, "compile array $(decl.type.name)\n");

    // Record the pointer to the array's contents to be compiled after 
    // we finish compiling this data.
    compiled_pointers->push(
    {
      // Record where in the output this pointer will appear.
      .offset = buffer->currentOffset(),
      // Record how many elements the pointer points to.
      .count = data.len,
      // Record the size of the subtype.
      // Note that we use sizeof here to ensure the size is not subject to 
      // any BUGS in the reflection code.
      .size = sizeof($(subtype.name)),
      // Record the typeid of the subtype.
      .type = "$(subtype.name)"_typeid,
    });

    buffer->writeT(data);
  }
  
  /* --------------------------------------------------------------------------
   */
  $(declareDeclFixPointers(decl))
  {
    data->arr = OffsetPtr<void>::getPtrAsOffsetPtr(&data->arr);
    for (auto& elem : *data)
      $(getTypeFixPointersName(subtype))(&elem);
  }
$ end

$ -- * ------------------------------------------------------------------------

$ local function putStringMapCompiler(decl)
$   putDeclCompiler(decl:findNestedRecord "Slot")
  /* --------------------------------------------------------------------------
   */
  $(declareDeclCompiler(decl))
  {
    compiled_pointers->push(
    {
      .offset = buffer->currentOffset(),
      .count = (u64)data.len,
      .size = sizeof($(decl.type.name)::Slot),
      .type = "$(decl.type.name)::Slot"_typeid,
    });

    buffer->writeT(data);
  }
  
  /* --------------------------------------------------------------------------
   */
  $(declareDeclFixPointers(decl))
  {
    data->slots = OffsetPtr<void>::getPtrAsOffsetPtr(&data->slots);
    for (auto& elem : *data)
    {
      $(getDeclFixPointersName(decl:findNestedRecord "Slot"))(&elem);
    }
  }
$ end

$ -- * ------------------------------------------------------------------------

$ local function putTypedStringMapCompiler(decl)
  /* --------------------------------------------------------------------------
   */
  $(declareDeclCompiler(decl))
  {
    assert(!"typed string map compilation not implemented yet");
  }
$   putDeclFixPointersNoop(decl)
$ end

$ -- * ------------------------------------------------------------------------

$ local function putFlagsCompiler(decl)
  /* --------------------------------------------------------------------------
   */
  $(declareDeclCompiler(decl))
  {
    // Just write out the raw enum value.
    buffer->writeT(data);
  }
$   putDeclFixPointersNoop(decl)
$ end

$ -- * ------------------------------------------------------------------------

$ local function putTemplateSpecCompiler(decl)
$   for arg in decl.args:each() do
$     if arg:is(ast.Type) then
$       putTypeCompiler(arg)
$     end
$   end
$
$   local name = decl.specialized.qname
$   if name == "reflect::Array" then
$     putArrayDefCompiler(decl)
$   elseif name == "reflect::StringMap" then
$     putStringMapCompiler(decl)
$   elseif name == "reflect::TypedStringMap" then
$     putTypedStringMapCompiler(decl)
$   elseif name == "iro::Flags" then
$     putFlagsCompiler(decl)
$   else
$     io.write("warn: unhandled template spec (compiler): ", decl, "\n")
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ local function putRecordCompiler(decl)
$   if decl.base then
$     putDeclCompiler(decl.base)
$   end
$  
$   if decl:findMetadata "ref" then
$     -- NOTE(sushi) trying out just compiling refs as structs for now 
$     --             as I believe that should handle them given how simple
$     --             they are at the moment.
$     putStructCompiler(decl)
$   elseif decl:is(ast.TemplateSpec) then
$     putTemplateSpecCompiler(decl)
$   elseif decl:is(ast.Struct) then
$     putStructCompiler(decl)
$   else
$     io.write("warn: ******* unhandled record type *********\n", 
$              ast.dump(decl), "\n")
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ local function putEnumCompiler(decl)
  /* --------------------------------------------------------------------------
   */
  $(declareDeclCompiler(decl))
  {
    // Just write out the raw enum value.
    buffer->writeT(data);
  }
$   putDeclFixPointersNoop(decl)
$ end

$ -- * ------------------------------------------------------------------------

$ putDeclCompiler = function(decl)
$   decl.user = decl.user or {}
$   if decl.user.compiler_placed then
$     return
$   end
$  
$   if decl:is(ast.TagDecl) then
$     if decl:is(ast.Record) then
$       putRecordCompiler(decl)
$     elseif decl:is(ast.Enum) then
$       putEnumCompiler(decl)
$     end
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ putTypeCompiler = function(type)
$   type = type:desugar() 
$   if type:is(ast.TagType) then
$     putDeclCompiler(type.decl)
$   elseif not type:is(ast.Builtin) and not type:is(ast.Pointer) then
$     io.write("warn: unhandled type: ", type, '\n')
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ for decl in astctx.type_decls:each() do
$   if decl.metadata.def then
$     putDeclCompiler(decl)
$   end
$ end

  // Define the runtime typeid compile handler.
  void compileTypeId(rtr::TypeId type, const void* data)
  {
    switch (type.val)
    {
$ for decl in astctx.type_decls:each() do
$   if decl.user.compiler_placed then
$     if decl.typedefs then
$       -- If this decl has been typedef'd also handle those typenames as 
$       -- well. Note that we have to use the type the typedef declares,
$       -- not the typedef itself, to preserve namespaces.
$       for typedef in decl.typedefs:each() do
    case "$(typedef.type.name)"_typeid_val:
$       end
$     end
    case "$(decl.type.name)"_typeid_val:
      $(getDeclCompilerName(decl))(*($(decl.type.name)*)data);
      return;
$   end
$ end
    }

    assert(!"unhandled typeid given to data compiler");
  }
};

/* ----------------------------------------------------------------------------
 */
b8 CompiledData::compile(const CompileParams& params)
{
$ local function err(...)
$   return [[buildError(params.result, "while compiling '", ]]..
$     [[params.output_path, "': ", ]]..
$     cmn.joinArgs(',',...)..[[)]]
$ end

  assert(notnil(params.type));
  assert(notnil(params.output_path));
  assert(params.dataptr != nullptr);

  // Attempt to open (and lock) the specified output file early such that 
  // any error with doing so is caught quickly.
  fs::File out_file = fs::File::createForTruncatedWriting(params.output_path);
  if (isnil(out_file))
    return @err("failed to open file");
  defer { out_file.close(); };

  auto failsafe_delete_outfile = deferWithCancel
  {
    fs::unlink(params.output_path);
  };

  // TODO(sushi) should take an allocator for this eventually. Prob when we 
  //             get to multithreading this where we'd prob wanna dedicate
  //             an allocator to each of those threads to avoid any sorta
  //             stl_allocator thread-safe internals (maybe they handle 
  //             that well, I don't know, but I am NOT looking over stl 
  //             code!!!).

  // Create the buffer we will incrementally compile data into.
  mem::BinaryDataBuilder buffer;
  if (!buffer.init(1024))
    return @err("failed to initialize BinaryDataBuilder");
  defer { buffer.deinit(); };
  
  // Allocate and set up header info.
  {
    buffer.writeZeroedT<CompiledData>();

    auto* header = (CompiledData*)buffer.data.ptr;
    header->type = params.type;
    header->pointer_state = PointerState::Offset;
  }

  // Create the string table builder.
  mem::BinaryDataBuilder string_table;
  if (!string_table.init(1024))
    return @err("failed to initialize BinaryDataBuilder for string table");
  defer { string_table.deinit(); };

  // Small arrays for storing pointers and strings while compiling each blob
  // of data.
  // Pointers are stored such that we may compile each blob of memory in 
  // succession while strings are stored so we may point all Strings found 
  // data to their location in the string table after all data has been 
  // compiled.
  // Refs are stored so that we may compile a table of references made in
  // compiled data for easier interation of them once this data is 
  // eventually loaded. We used to provide a getRefs() function for this,
  // but that complicated the internals a bit. So, we sacrifice a little 
  // bit of memory by storing a table of them instead.
  CompiledStrings strings;
  CompiledPtrs pointers;
  CompiledRefs refs;

  // Store the offset at which we are going to start writing the actual data.
  u64 data_start_offset = buffer.currentOffset();

  // Create a Compiler and prep it for building data.
  Compiler compiler;
  compiler.buffer = &buffer;
  compiler.strings = &string_table;
  compiler.compiled_strings = &strings;
  compiler.compiled_pointers = &pointers;
  compiler.compiled_refs = &refs;

  // Compile the root data.
  compiler.compileTypeId(params.type, params.dataptr);
  
  // Store the size of the root data.
  // TODO(sushi) we eventually need to add checks for if this matches the 
  //             type's size, but atm rtr does not provide a function 
  //             for getting size from a typeid. I will get to that once 
  //             other stuff is properly reimplemented (or if it winds up
  //             needed).
  u64 root_size = buffer.currentOffset() - data_start_offset;

  // Process each layer of pointers following the root data.
  for (;;)
  {
    // Gather the next set of pointers into a separate buffer.
    CompiledPtrs next_pointers;
    compiler.compiled_pointers = &next_pointers;

    // Compile data that is pointed to by this type into their own blobs.
    for (auto& ptr : pointers)
    {
      // Get the address of the pointer and what it points to.
      void** ptrptr = (void**)(buffer.data.ptr + ptr.offset);
      void* ptrdata = *ptrptr;

      // Set the pointer to be an offset to the data we're about to write.
      OffsetPtr<void>::setPtrAsOffsetPtr(
        ptrptr, 
        (void*)(buffer.data.ptr + buffer.currentOffset()));

      // Compile each pointee.
      for (s32 i = 0; i < ptr.count; ++i)
      {
        void* pointee = (u8*)ptrdata + i * ptr.size;
        compiler.compileTypeId(ptr.type, pointee);
      }
    }

    // If didn't retrieve any more pointers, then we're done compiling the 
    // data.
    if (next_pointers.isEmpty())
      break;

    // Otherwise, swap the new pointers into the current.
    next_pointers.move(&pointers);
  }

  // Store where the string table will be in data.
  u64 string_table_offset = buffer.currentOffset();

  // Repoint all Strings we found in data to point at their location in 
  // the string table.
  for (auto& str : strings)
  {
    // Get the String that we wrote into the buffer.
    auto* strptr = (String*)(buffer.data.ptr + str.buffer_offset);

    // Pun it as an OffsetString and point to its content. This will break
    // if String ever becomes smaller than OffsetString but I believe that
    // should never happen. If for whatever reason it does, we'll probably
    // need a special String type used in data we expect to be compiled.
    // TODO(sushi) once I move the current reflect types out of asset/ into
    //             reflect/, we should make a String type specifically for 
    //             use in reflected data to avoid the above possibility.
    OffsetString::setStringAsOffsetString(strptr, 
      String::from(
        buffer.data.ptr + string_table_offset + str.table_offset,
        strptr->len));
  }

  // Store where the ref table will be in data.
  u64 ref_table_offset = string_table_offset + string_table.data.len;
  b8 has_refs = !refs.isEmpty();

  // Build the ref table if any references were compiled.
  mem::BinaryDataBuilder ref_table;
  defer 
  {
    if (has_refs)
      ref_table.deinit();
  };

  if (has_refs)
  {
    if (!ref_table.init(1024))
      return @err("failed to initialize BinaryDataBuilder");

    // Prep the table with the refs.
    ref_table.writeZeroedArrayT<Ref>(refs.len);

    for (s32 i = 0; i < refs.len; ++i)
    {
      u64 ref_offset_in_table = sizeof(Ref) * i;
      u64 ref_abs_offset = ref_offset_in_table + ref_table_offset;

      CompiledRef* compiled_ref = &refs[i];
      Ref* ref = (Ref*)(ref_table.data.ptr + ref_offset_in_table);

      ref->type = compiled_ref->type;

      // Compute the offset from the ref ptr's position in the compiled data
      // BACK to the actual data as it will be placed in the result.
      //
      // This may be visualized like so, given:
      //   d is the data buffer
      //   x is the data we want the ref's pointer to offset to
      //   s is the string table
      //   r is the ref table
      //   p is the ref's pointer
      // 
      //  d    x     s       r  p
      //  |    |     |       |  |
      //       \________________/
      // So, the ref pointer's offset in the resulting ref table, minus the 
      // offset of the data it wants to point to the in the data buffer.
      u64 ref_ptr_offset = (u8*)&ref->ptr - (u8*)ref;
      u64 ref_ptr_abs_offset = ref_abs_offset + ref_ptr_offset;
      u64 ref_ptr_offset_to_data = ref_ptr_abs_offset - compiled_ref->offset;
      ref->ptr.set((u8*)&ref->ptr - ref_ptr_offset_to_data);

      // Get the CompiledString representing the target of the ref as it 
      // will be written to the string table such that we can point to
      // it from the Ref. This isn't necessary I don't think, but it is 
      // useful for how Refs are not inheriting a common thing anymore.
      // As in, this avoids needing to use the typeid of the ref at runtime
      // to determine where the 'name' member actually is in the ref's data.
      // TODO(sushi) decide if it would be better (memory-wise) to just store
      //             an OffsetPtr<String> to the actual String in the buffer.
      //             The way it is now avoids needing to fixPointers to get 
      //             the target, since we are just pointing at the string 
      //             table, but we also have to store the string's length
      //             twice to do it this way.
      CompiledString* compiled_name = &strings[compiled_ref->string_index];

      // Get the string written to the buffer, since that is where it's 
      // length is actually stored.
      auto* str = (String*)(buffer.data.ptr + compiled_name->buffer_offset);

      u64 ref_target_offset = (u8*)&ref->target - (u8*)ref;
      u64 ref_target_abs_offset = ref_abs_offset + ref_target_offset;
      u64 ref_target_offset_to_string = 
        ref_target_abs_offset - 
        (compiled_name->table_offset + string_table_offset);

      ref->target.setSlice(
        (u8*)&ref->target - ref_target_offset_to_string,
        str->len);
    }
  }

  // Set the offset header data.
  auto* header = (CompiledData*)buffer.data.ptr;

  // Root data is the first block we place.
  header->root.setSlice(buffer.data.ptr + data_start_offset, root_size);

  // Set the slice spanning all compiled data (remember this includes root).
  header->data.setSlice(
    buffer.data.ptr + data_start_offset, 
    buffer.currentOffset() - data_start_offset);

  // The string table will be placed directly after the binary data, so
  // point its slice there.
  header->strings.setSlice(
    buffer.data.ptr + string_table_offset,
    string_table.data.len);

  if (has_refs)
  {
    header->refs.setSlice(
      (Ref*)(buffer.data.ptr + ref_table_offset),
      refs.len);
  }

  // Finally, write out the data to the output file.
  out_file.write(buffer.data);
  out_file.write(string_table.data);
  if (has_refs)
    out_file.write(ref_table.data);

  failsafe_delete_outfile.cancel();
  return true;
}

/* ----------------------------------------------------------------------------
 *  Take an allocator or provide a function for getting the size required 
 *  for compiled data at a given path (which is just its file size but yeah).
 */
CompiledData* CompiledData::load(
    String path, 
    mem::Allocator* allocator,
    build::Result* result)
{
$ local function err(...)
$   return 
$     [[buildError(result, "while loading compiled data '", path, "': ", ]]..
$     cmn.joinArgs(',',...)..[[), nullptr]]
$ end

  assert(notnil(path) && allocator != nullptr);
  
  auto file = fs::File::openForRead(path);
  if (isnil(file))
    return @err("failed to open file");
  defer { file.close(); }; 

  fs::Stat stat;
  if (!fs::stat(path, &stat))
    return @err("failed to stat file for size");

  auto* data = (CompiledData*)allocator->allocate(stat.byte_size);
  file.read({(u8*)data, stat.byte_size});

  // Assert that the pointers were compiled as offsets.
  // Otherwise this is not valid data.
  assert(data->pointer_state == PointerState::Offset);

  return data;
}

/* ----------------------------------------------------------------------------
 */
void CompiledData::fixPointers()
{
  if (pointer_state == PointerState::Absolute)
    return;

  // TODO(sushi) really need to come up with a way to separate these.
  Compiler compiler;

  switch (type.val)
  {
$ for decl in astctx.type_decls:each() do
$   if decl.user.compiler_placed then
$     if decl.typedefs then
$       -- If this decl has been typedef'd also handle those typenames as 
$       -- well. Note that we have to use the type the typedef declares,
$       -- not the typedef itself, to preserve namespaces.
$       for typedef in decl.typedefs:each() do
    case "$(typedef.type.name)"_typeid_val:
$       end
$     end
    case "$(decl.type.name)"_typeid_val:
      compiler.$(getDeclFixPointersName(decl))(
        ($(decl.type.name)*)data.ptr.get());
      break;
$   end
$ end
  default:
    @log.error(reflect, 
          "CompiledData::fixPointers not implemented for type ",
          rtr::typenameFromTypeId(type), '\n');
    assert(!"unhandled type in CompiledData::fixPointers");
  }

  pointer_state = PointerState::Absolute;
}

/* ----------------------------------------------------------------------------
 */
static void compiledDataGetPrereqs(const build::RuleParams_GetPrereqs& params)
{
  // Data targets need some SourceData to build, which should have the same 
  // name and type, but without the .data extension.
  build::Target* source_target = params.build_system->findOrCreateTarget(
    params.target->name,
    params.target->type.removeSuffix(".data"_str),
    build::TargetKind::SourceData);

  // Note the source target as a prereq.
  params.prereqs->insert(source_target);
}


/* ----------------------------------------------------------------------------
 */
static void compiledDataBuild(const build::RuleParams_Build& params)
{
   // Get the target we are building from, it should already exist.
  build::Target* source_target = params.build_system->findTarget(
    params.target->name, 
    params.target->type.removeSuffix(".data"_str),
    build::TargetKind::SourceData);

  assert(source_target != nullptr);

  build::PathBuffer source_path_buffer;
  build::PathBuffer target_path_buffer;

  String source_path = source_target->formFullPath(&source_path_buffer);
  String target_path = params.target->formFullPath(&target_path_buffer);

  // Load the source data file.
  // TODO(sushi) we should be passing in a build::Result here but that's 
  //             starting to cause build related stuff to intrude on most 
  //             systems. For tooling, we should experiment with iro providing
  //             a generic interface for emitting diagnostics that can be 
  //             passed around to all the tools in enosi and is not tied to 
  //             how some system would like them to work. Something similar 
  //             to how llvm's diagnostic consumer thing works.
  SourceDataFile sfile;
  if (!SourceDataFile::from(&sfile, source_path))
  {
    buildError(params.result, "failed to load source data file");
    return;
  }
  defer { sfile.deinit(); };

  PackedData packed;
  if (!packed.init())
  {
    buildError(params.result, "failed to initialied PackedData");
    return;
  }
  defer { packed.deinit(); };

  PackParams pack_params = 
  {
    .packed = &packed,
    .result = params.result,
  };

  if (!packSourceDataFromType(*sfile.returned_data, pack_params))
    return; // error will have been emitted internally.

  CompiledData::CompileParams compile_params = 
  {
    .type = packed.type,
    .dataptr = packed.data.ptr,
    .output_path = target_path,
    .result = params.result,
  };

  if (!CompiledData::compile(compile_params))
    return;

  CompiledData* compiled = CompiledData::load(
    compile_params.output_path, 
    &params.build_system->compiled_data_allocator,
    params.result);

  if (compiled == nullptr)
    return;

  compiled->fixPointers();

  for (CompiledData::Ref& ref : compiled->refs.getSlice())
  {
    String def_links = rtr::getMetadataValue(ref.type, "links"_str);

    if (isnil(def_links))
      continue;

    String::Pair split = def_links.splitAtFirst(';');

    for (;;)
    {
      build::Target* links_target = params.build_system->findOrCreateTarget(
        ref.target.getString(),
        split.first,
        build::TargetKind::Unknown);

      params.target->links(links_target);

      if (isnil(split.second))
        break;

      split = split.second.splitAtFirst(';');
    }
  }
}

/* ----------------------------------------------------------------------------
 */
build::Rule CompiledData::getBuildRule()
{
  return 
  {
    .types = "data"_str,
    .interface = 
    {
      .getPrereqs = compiledDataGetPrereqs,
      .build = compiledDataBuild,
    }
  };
}

}
