$ local cmn = require "common"
$ local ast = require "reflect.ast"
$ local List = require "iro.List"
$ local dumpValue = require "iro.util".dumpValue

$$$

local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/**/*.defs.lh",
  "src/**/*.comp.lh"
}

local function lookup(name)
  return astctx:lookupDecl(name)
end

local av = require "reflect.AstVisitor" .new(astctx)

$$$
$(imported)

@lpp.import "reflect/CompiledData.lh"
@lpp.import "reflect/Packing.lh"
@lpp.import "reflect/TypeId.lh"
@lpp.import "build/Target.lh"
@lpp.import "build/Rule.lh"
@lpp.import "build/Result.lh"
@lpp.import "build/BuildSystem.lh"
@lpp.import "sdata/SourceDataFile.lh"

#include "iro/fs/fs.h"
#include "iro/fs/File.h"
#include "iro/memory/BinaryDataBuilder.h"

@log.import

namespace reflect
{

/* ============================================================================
 */
struct CompiledPtr
{
  u64 offset;
  u64 count;
  u64 size;
  rtr::TypeId type;
};

typedef SmallArray<CompiledPtr, 64> CompiledPtrs;

struct CompiledString
{
  u64 buffer_offset;
  u64 table_offset;
  // Note that the length of the string is stored in the String actually 
  // written to the data buffer.
};

typedef SmallArray<CompiledString, 64> CompiledStrings;

struct CompiledLink
{
  // The offset of the link in the data buffer.
  u64 offset;
  // The type of the link.
  rtr::TypeId type;
  // Index into the compiled strings array that represents the target
  // of the link.
  u64 compiled_string_index;
};

typedef SmallArray<CompiledLink, 64> CompiledLinks;

/* ----------------------------------------------------------------------------
 */
template<typename... Args>
b8 buildError(build::Result* result, Args... args)
{
  if (result != nullptr)
    result->pushError(args...);
  else
    @log.error(reflect, args...);
  return false;
}


/* ============================================================================
 *  Data compiler state and interface. This contains the actual implementations
 *  of data compilation functions.
 */
struct Compiler
{
  mem::BinaryDataBuilder* buffer;
  mem::BinaryDataBuilder* strings;
  CompiledStrings* compiled_strings;
  CompiledPtrs* compiled_pointers;
  CompiledLinks* compiled_links;

$ -- * ------------------------------------------------------------------------
$ --
$ -- Function declaration and call generation helper.
$ --
$ -- The name of a function is compile_<c-safe-typename> where 
$ -- <c-safe-typename> is generated from the decl or type we pass to `comp`s
$ -- methods. See formCSafeName() on the types in ast.lua.

@[comp] av:funcgen(
  compile_,
  void,
  this Compiler& self,
  const %& data)

$ -- * ------------------------------------------------------------------------
$ -- Our typedefs of builtins get written out directly.

$ av:previsit(ast.iro_builtins, function(type)
  /* -------------------------------------------------------------------------
   */
  $(comp.declare(type))
  {
    self.buffer->writeT(data);
  }
$ end)

$ -- * ------------------------------------------------------------------------
$ -- Typedefs simply passthrough to their underlying type's compiler func.

$ av:visit(ast.TypedefDecl, function(decl)
  /* -------------------------------------------------------------------------
   */
  $(comp.declare(decl))
  {
    self.$(comp.call(decl.subtype))(data);
  }
$ end)

$ -- * ------------------------------------------------------------------------
$ -- Strings get special handling since we need to emit compiled data in 
$ -- such a way that we can load it directly (eg. the output size is the 
$ -- same size we load). To do this we construct a string table, and Strings
$ -- become OffsetStrings that point into that table.

$ av:visit(lookup "iro::utf8::String", function(decl)
  /* -------------------------------------------------------------------------
   */
  $(comp.declare(decl))
  {
    // If the String has content, then record it.
    if (notnil(data))
    {
      self.compiled_strings->push(
      {
        // Mark where this String will appear in the compiled data.
        .buffer_offset = self.buffer->currentOffset(),
        // Mark where this String's content will appear in the string table.
        .table_offset = self.strings->currentOffset(),
      });

      // Copy the contents into the String table.
      self.strings->writeString(data);

      // Null-terminate the String. Even though we don't care for 
      // null-termination of strings throughout the project, things we have
      // to use unfortunately do (eg. OS functions). Doing this helps make 
      // writing tools easier. For example, the build system doesn't have to 
      // null-terminate every path in data before asking something to compile 
      // something.
      self.strings->writeByte(0);
    }

    // Write a String to the buffer with a nullptr and its length in the table.
    self.buffer->writeT<String>({nullptr, data.len});
  }
$ end)

$ -- * ------------------------------------------------------------------------
$ -- Colors are special because they contain a union, which we do not handle
$ -- in the reflection system since their use is ambiguous.

$ av:visit(lookup "Color", function(decl)
  /* -------------------------------------------------------------------------
   */
  $(comp.declare(decl))
  {
    self.buffer->writeT(data);
  }
$ end)

$ -- * ------------------------------------------------------------------------
$ -- Structs are built from their fields, as well as any fields from its bases.

$ av:visit(ast.Struct, function(decl)
  /* -------------------------------------------------------------------------
   */
  $(comp.declare(decl))
  {
    u64 start_offset = self.buffer->currentOffset();

$   -- For link types, we need track where their name appears in the 
$   -- `compiled_strings` array. See the end of this function.
$   local is_link = decl:findMetadata "ref"
$   if is_link then
    u64 compiled_link_name_idx = -1;
$   end

$   local function checkPrevFieldPadding(prev_field, curr_field)
$     if prev_field then
$       local diff = curr_field.offset - prev_field.offset
$       local padding_size = diff - prev_field.type.size
$       if padding_size > 0 then
    // Allocate padded space from the previous field.
    self.buffer->writeZeroed($(padding_size));
$       end
$     end
$   end

$   -- In debug builds, assert that our current offset matches that of the 
$   -- field.
$   local function assertProperOffset(field, record)
$     if ECS_DEBUG then
    assert($(field.offset) == self.buffer->currentOffset() - start_offset);
$     end
$   end

$   -- For link types, record the index at which its name string will appear
$   -- in the `compiled_strings` array. This is used later to generate the 
$   -- list of embedded refs stored elsewhere.
$   local function recordLinkNameIndex(field)
$     if is_link and field.name == "name" then
    compiled_link_name_idx = self.compiled_strings->len;
$     end
$   end

$   -- Call the field's compiler function. Also, detect if this field is a 
$   -- pointer. We don't allow raw pointers in data because their use is 
$   -- ambiguous (like unions), however they appear in link types since those
$   -- need to point at the underlying asset/resource they are linking to.
$   --
$   -- TODO(sushi) we can probably make this more general and allow pointers
$   --             only when they are marked 'hidden'. They just aren't 
$   --             allowed to have meaning in data.
$   --             Really, though, we should be validating these kinds of 
$   --             things in some central location. These kinds of checks 
$   --             are all around the reflection code and it'll likely get
$   --             to a point where fixing them all gets quite annoying.
$   local function callFieldCompiler(field)
$     if field.type:is(ast.Pointer) then
$       if not is_link then
$          error("reflected data type "..decl.type.qname.." contains a "..
$                "raw pointer!")
$       end
    // Link pointer.
    self.buffer->writeZeroedT<void*>();
$     else
    self.$(comp.call(field.type))(data.$(field.name));
$     end
$   end

$   -- Iterate over the fields of this struct AND its bases (if any).
$   -- We track the prev field because its possible we may need to insert
$   -- padding after it.
$   local prev_field
$   for field, record in decl:allFields() do
$     checkPrevFieldPadding(prev_field, field)
$     prev_field = field
$     assertProperOffset(field, record)
$     recordLinkNameIndex(field)
$     callFieldCompiler(field)
$   end

$   -- After compiling each field, we need to check if there's any padding
$   -- at the end of this struct, and in debug we perform the final check
$   -- that the amount of data we wrote matches the size of the struct.
$   -- Note that we do not do the final assert for empty structs, primarily
$   -- because there's no reason to, but also because in C++ the size of an
$   -- empty struct is 1, so the assert would always fail.
$   if prev_field then
$     local this_size = decl.type.size
$     local last_extent = prev_field.type.size + prev_field.offset
$     local padding_size = this_size - last_extent
$     if padding_size > 0 then
    // Trailing padding.
    self.buffer->writeZeroed($(padding_size));
$     end
$     if ECS_DEBUG then
    u64 final_offset = self.buffer->currentOffset() - start_offset;
    assert(final_offset == sizeof($(decl.type.qname)));
$     end
$   end

$   -- Finally, if this is a link type, record the compiled link's target
$   -- type and address so that we can compile it into a table for easier 
$   -- iteration when this data is eventually loaded. Also only do this 
$   -- when the link actually links something, so that we can always assume
$   -- embedded links are valid in iteration.
$   if is_link then
    if (notnil(data.name))
    {
      self.compiled_links->push(
      {
        .offset = start_offset,
        .type = "$(decl.type.qname)"_typeid,
        .compiled_string_index = compiled_link_name_idx,
      });
    }
$   end
  }
$ end)

$ -- * ------------------------------------------------------------------------
$ -- Arrays report what they point to and how many elements they contain
$ -- so that we can compile them separately.

$ av:visit(lookup "reflect::Array", function(decl)
$   local subtype = decl.args[1]
  /* -------------------------------------------------------------------------
   */
  $(comp.declare(decl))
  {
    // If this array is not empty, report where its contents are.
    if (!data.isEmpty())
    {
      self.compiled_pointers->push(
      {
        // Record where in the output buffer this pointer will appear.
        .offset = self.buffer->currentOffset(),
        // Record how many elements this pointer points to.
        .count = data.len,
        // Record the size of the subtype.
        .size = sizeof($(subtype.qname)),
        // Record the typeid of the subtype.
        .type = "$(subtype.qname)"_typeid,
      });
    }

    // Write the raw data of the array.
    self.buffer->writeT(data);
  }
$ end)

$ -- * ------------------------------------------------------------------------
$ -- StringMaps report where the slots they point to are. At the moment, we 
$ -- also have to explicitly ask the AstVisitor to handle its Slot type,
$ -- as it does not automatically handled nested records.

$ av:visit(lookup "reflect::StringMap", function(decl)
$   av:handleDecl(decl:findNestedRecord "Slot")
  /* -------------------------------------------------------------------------
   */
  $(comp.declare(decl))
  {
    if (!data.isEmpty())
    {
      self.compiled_pointers->push(
      {
        .offset = self.buffer->currentOffset(),
        .count = (u64)data.len,
        .size = sizeof($(decl.type.qname)::Slot),
        .type = "$(decl.type.qname)::Slot"_typeid,
      });
    }

    self.buffer->writeT(data);
  }
$ end)

$ -- * ------------------------------------------------------------------------
$ -- TypedPtrs just record what they point to, if anything. Also, we need to
$ -- explicitly ask the AstVisitor to handle all derived types of the TypePtr's
$ -- subtype.

$ av:visit(lookup "reflect::TypedPtr", function(decl)
$   local subtype = decl.args[1]:desugar()
$   local subdecl = subtype.decl
$   for derived in subdecl:allDerived() do
$     av:handleDecl(derived)
$   end
  /* -------------------------------------------------------------------------
   */
  $(comp.declare(decl))
  {
    if (data.ptr != nullptr && notnil(data.type))
    {
      self.compiled_pointers->push(
      {
        .offset = self.buffer->currentOffset(),
        .count = 1,
        .size = rtr::typeSizeFromTypeId(data.type),
        .type = data.type,
      });
    }

    self.buffer->writeT(data);
  }
$ end)


$ -- * ------------------------------------------------------------------------
$ -- Flags just write their raw value.

$ av:visit(lookup "iro::Flags", function(decl)
  /* -------------------------------------------------------------------------
   */
  $(comp.declare(decl))
  {
    self.buffer->writeT(data);
  }
$ end)

$ -- * ------------------------------------------------------------------------
$ -- Enums just write their raw value.

$ av:visit(ast.Enum, function(decl)
  /* -------------------------------------------------------------------------
   */
  $(comp.declare(decl))
  {
    self.buffer->writeT(data);
  }
$ end)

$ -- * ------------------------------------------------------------------------
$ -- Tell the AstVisitor to begin and only handle all top-level declarations 
$ -- marked with 'def' metadata.

$ av:begin(function(decl)
$   return decl.metadata.def ~= nil
$ end)

$ -- * ------------------------------------------------------------------------
$ -- Once we've visited everything, generate the runtime typeid dispatcher.

  /* -------------------------------------------------------------------------
   */
  void compileTypeId(rtr::TypeId type, const void* data)
  {
    switch (type.val)
    {
$ av:eachVisited(function(decl)
$   local name = decl.type.qname
    case "$(name)"_typeid_val:
      $(comp.call(decl))(*($(name)*)data);
      return;
$ end)
    }

    assert(!"unhandled typeid given to data compiler");
  }

};

/* ----------------------------------------------------------------------------
 */
b8 CompiledData::compile(const CompileParams& params)
{
  assert(notnil(params.type));
  assert(notnil(params.output_path));
  assert(params.dataptr != nullptr);

$ local function err(...)
$   return [[buildError(params.result, "while compiling '", ]]..
$     [[params.output_path, "': ", ]]..
$     cmn.joinArgs(',',...)..[[)]]
$ end

  // Attempt to open (and lock) the specified output file early such that 
  // any error with doing so is caught quickly.
  fs::File out_file = fs::File::createForTruncatedWriting(params.output_path);
  if (isnil(out_file))
    return @err("failed to open file");
  defer { out_file.close(); };

  auto failsafe_delete_outfile = deferWithCancel
  {
    fs::unlink(params.output_path);
  };

  // Create the buffer we will incrementally compile data into.
  // Remember, the memory of this moves. Do not attempt to keep a pointer 
  // to anything inside of this long term.
  mem::BinaryDataBuilder buffer;
  if (!buffer.init(1024))
    return @err("failed to initialize BinaryDataBuilder");
  defer { buffer.deinit(); };
  
  // Allocate and set up header info.
  {
    buffer.writeZeroedT<CompiledData>();

    auto* header = (CompiledData*)buffer.data.ptr;
    header->type = params.type;
    header->pointer_state = PointerState::Offset;
  }

  // Create the string table builder.
  mem::BinaryDataBuilder string_table;
  if (!string_table.init(1024))
    return @err("failed to initialize BinaryDataBuilder for string table");
  defer { string_table.deinit(); };

  // Create the arrays used to track special things found while compiling 
  // units of the data. These things are:
  // 
  // * Pointers. Since we need to compile each unit of data separately, we
  //   need to track what other units of data they point to so that we can
  //   compile them after we have finished the unit pointing to them.
  // 
  // * Strings. Similar to pointers, we need to store the content of Strings
  //   we find elsewhere. We store all string data in its own table.
  // 
  // * Links. Links to other assets are stored in their own array. This allows
  //   easy iteration of them once something loads the data we are compiling.
  CompiledStrings strings;
  CompiledPtrs pointers;
  CompiledLinks links;

  // On top of all of that, we want to keep all the pointers we find around.
  // Similar to links, we embed an array of pointers in the data so that 
  // we may automatically fix them on load.
  CompiledPtrs all_pointers;

  // Store the offset at which we are going to start writing the actual data.
  u64 data_start_offset = buffer.currentOffset();

  // Create a Compiler and prep it for building data.
  Compiler compiler;
  compiler.buffer = &buffer;
  compiler.strings = &string_table;
  compiler.compiled_strings = &strings;
  compiler.compiled_pointers = &pointers;
  compiler.compiled_links = &links;

  // Compile the root data.
  compiler.compileTypeId(params.type, params.dataptr);

  // Store the size of the root data.
  u64 root_size = buffer.currentOffset() - data_start_offset;

  // Process each layer of pointers following the root data.
  for (;;)
  {
    // Collect the pointers we currently have into `all_pointers`.
    // TODO(sushi) we could probably be more clever about this and always 
    //             collect pointers into `all_pointers`, and segement it 
    //             into current/next via offsets into it.
    for (auto& ptr : pointers)
      all_pointers.push(ptr);

    // Gather the next set of pointers into a separate array.
    CompiledPtrs next_pointers;
    compiler.compiled_pointers = &next_pointers;

    // Compile data that is pointed to by this type into their own units.
    for (auto& compiled_ptr : pointers)
    {
      // Get the address of the pointer and what it points to.
      void** pointer_addr = (void**)(buffer.data.ptr + compiled_ptr.offset);
      void* data_pointed_to = *pointer_addr;

      // Set the pointer to be an offset to the data we're about to write.
      OffsetPtr<void>::setPtrAsOffsetPtr(
        pointer_addr,
        (void*)(buffer.data.ptr + buffer.currentOffset()));

      // Compile each pointee.
      for (s32 i = 0; i < compiled_ptr.count; ++i)
      {
        void* pointee = (u8*)data_pointed_to + i * compiled_ptr.size;
        compiler.compileTypeId(compiled_ptr.type, pointee);
      }
    }

    // If we didn't find anymore pointers, then we're done compiling the 
    // data.
    if (next_pointers.isEmpty())
      break;
    
    // Otherwise, swap the new pointers into the current.
    next_pointers.move(&pointers);
  }

  // Store where in the data we're going to place the string table.
  u64 string_table_offset = buffer.currentOffset();

  // Set all Strings we found to be an offset to their location in the 
  // table.
  for (auto& str : strings)
  {
    auto* str_addr = (String*)(buffer.data.ptr + str.buffer_offset);

    // Get a String over the content we wrote to the table.
    auto content_in_table = String::from(
      buffer.data.ptr + string_table_offset + str.table_offset,
      str_addr->len);

    // Pun the String as an OffsetString and offset to its content.
    OffsetString::setStringAsOffsetString(str_addr, content_in_table);
  }

  // Store where the link table might be in data.
  u64 link_table_offset = string_table_offset + string_table.data.len;
  b8 has_links = !links.isEmpty();

  // Build the link table.
  mem::BinaryDataBuilder link_table;
  if (!link_table.init(1024))
    return @err("failed to initialize BinaryDataBuilder for link table");
  defer { link_table.deinit(); };

  link_table.writeZeroedArrayT<Link>(links.len);

  for (s32 i = 0; i < links.len; ++i)
  {
    // Compute where this Link will appear in the table.
    u64 link_offset_in_table = i * sizeof(Link);

    // Compute its absolute offset in the final data.
    u64 link_abs_offset = link_offset_in_table + link_table_offset;

    CompiledLink* compiled_link = &links[i];
    auto* link = (Link*)(link_table.data.ptr + link_offset_in_table);

    link->type = compiled_link->type;

    // Compute the offset from the link ptr's position in the compiled data
    // BACK to the actual data as it will be placed in the result.
    //
    // This may be visualized like so, given:
    //   d is the data buffer
    //   x is the data we want the link's pointer to offset to
    //   s is the string table
    //   r is the link table
    //   p is the link's pointer
    // 
    //  d    x     s       r  p
    //  |    |     |       |  |
    //       \________________/
    //
    // So, the link pointer's offset in the resulting link table, minus the 
    // offset of the data it wants to point to the in the data buffer.
    
    // The offset of the `ptr` field of `CompiledData::Link`.
    u64 link_ptr_offset = (u8*)&link->ptr - (u8*)link;

    // The offset of the `ptr` field in the final data.
    u64 link_ptr_abs_offset = link_abs_offset + link_ptr_offset;

    // The offset from the `ptr` field BACK to the data it wants to point at.
    u64 link_ptr_offset_to_data = link_ptr_abs_offset - compiled_link->offset;

    link->ptr.set((u8*)&link->ptr - link_ptr_offset_to_data);

    // Get the CompiledString who's content is the target of this link and
    // set the CompiledData::Link's target to point at it. 
    // This avoids needing to use runtime type info to figure out where the
    // `name` field of the Link type is. Ideally this is uniform among 
    // link types, but we no longer have them all inheriting from a common
    // base struct so we cannot guarantee that. 
    // 
    // At one point having all link types inherit from a base struct was a 
    // problem because it did not define the `name` field. I initially didn't
    // think that all link types (then called 'ref's) would use a String name
    // to identify their target. It wound up being that way though, so to make
    // things easier we should probably return to that eventually.
    CompiledString* compiled_name = 
      &strings[compiled_link->compiled_string_index];

    u64 compiled_name_offset = 
      compiled_name->table_offset + string_table_offset;
    
    // Similar to the above logic computing the offset from the `ptr` member
    // back to the link in data, we now compute the offset from the `target`
    // field back to the target name in the STRING TABLE.

    // The offset of the `target` field in `CompiledData::Link`.
    u64 link_target_offset = (u8*)&link->target - (u8*)link;

    // The offset of the `target` field in the final data.
    u64 link_target_abs_offset = link_abs_offset + link_target_offset;

    // The offset from the `target` field BACK to the target string in the 
    // STRING TABLE.
    u64 link_target_offset_to_string = 
      link_target_abs_offset - compiled_name_offset;
    
    // Get the String written to the buffer, since that is where its length
    // is stored.
    auto* str = (String*)(buffer.data.ptr + compiled_name->buffer_offset);

    // Finally, set the link's target to point at the target string in the 
    // string table.
    link->target.setSlice(
      (u8*)&link->target - link_target_offset_to_string,
      str->len);
  }

  // Store where we are going to write the pointer table in the data.
  u64 ptr_table_offset = link_table_offset + link_table.data.len;

  // Build the pointer table.
  mem::BinaryDataBuilder ptr_table;
  if (!ptr_table.init(256))
    return @err("failed to initialize BinaryDataBuilder for ptr table");
  defer { ptr_table.deinit(); };
  
  // We need to store the compiled pointers and String pointers.
  ptr_table.writeZeroedArrayT<Ptr>(
    all_pointers.len + strings.len);

  // Write compiled pointers.
  for (s32 i = 0; i < all_pointers.len; ++i)
  {
    // Compute where this Ptr will appear in the table.
    u64 ptr_offset_in_table = i * sizeof(Ptr);

    // Compute its absolute offset in the final data.
    u64 ptr_abs_offset = ptr_offset_in_table + ptr_table_offset;

    CompiledPtr* compiled_ptr = &all_pointers[i];
    auto* ptr = (Ptr*)(ptr_table.data.ptr + ptr_offset_in_table);

    // Similar calculations as above. Should make a helper.
    u64 ptr_ptr_offset = (u8*)&ptr->ptr - (u8*)ptr;
    u64 ptr_ptr_abs_offset = ptr_abs_offset + ptr_ptr_offset;
    u64 ptr_ptr_offset_to_ptr = ptr_ptr_abs_offset - compiled_ptr->offset;

    // Sorry.
    ptr->ptr.set((void**)((u8*)&ptr->ptr - ptr_ptr_offset_to_ptr));
  }

  // Write String pointers.
  for (s32 i = all_pointers.len; i < all_pointers.len + strings.len; ++i)
  {
    // Compute where this Ptr will appear in the table.
    u64 ptr_offset_in_table = i * sizeof(Ptr);

    // Compute its absolute offset in the final data.
    u64 ptr_abs_offset = ptr_offset_in_table + ptr_table_offset;

    s32 compiled_string_idx = i - all_pointers.len;

    CompiledString* compiled_str = &strings[compiled_string_idx];
    auto* ptr = (Ptr*)(ptr_table.data.ptr + ptr_offset_in_table);

    // Similar calculations as above. Should make a helper.
    u64 ptr_ptr_offset = (u8*)&ptr->ptr - (u8*)ptr;
    u64 ptr_ptr_abs_offset = ptr_abs_offset + ptr_ptr_offset;
    u64 ptr_ptr_offset_to_str = 
      ptr_ptr_abs_offset - compiled_str->buffer_offset;

    auto* str = (String*)(buffer.data.ptr + compiled_str->buffer_offset);

    // Offset to the `ptr` member of String. Likely 0, but just incase its 
    // ever moved.
    u64 str_ptr_offset = (u8*)&str->ptr - (u8*)str;

    u64 ptr_ptr_offset_to_str_ptr = ptr_ptr_offset_to_str + str_ptr_offset;

    // Sorry.
    ptr->ptr.set((void**)((u8*)&ptr->ptr - ptr_ptr_offset_to_str_ptr));
  }

  // Set the offset header data.
  auto* header = (CompiledData*)buffer.data.ptr;
  
  // Set the root slice, which is the compiled bytes spanning the data that
  // we were originally requested to compile.
  header->root.setSlice(
    buffer.data.ptr + data_start_offset, 
    root_size);

  // Set the slice spanning all data that we compiled (remember this includes
  // the root data).
  header->data.setSlice(
    buffer.data.ptr + data_start_offset,
    buffer.currentOffset() - data_start_offset);

  // The string table will be placed directly after the binary data.
  header->strings.setSlice(
    buffer.data.ptr + string_table_offset,
    string_table.data.len);

  // If we found any links, they are placed after the string table.
  header->links.setSlice(
    (Link*)(buffer.data.ptr + link_table_offset),
    links.len);

  // And finally write out the pointers we found, including the strings
  // pointers.
  header->pointers.setSlice(
    (Ptr*)(buffer.data.ptr + ptr_table_offset),
    all_pointers.len + strings.len);

  // Finally output all of the data to the output file.
  out_file.write(buffer.data);
  out_file.write(string_table.data);
  out_file.write(link_table.data);
  out_file.write(ptr_table.data);

  failsafe_delete_outfile.cancel();
  return true;
}

/* ----------------------------------------------------------------------------
 */
CompiledData* CompiledData::load(
    String path, 
    mem::Allocator* allocator,
    build::Result* result)
{
$ local function err(...)
$   return 
$     [[buildError(result, "while loading compiled data '", path, "': ", ]]..
$     cmn.joinArgs(',',...)..[[), nullptr]]
$ end

  assert(notnil(path) && allocator != nullptr);
  
  auto file = fs::File::openForRead(path);
  if (isnil(file))
    return @err("failed to open file");
  defer { file.close(); };

  fs::Stat stat;
  if (!fs::stat(path, &stat))
    return @err("failed to stat file for size");

  auto* data = (CompiledData*)allocator->allocate(stat.byte_size);
  file.read({(u8*)data, stat.byte_size});
  
  // If for some reason the loaded pointer state is not Offset, then
  // this must be corrupt data.
  if (data->pointer_state != PointerState::Offset)
    return @err("loaded data pointer state is not Offset");

  return data;
}

/* ----------------------------------------------------------------------------
 */
void CompiledData::fixPointers()
{
  if (pointer_state == PointerState::Absolute)
    return;

  for (Ptr& ptr : pointers.getSlice())
    *ptr.ptr.get() = OffsetPtr<void*>::getPtrAsOffsetPtr(ptr.ptr.get());

  pointer_state = PointerState::Absolute;
}

/* ----------------------------------------------------------------------------
 */
static void compiledDataGetPrereqs(const build::RuleParams_GetPrereqs& params)
{
  // Data targets need some SourceData to build, which should have the same 
  // name and type, but without the .data extension.
  build::Target* source_target = params.build_system->findOrCreateTarget(
    params.target->name,
    params.target->type.removeSuffix(".data"_str),
    build::TargetKind::SourceData);

  // Note the source target as a prereq.
  params.prereqs->insert(source_target);
}

/* ----------------------------------------------------------------------------
 */
static void compiledDataBuild(const build::RuleParams_Build& params)
{
   // Get the target we are building from, it should already exist.
  build::Target* source_target = params.build_system->findTarget(
    params.target->name, 
    params.target->type.removeSuffix(".data"_str),
    build::TargetKind::SourceData);

  assert(source_target != nullptr);

  fs::PathBuffer source_path_buffer;
  fs::PathBuffer target_path_buffer;

  String source_path = source_target->formFullPath(&source_path_buffer);
  String target_path = params.target->formFullPath(&target_path_buffer);

  // Load the source data file.
  // TODO(sushi) we should be passing in a build::Result here but that's 
  //             starting to cause build related stuff to intrude on most 
  //             systems. For tooling, we should experiment with iro providing
  //             a generic interface for emitting diagnostics that can be 
  //             passed around to all the tools in enosi and is not tied to 
  //             how some system would like them to work. Something similar 
  //             to how llvm's diagnostic consumer thing works.
  SourceDataFile sfile;
  if (!SourceDataFile::from(&sfile, source_path))
  {
    buildError(params.result, "failed to load source data file");
    return;
  }
  defer { sfile.deinit(); };

  PackedData packed;
  if (!packed.init())
  {
    buildError(params.result, "failed to initialied PackedData");
    return;
  }
  defer { packed.deinit(); };

  PackParams pack_params = 
  {
    .name = source_target->name,
    .packed = &packed,
    .result = params.result,
  };

  if (!packSourceDataFromType(*sfile.returned_data, pack_params))
    return; // error will have been emitted internally.

  CompiledData::CompileParams compile_params = 
  {
    .type = packed.type,
    .dataptr = packed.data.ptr,
    .output_path = target_path,
    .result = params.result,
  };

  if (!CompiledData::compile(compile_params))
    return;

  CompiledData* compiled = CompiledData::load(
    compile_params.output_path, 
    &params.build_system->compiled_data_allocator,
    params.result);

  if (compiled == nullptr)
    return;

  compiled->fixPointers();

  for (CompiledData::Link& link : compiled->links.getSlice())
  {
    String def_links = rtr::getMetadataValue(link.type, "links"_str);

    if (isnil(def_links))
      continue;

    String::Pair split = def_links.splitAtFirst(';');

    for (;;)
    {
      build::Target* links_target = params.build_system->findOrCreateTarget(
        link.target.getString(),
        split.first,
        build::TargetKind::Unknown);

      params.target->links(links_target);

      if (isnil(split.second))
        break;

      split = split.second.splitAtFirst(';');
    }
  }
}

/* ----------------------------------------------------------------------------
 */
build::Rule CompiledData::getBuildRule()
{
  return 
  {
    .types = "data"_str,
    .interface = 
    {
      .getPrereqs = compiledDataGetPrereqs,
      .build = compiledDataBuild,
    }
  };
}

}
