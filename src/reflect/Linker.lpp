$ local cmn = require "common"
$ local ast = require "reflect.ast"

#include "iro/print.h"

$$$ 

local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/**/*.defs.lh",
  "src/**/*.comp.lh",
  "src/**/*.resource.lh",
}

local function lookup(s)
  return astctx:lookupDecl(s)
end

local ResourceLink = astctx:lookupTypeDecl "gfx::ResourceLink"
local CompiledDataLink = astctx:lookupDecl "reflect::CompiledDataLink"
local AssetLink = astctx:lookupDecl "AssetLink"

local av = require "reflect.AstVisitor" .new(astctx)

$$$ 
$(imported)

@lpp.import "graphics/ResourceMgr.lh"
@lpp.import "asset/AssetMgr.lh"

@log.import

@[link] av:funcgen(
  link_,
  b8,
  %* data)

namespace reflect
{

/* ============================================================================
 */
struct Linker
{
  gfx::ResourceMgr& resource_mgr;
  AssetMgr& asset_mgr;

  iro::Array<Asset*> loaded_compiled_data_assets;

$ -- * ------------------------------------------------------------------------

$ local function link_stub(node)
  $(link.declare(node))
  {
    // stub
    return true;
  }
$ end

$ av:previsit(ast.iro_builtins, link_stub)
$ av:visit(lookup "iro::utf8::String", link_stub)
$ av:visit(ast.Enum, link_stub)
$ av:visit(lookup "iro::Flags", link_stub)

$ -- * ------------------------------------------------------------------------

$ av:visit(ast.Struct, function(decl)
  /* --------------------------------------------------------------------------
   */
  $(link.declare(decl))
  {
$ for field in decl:allFields() do
$   -- NOTE(sushi) some types we encounter here use void* as handles
$   --             (currently just gfx object types, like Shader) and for 
$   --             now they just specify 'metadata.no_link' instead of us 
$   --             explicitly checking for pointers here.
$   if not field.metadata.no_link then
    if (!$(link.call(field.type))(&data->$(field.name)))
      return false;
$   else
    // Field $(field.name) marked 'no_link'.
$   end
$ end
    return true;
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "reflect::Array", function(decl)
$   local subtype = decl.args[1]
  /* --------------------------------------------------------------------------
   */
  $(link.declare(decl))
  {
    for (auto& elem : *data)
    {
      if (!$(link.call(subtype))(&elem))
        return false;
    }
    return true;
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ local function putAssetLinker(decl)
$   local link_type = decl.metadata.links
$   if not link_type then
$     clog.warn("asset link type ", decl.qname, " does not specify what ",
$               "asset type it links")
$   end
  /* --------------------------------------------------------------------------
   *  Generic asset.
   */
  $(link.declare(decl))
  {   
    if (isnil(data->name))
      return true; // Nothing to link.

    data->asset = asset_mgr.loadAssetFromDisk(data->name, "$(link_type)"_str);

    if (data->asset == nullptr)
      return @log.error(reflect,
        "failed to load generic asset '", data->name, 
        "' of type $(link_type)");
    
    return true;
  }
$ end

$ -- * ------------------------------------------------------------------------

$ local function putCompiledDataLinker(decl)
$   local link_type = decl.metadata.links
$   if not link_type then
$     clog.warnln("compiled asset link type ", decl.qname, " does not ",
$                 "specify what asset type it links")
$   end
  /* --------------------------------------------------------------------------
   *  A CompiledData link.
   */
  $(link.declare(decl))
  {
    if (isnil(data->name))
      return true; // Nothing to link.

    // Load the CompiledData through the asset manager.
    data->asset = asset_mgr.loadAssetFromDisk(data->name, "$(link_type)"_str);

    if (data->asset == nullptr)
      return @log.error(reflect,
        "failed to link compiled data '", data->name, "' of type "
        "$(link_type)");
    
    // Check if we've already linked embedded links of this data.
    for (Asset* already_done : loaded_compiled_data_assets)
    {
      if (already_done == data->asset)
      {
        @log.debug(rflnk, "  already linked");
        return true;
      }
    }

    loaded_compiled_data_assets.push(data->asset);

    // Get the CompiledData.
    CompiledData* compiled = &data->get();

    // Fix its pointers.
    compiled->fixPointers();

    // Link any embedded links.
    for (CompiledData::Link& link : compiled->links.getSlice())
    {
      if (!linkByTypeId(link.type, link.ptr.get()))
        return @log.error(reflect,
          "failed to link embedded link in compiled data '", data->name, "'");
    }

    return true;
  }
$ end

$ -- * ------------------------------------------------------------------------

$ local function putResourceLinker(decl)
$   local function getResourceType(decl)
$     if decl:is(ast.TemplateSpec) then
$       if decl.specialized.qname == "gfx::TypedResourceLink" then
$         return decl.args[1]
$       end
$     end
$     if decl.base then
$       return getResourceType(decl.base)
$     end
$   end
$   local resource_type = getResourceType(decl)
$   if not resource_type then
$     error("failed to find resource type from "..decl.qname)
$   end
$   local resource_decl = resource_type.decl
$   local rname = resource_decl.name
$   local rtname = resource_decl.type.name
$   av:handleType(resource_type)
  /* --------------------------------------------------------------------------
   *  A Resource link.
   */
  $(link.declare(decl))
  {
    if (isnil(data->name))
      return true; // Nothing to link.

    if (data->resource != nullptr)
      return true; // Already linked (?).

    data->resource = resource_mgr.find$(rname)(data->name);
    if (data->resource != nullptr)
      return true; // Already in resource manager.

    data->resource = resource_mgr.getOrCreate$(rname)(data->name);

    auto* r = ($(rtname)*)data->resource;

    // Set nested links to reference what the data wants.
    // NOTE(sushi) this feels finnicky, might break.
$   for field in resource_decl:allFields() do
$     local field_type = field.type:desugar()
$     if field_type:is(ast.TagType) and field_type.decl:is(ast.Record) then
$       if field_type.decl:findMetadata "ref" then
    r->$(field.name).name = data->name;
$       end
$     end
$   end

    // Link any internals the Resource may have.
    if (!$(link.call(resource_type))(r))
      return @log.error(reflect, "failed to link resource $(rname)");
    
    // Ask the resource manager to load the resource.
    if (!resource_mgr.load$(rname)(r))
      return @log.error(reflect, "failed to load resource $(rname)");

    return true;
  }
$ end

$ -- * ------------------------------------------------------------------------

$ local function maybePutSpecialLinker(decl, real_decl)
$   if decl:isDerivedFrom(CompiledDataLink) then
$     putCompiledDataLinker(real_decl)
$     return true
$   elseif decl:isDerivedFrom(ResourceLink) then
$     putResourceLinker(real_decl)
$     return true
$   elseif decl:isDerivedFrom(AssetLink) then
$     putAssetLinker(real_decl)
$     return true
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ av:previsit(ast.Record, function(decl)
$   if not decl:findMetadata "ref" then
$     return
$   end
$   
$   maybePutSpecialLinker(decl, decl)
$
$   return av.handled
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(ast.TypedefDecl, function(decl)
$   -- Check if this typedef is wrapping a link type, as if it is then it 
$   -- might be specifying a different `links` metadata. At the moment,
$   -- this only happens with CompiledFontLink, as it needs to link 
$   -- `font.texture.compiled` rather than `texture.compiled` as the type
$   -- it wraps, CompiledTextureLink, specifies.
$   local real_decl = decl
$   decl = decl.subtype:desugar().decl
$   if decl then
$     if maybePutSpecialLinker(decl, real_decl) then
$       return
$     end
$   end
  /* --------------------------------------------------------------------------
   */
  $(link.declare(real_decl))
  {
    return $(link.call(real_decl.subtype))(data);
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "reflect::StringMap", function(decl)
$   local subtype = decl.args[1]
  /* --------------------------------------------------------------------------
   */
  $(link.declare(decl))
  {
    for (auto& slot : *data)
    {
      if (slot.hash == 0)
        continue;

      if (!$(link.call(subtype))(&slot.elem))
        return false;
    }

    return true;
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "reflect::TypedPtr", function(decl)
$   local subtype = decl.args[1]
$   local subdecl = subtype.decl
$   for derived in subdecl:allDerived() do
$     av:handleDecl(derived)
$   end
  /* --------------------------------------------------------------------------
   */
  $(link.declare(decl))
  {
    switch (data->type.val)
    {
$   for derived in subdecl:allDerived() do
    case "$(derived.qname)"_typeid_val:
      if (!$(link.call(derived))(data->getAs<$(derived.qname)>()))
        return false;
      break;
$   end
    default:
      return @log.error(reflect,
        "invalid type encountered while linking $(decl.qname)");
    }
    return true;
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:begin(function(decl)
$   return decl.metadata.def ~= nil or decl.metadata.links ~= nil
$ end)

  /* --------------------------------------------------------------------------
   */
  b8 linkByTypeId(rtr::TypeId type, void* data)
  {
    switch (type.val)
    {
$ av:eachVisited(function(decl)
$   local qname = decl.type.qname
    case "$(qname)"_typeid_val:
      return $(link.call(decl))(($(qname)*)data);
$ end)
    default:
      @dbgBreak;
      return @log.error(reflect,
        "unhandled type passed to linkByTypeId");
    }
  }
};

/* ----------------------------------------------------------------------------
 */
b8 linkData(
    rtr::TypeId type, 
    void* data, 
    gfx::ResourceMgr& resource_mgr, 
    AssetMgr& asset_mgr)
{
  Linker linker = { .asset_mgr = asset_mgr, .resource_mgr = resource_mgr };
  linker.loaded_compiled_data_assets.init();
  defer { linker.loaded_compiled_data_assets.destroy(); };

  return linker.linkByTypeId(type, data);
}

}
