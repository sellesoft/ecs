$ local cmn = require "common"

#include "iro/containers/SmallArray.h"
#include "iro/memory/Bump.h"

@@lpp.import "reflect/TypeId.lh"

struct SourceData;;

namespace gfx
{
struct Renderer;
}

namespace iro::io
{
struct IO;
}

namespace reflect
{


/* ============================================================================
 *  The result of packing some data. This contains the raw bytes of the 
 *  packed data as well as a buffer containing any other data that needs 
 *  to live as long as the packed data.
 */
struct PackedData
{
  // The raw packed data. This points into the 'buffer' where the resulting 
  // data was packed.
  iro::Bytes data;

  // A buffer containing the packed data as well as any other data that 
  // must live for as long as the resulting packed data, primarily strings 
  // and arrays.
  iro::mem::LenientBump buffer;

  // Id of the type that was packed. 
  rtr::TypeId type;

  // Small helper for getting the packed data as the given type. Note that 
  // there is no checking for if the requested type matches that which was 
  // packed. So be careful!
  // TODO(sushi) implement proper checks if that ever winds up being a 
  //             problem.
  template<typename T>
  T* getDataAs() const
  {
    return (T*)data.ptr;
  }

  // TODO(sushi) we could prob support passing in an allocator here.
  b8 init()
  {
    data = nil;
    
    return buffer.init();
  }

  void deinit()
  {
    data = nil;
    buffer.deinit();
  }
};

/* ============================================================================
 */
struct PackParams
{
  PackedData* packed;
  build::Result* result;
};

// Packs some SourceData based on what its type value is.
b8 packSourceDataFromType(const SourceData& data, PackParams& ctx);

}
