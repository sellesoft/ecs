/*
 *  Implementation of packing routines for types that come from defs/comp 
 *  headers. 
 *
 *  'Packing' data refers to taking some SourceData and a desired C/C++ type 
 *  and transforming the SourceData into binary data of that type.
 */

$ require "common"
$ local minfo = require "math.info"

$$$
local astctx, imported = require "reflect.AstContext" .fromGlobs 
{ 
  "src/**/*.defs.lh",
  "src/**/*.comp.lh"
}
local ast = require "reflect.ast"
local AstVisitor = require "reflect.AstVisitor"
local av = AstVisitor.new(astctx)
local function ld(name)
  return astctx:lookupDecl(name)
end
$$$
$(imported)

@log.import

@lpp.import "reflect/Packing.lh"

@lpp.import "asset/AssetMgr.lh"
@lpp.import "sdata/SourceData.lh"
@lpp.import "sdata/SourceDataFile.lh"
@lpp.import "sdata/SourceDataParser.lh"
@lpp.import "build/Result.lh"

@lpp.import "reflect/types/Array.lh"

#include "iro/containers/BitArray.h"
#include "stdlib.h"

$ local function markHasDefaults(decl)
$   decl.metadata.has_defaults = true
$   for used_in in decl.used_in:each() do
$     markHasDefaults(used_in)
$   end
$ end

$ for decl in astctx.type_decls:each() do
$   if decl:is(ast.Record) then
$     for field in decl:eachField() do
$       if field.metadata.default then
$         markHasDefaults(decl)
$         break
$       end
$     end
$   end
$ end

namespace reflect
{

/* ----------------------------------------------------------------------------
 */
template<typename... Args>
b8 buildError(build::Result* result, Args... args)
{
  if (result != nullptr)
    result->pushError(args...);
  else
    @log.error(reflect, args...);
  return false;
}

@[f] av:funcgen(
  pack_,
  b8,
  const SourceData& data,
  %* out)

/* ============================================================================
 */
struct Packer
{
  String name;

  PackedData* packed;

  // A SourceDataFile that's used to cache parsed defaults for fields that 
  // have default metadata.
  SourceDataFile defaults_cache;

  // When provided, points to a build::Result that errors will be output
  // to rather than normal logging.
  build::Result* result;

  template<typename... Args>
  b8 error(const SourceData& data, Args... args)
  {
    return buildError(result, 
      tcolor::red, name, tcolor::reset, 
      ':', data.line, ':', data.column, ": ",
      args...);
  }

  /* --------------------------------------------------------------------------
   */
  b8 hasUnnamedData(const SourceData& data)
  {
    assert(data.hasObjectData());

    if (data.hasChildren())
    {
      for (u32 i = 1; i < data.children.len; ++i)
      {
        if (isnil(data.children[i]->name))
          return true;
      }
    }

    return false;
  }

$ local function kindCheckVal(data, kind, for_what)
  if (!($(data))->has$(kind)Value())
    return error(*$(data), "expected $(kind) value for $(for_what)");
$ end

$ local function markNoDefaults(decl_or_type)
$   decl_or_type.astv.no_defaults = true
$ end

$ -- * ------------------------------------------------------------------------

$ av:previsit(ast.iro_builtins, function(type)
  /* --------------------------------------------------------------------------
   */
  $(f.declare(type))
  {
$   if type == ast.builtins.b8 then
    @kindCheckVal(&data, Boolean, b8);
    *out = data.testBooleanValue();
$   else
    @kindCheckVal(&data, Number, $(type.name));
$   -- TODO(sushi) do this better
$     if type.name ~= "f32" and type.name ~= "f64" then
$       local max = "MAX_"..type.name:upper()
$       local min 
$       if type.name:find "^s" then
$         min = "MIN_"..type.name:upper()
$       else
$         min = "0"
$       end
    s64 val = strtoll((char*)data.val.str.ptr, nullptr, 10);
    if (val < $(min) || val > $(max))
      return error(data, "cannot pack value ", val, " into $(type.name)");
    *out = val;
$     else
    *out = strtof((char*)data.val.str.ptr, nullptr);
$     end
$ end
    return true;

  }
$  return handled
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(ld "iro::utf8::String", function(decl)
$   markNoDefaults(decl)
  /* --------------------------------------------------------------------------
   */
  $(f.declare(decl))
  {
    if (!data.hasStringValue())
      return error(data, "expected string value to pack String");

    *out = data.val.str.allocateCopy(&packed->buffer);

    return true;
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(ld "StringHash", function(decl)
$   markNoDefaults(decl)
  /* --------------------------------------------------------------------------
   */
  $(f.declare(decl))
  {
    if (!data.hasStringValue())
      return error(data, "expected a string value to pack StringHash");

    out->val = data.val.str.hash();

    return true;
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(minfo.getVecDecls(astctx), function(decl)
$   markNoDefaults(decl)
$   local subtype = decl:findMember "T"
  /* --------------------------------------------------------------------------
   */
  $(f.declare(decl))
  {
    if (!data.hasChildren())
      return error(data, "expected an object to pack vec2");

    if (data.children.len != 2)
      return error(data, 
        "expected 2 components to pack vec2 (got ", data.children.len, ")");

    const SourceData* x = nullptr;
    const SourceData* y = nullptr;

    for (SourceData* child : data.children)
    {
      if (isnil(child->name))
        return error(*child, "vec2 fields must be named");

      if (child->name == "x"_str)
      {
        if (x != nullptr)
          return error(*child, "vec2::x specified twice");
        x = child;
      }
      else if (child->name == "y"_str)
      {
        if (y != nullptr)
          return error(*child, "vec2::y specified twice");
        y = child;
      }
      else
        return error(*child, "no field named '", child->name, "' in vec2");
    }

    if (!$(f.call(subtype))(*x, &out->x))
      return false;

    if (!$(f.call(subtype))(*y, &out->y))
      return false;

    return true;
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(ld "Rect", function(decl)
$   markNoDefaults(decl)
  /* --------------------------------------------------------------------------
   */
  $(f.declare(decl))
  {
    if (!data.hasObjectData())
      return error(data, "expected object data to pack Rect");

    if (data.children.len != 4)
      return error(data, 
        "expected 4 components to pack Rect (got ", data.children.len, ")");

    const SourceData* x = data.findChildByName("x"_str);
    const SourceData* y = data.findChildByName("y"_str);
    const SourceData* w = data.findChildByName("w"_str);
    const SourceData* h = data.findChildByName("h"_str);

    if (matchAny(nullptr, x, y, w, h))
    {
      for (SourceData* child : data.children)
      {
        if (isnil(child->name))
          error(*child, "Rect fields must be named");
        else if (!matchAny(child->name, "x"_str, "y"_str, "w"_str, "h"_str))
          error(*child, child->name, " is not a field of Rect");
      }
      return false;
    }

    if (!pack_f32(*x, &out->x))
      return false;

    if (!pack_f32(*y, &out->y))
      return false;

    if (!pack_f32(*w, &out->w))
      return false;

    if (!pack_f32(*h, &out->h))
      return false;

    return true;
  }
$ end)

$ -- * ------------------------------------------------------------------------
$ -- TODO(sushi) once editing SourceData in the editor works well, remove 
$ --             the ability to use hex values for Colors like nameless
$ --             stuff was removed for vec/Rect. SourceData needs to be 
$ --             consistent to make dealing with it everywhere else not
$ --             so annoying.

$ av:visit(ld "Color", function(decl)
$   markNoDefaults(decl)
  /* --------------------------------------------------------------------------
   */
  $(f.declare(decl))
  {
    if (data.hasNumberHexValue())
    {
      // TODO(sushi) detect when the hex value does not include alpha and 
      //             default it to 'ff'.
      *out = strtoll((char*)data.val.str.ptr, nullptr, 16);
      return true;
    }

    if (!data.hasObjectData())
      return error(data, "expected object data or hex number to pack Color");

    if (data.children.len > 4)
      return error(data,
        "too many Color components (can specify up to 4, got ",
        data.children.len, ")");

    const SourceData* r = data.findChildByName("r"_str);
    const SourceData* g = data.findChildByName("g"_str);
    const SourceData* b = data.findChildByName("b"_str);
    const SourceData* a = data.findChildByName("a"_str);

    if (matchAny(nullptr, r, g, b))
    {
      for (SourceData* child : data.children)
      {
        if (isnil(child->name))
          error(*child, "Color fields must be named");
        else
          error(*child, child->name, " is not a field of Color");
      }
      return error(data, "Color data must specify at least r, g, and b");
    }

$ local function checkval(c)
    s64 $(c)_val = strtoll((char*)$(c)->val.str.ptr, nullptr, 10);
    if ($(c)_val < 0 || $(c)_val > 255)
      return error(*$(c), 
        "cannot pack value ", $(c)_val, " into Color::$(c) (a u8)");
    out->$(c) = (u8)$(c)_val;
$ end

    @checkval(r)
    @checkval(g)
    @checkval(b)

    if (a != nullptr)
    {
      @checkval(a)
    }
    else
    {
      out->a = 255;
    }

    return true;
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(ast.Enum, function(decl)
$   markNoDefaults(decl)
  /* --------------------------------------------------------------------------
   */
  $(f.declare(decl))
  {
    if (!data.hasStringValue())
      return error(data, "expected a string value to pack enum $(decl.qname)");

    switch (data.val.str.hash())
    {
$   for elem in decl.elems:each() do
    case "$(elem.name)"_hashed:
$     if not elem.metadata.hidden then
      *out = $(decl.type.qname)::$(elem.name);
      break;
$     else
      return error(data, 
        "enum constant $(decl.qname)::$(elem.name) is marked hidden and "
        "so cannot be used in data");
$     end
$   end
    default:
      return error(data, 
        "no constant named '", data.val.str, "' in enum $(decl.qname)");
    }

    return true;
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(ast.Struct, function(decl)
$   local TFoundFields = decl:formCSafeName().."_FoundFields"

  typedef BitArray<$(decl:countAllFields())> $(TFoundFields);

  @[sdef] av:funcgen(
    _pack_struct_defaults_,
    b8,
    %* out,
    const $(TFoundFields)& found_fields)

  @[simpl] av:funcgen(
    _pack_struct_impl_,
    b8,
    const SourceData& data,
    %* out,
    $(TFoundFields)* found_fields)

  /* --------------------------------------------------------------------------
   */
  $(sdef.declare(decl))
  {
$ local function handleFieldDefault(field, record)
$   local default_aux_name = record.qname.."::"..field.name
    SourceData* default_data = 
      defaults_cache.findAuxData("$(default_aux_name)"_str);

    if (default_data == nullptr)
    {
      auto view = io::RBytes::from("$(field.metadata.default)"_str);

      default_data = parsePossiblyTypedAuxData(
        &defaults_cache,
        &view,
        "$(default_aux_name) default"_str,
        "$(default_aux_name)"_str);

      if (default_data == nullptr)
        return false;
    }

    if (!$(f.call(field.type))(*default_data, &out->$(field.name)))
      return false;
$ end

$ local function handleNestedDefaults(field, record, type_decl)
    if (!$(sdef.call(type_decl))(&out->$(field.name), {}))
      return false;
$ end

$ decl:allFieldsWithIndex(function(field, record, i)
$   if field.metadata.hidden then
$     return
$   end
$   local handler
$   local field_type_decl
$   if field.metadata.default then
$     handler = handleFieldDefault
$   else
$     local ft = field.type:desugar()
$     if ft:is(ast.TagType) and ft.decl:is(ast.Record) and
$        ft.decl.metadata.has_defaults 
$     then
$       handler = handleNestedDefaults
$       field_type_decl = ft.decl
$     end
$   end
$   if handler then
    if (!found_fields.test($(i - 1)))
    {
$     handler(field, record, field_type_decl)
    }
$   end
$ end)
    return true;
  }

  /* --------------------------------------------------------------------------
   */
  $(simpl.declare(decl))
  {
    for (const SourceData* child : data.children)
    {
      if (isnil(child->name))
        return error(*child, "struct field data must be named");

$ -- Pulled out because its quite an eyesore when this is in the switch
$ -- below.
$ local function callFieldPacker(field, record, i)
    if (!$(f.call(field.type))(*child, &out->$(field.name)))
      return error(*child, 
        "failed to pack field $(record.qname)::$(field.name)");
    found_fields->set($(i-1));
$ end

      switch (child->name.hash())
      {
$   for field, record, i in decl:allFieldsWithIndex() do
      case "$(field.name)"_hashed:
$     if not field.metadata.hidden then
$       callFieldPacker(field, record, i)
        break;
$     else
        return error(*child, 
          "field $(decl.qname)::$(field.name) is marked hidden");
$     end
$   end
      default:
        return error(*child,
          "$(decl.qname) has no field '", child->name, "'");
      }
    }

    if (data.base != nullptr)
    {
      if (!$(simpl.call(decl))(*data.base, out, found_fields))
        return error(data, "failed to pack base data");
    }

    return true;
  }

  /* --------------------------------------------------------------------------
   */
  $(f.declare(decl))
  {
    if (!data.hasObjectData() && data.base == nullptr)
      return error(data, "expected object data to pack struct $(decl.qname)");

    mem::zero(out, sizeof($(decl.qname)));

    $(TFoundFields) found_fields;

    if (!$(simpl.call(decl))(data, out, &found_fields))
      return false;

    if (!$(sdef.call(decl))(out, found_fields))
      return error(data, "failed to pack defaults of struct $(decl.qname)");

    return true;
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(ld "iro::Flags", function(decl)
$   local subtype = decl.args[1]:desugar()
$   local subdecl = subtype.decl
$   if not subdecl then
$     error("failed to get declaration from Flags type "..subtype.name)
$   end
  /* --------------------------------------------------------------------------
   */
  $(f.declare(decl))
  {
    if (!data.hasObjectData())
      return error(data, 
        "expected a list of strings to pack $(decl.type.qname)");

    for (const SourceData* child : data.children)
    {
      if (notnil(child->name))
        return error(*child, "elements of $(decl.type.qname) cannot be named");

      if (!child->hasStringValue())
        return error(*child, 
          "expected a string to pack flag of $(decl.type.qname)");

      switch (child->val.str.hash())
      {
$   for elem in subdecl.elems:each() do
      case "$(elem.name)"_hashed:
$     if not elem.metadata.hidden then
        out->set($(subdecl.qname)::$(elem.name));
        break;
$     else
        return error(*child, 
          "enum constant $(subtype.qname)::$(elem.name) is marked hidden");
$     end
$   end
      default:
        return error(*child,
          "no element named '", child->val.str, "' in $(decl.qname)");
      }
    }

    return true;
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(ld "reflect::Array", function(decl)
$   local subtype = decl.args[1]
  /* --------------------------------------------------------------------------
   */
  $(f.declare(decl))
  {
    if (!data.hasObjectData())
      return error(data, "expected object data to pack $(decl.type.qname)");

    s32 child_count = data.children.len;

    if (!out->init(child_count, &packed->buffer))
      return error(data, "failed to initialize $(decl.type.qname)");

    for (s32 i = 0; i < child_count; ++i)
    {
      const SourceData* child = data.children[i];
      if (notnil(child->name))
        return error(*child, "array elements cannot have names");

      if (!$(f.call(subtype))(*child, &(*out)[i]))
        return error(*child, "failed to pack [", i, "] of $(decl.type.qname)");
    }

    return true;
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(ld "reflect::StringMap", function(decl)
$   local subtype = decl.args[1]
  /* --------------------------------------------------------------------------
   */
  $(f.declare(decl))
  {
    if (!data.hasObjectData())
      return error(data, "expected object data to pack $(decl.type.qname)");

    if (!out->init(data.children.len, &packed->buffer))
      return error(data, "failed to initialize $(decl.type.qname)");

    for (const SourceData* child : data.children)
    {
      if (isnil(child->name))
        return error(*child, "StringMap children must be named");

      auto* elem = out->add(child->name);

      if (!$(f.call(subtype))(*child, elem))
        return error(*child, "failed to pack key ", child->name);
    }

    return true;
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(ld "reflect::TypedPtr", function(decl)
$   local subtype = decl.args[1]:desugar()
$   local subdecl = subtype.decl
$   for derived in subdecl:allDerived() do
$     av:handleDecl(derived)
$   end
  /* --------------------------------------------------------------------------
   */
  $(f.declare(decl))
  {
    if (isnil(data.type))
      return error(data, 
        "TypedPtr data must be typed as a derived struct of $(subtype.name)");

    switch (data.type.hash())
    {
    case "$(subtype.name)"_hashed:
      return error(data, 
        "TypedPtr data cannot have the base type $(subtype.name)");

$   for derived in subdecl:allDerived() do
    case "$(derived.qname)"_hashed:
      out->ptr = packed->buffer.allocateType<$(derived.qname)>();
      if (out->ptr == nullptr)
        return error(data, 
          "failed to allocate data for TypedPtr<$(derived.qname)>");
      out->type = "$(derived.qname)"_typeid;

      if (!$(f.call(derived))(data, ($(derived.qname)*)out->ptr))
        return error(data, "failed to pack TypedPtr as $(derived.qname)");
      break;
$   end

    default:
      return error(data,
        "type '", data.type, "' is not a known subtype of $(subtype.name)");
    }

    return true;
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:previsit(ast.Record, function(decl)
$   if not decl:findMetadata "ref" then
$     return
$   end
  /* --------------------------------------------------------------------------
   */
  $(f.declare(decl))
  {
    if (!data.hasStringValue())
      return error(data,
        "expected string data to pack link type $(decl.type.qname)");

    out->name = data.val.str.allocateCopy(&packed->buffer);

    return true;
  }

$   return av.handled
$ end)

$ av:visit(ast.TypedefDecl, function(decl)
  /* --------------------------------------------------------------------------
   */
  $(f.declare(decl))
  {
    // Typedefs just passthrough to their subtype for now.
    return $(f.call(decl.subtype))(data, ($(decl.subtype.qname)*)out);
  }
$ end)

$ av:begin(function(decl)
$   return decl.metadata.def ~= nil
$ end)

};

/* ----------------------------------------------------------------------------
 */
b8 packSourceDataFromType(const SourceData& data, PackParams& ctx)
{
  if (isnil(data.type))
    return buildError(ctx.result, 
      "packSourceDataFromType passed untyped data");

  Packer packer;
  packer.name   = ctx.name;
  packer.packed = ctx.packed;
  packer.result = ctx.result;

  PackedData* packed = packer.packed;

  if (!packer.defaults_cache.init())
    return buildError(ctx.result, 
      "failed to initialize packer defaults cache");
  defer { packer.defaults_cache.deinit(); };

  switch (data.type.hash())
  {
$ av:eachVisited(function(decl)
$   local name = decl.type.qname
  case "$(name)"_hashed:
    packed->data.ptr = (u8*)packed->buffer.allocateType<$(name)>();
    if (!packer.$(f.call(decl))(data, ($(name)*)packed->data.ptr))
      return false;
    packed->type = rtr::TypeId::fromString(data.type);
    break;
$ end)
  default:
    return buildError(ctx.result,
      "data given to packSourceDataFromType specifies unhandled type: ",
      data.type);
  }

  return true;
}

}
