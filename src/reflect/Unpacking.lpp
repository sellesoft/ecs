$ require "common"
$ local ast = require "reflect.ast"
$ local minfo = require "math.info"

$$$

local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/**/*.defs.lh",
  "src/**/*.comp.lh",
}

local av = require "reflect.AstVisitor" .new(astctx)

local function lookup(s)
  return astctx:lookupDecl(s)
end 

$$$
$(imported)

@log.import

@lpp.import "reflect/Unpacking.lh"

@lpp.import "reflect/Packing.lh"
@lpp.import "build/Result.lh"

namespace reflect
{

template<typename... Args>
b8 buildError(build::Result* result, Args... args)
{
  if (result != nullptr)
    result->pushError(args...);
  else
    @log.error(reflect, args..., '\n');
  return false;
}

/* ============================================================================
 */
struct Unpacker
{
  SourceDataFile* sfile;
  
  build::Result* result;

  template<typename... Args>
  b8 error(Args... args)
  {
    return buildError(result, args...);
  }

@[unpack] av:funcgen(
  unpack_,
  void,
  const %& data,
  SourceData* sdata)

$ -- * ------------------------------------------------------------------------

$$$

local builtin_setter = 
{
  [ast.builtins.u8]  = "setUIntValue",
  [ast.builtins.u16] = "setUIntValue",
  [ast.builtins.u32] = "setUIntValue",
  [ast.builtins.u64] = "setUIntValue",
  [ast.builtins.s8]  = "setIntValue",
  [ast.builtins.s16] = "setIntValue",
  [ast.builtins.s32] = "setIntValue",
  [ast.builtins.s64] = "setIntValue",
  [ast.builtins.f32] = "setNumberValue",
}

$$$

$ av:previsit(ast.iro_builtins, function(type)
  /* --------------------------------------------------------------------------
   */
  $(unpack.declare(type))
  {
$   if type == ast.builtins.b8 then
    sdata->setBooleanValue(data);
$   else
    sdata->$(builtin_setter[type])(*sfile, data);
$   end
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "iro::utf8::String", function(decl)
  /* --------------------------------------------------------------------------
   */
  $(unpack.declare(decl))
  {
    sdata->setStringValue(*sfile, data);
  }
$ end)

$ -- * ------------------------------------------------------------------------

$$$

local vec_setters = 
{
  [lookup "vec2f"] = "setVec2f",
  [lookup "vec2i"] = "setVec2i",
  [lookup "vec2u"] = "setVec2u",
}

$$$

$ av:visit(minfo.getVecDecls(astctx), function(decl)
  /* --------------------------------------------------------------------------
   */
  $(unpack.declare(decl))
  {
    sdata->$(vec_setters[decl])(*sfile, data); 
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "StringHash", function(decl)
  /* --------------------------------------------------------------------------
   */
  $(unpack.declare(decl))
  {
    sdata->setUIntValue(*sfile, data.val);
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "Color", function(decl)
  /* --------------------------------------------------------------------------
   */
  $(unpack.declare(decl))
  {
    sdata->setObject(nil);
    sdata->addUIntValue(*sfile, "r"_str, data.r);
    sdata->addUIntValue(*sfile, "g"_str, data.g);
    sdata->addUIntValue(*sfile, "b"_str, data.b);
    sdata->addUIntValue(*sfile, "a"_str, data.a);
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(ast.Enum, function(decl)
  /* --------------------------------------------------------------------------
   */
  $(unpack.declare(decl))
  {
    switch (data)
    {
$   for elem in decl.elems:each() do
$     if not elem.metadata.hidden then
    case $(decl.qname)::$(elem.name):
      sdata->setStringValue(*sfile, "$(elem.name)"_str);
      break;
$     end
$   end
    }
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(ast.Struct, function(decl)
  /* --------------------------------------------------------------------------
   */
  $(unpack.declare(decl))
  {
    sdata->setObject(nil);

$   local function unpackField(field, record) 
    {
      SourceData* child_data = sdata->addData(
        *sfile,
        "$(field.name)"_str,
        "$(field.type.qname)"_str);

      $(unpack.call(field.type))(data.$(field.name), child_data);
    }
$   end

$   if decl:findMetadata "fields_hidden_by_default" then
$     for field, record in decl:allFields() do
$       if field.metadata.data_field then
$         unpackField(field, record)
$       end
$     end
$   else
$     for field, record in decl:allFields() do
$       if not field.metadata.hidden then
$         unpackField(field, record)
$       end
$     end
$   end
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "reflect::Array", function(decl)
$   local subtype = decl.args[1]
  /* --------------------------------------------------------------------------
   */
  $(unpack.declare(decl))
  {
    sdata->setObject(nil);

    for (auto& elem : data)
    {
      SourceData* elem_data = sdata->addData(
        *sfile,
        nil,
        "$(subtype.qname)"_str);

      $(unpack.call(subtype))(elem, elem_data);
    }
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "reflect::StringMap", function(decl)
$   local subtype = decl.args[1]
  /* --------------------------------------------------------------------------
   */
  $(unpack.declare(decl))
  {
    sdata->setObject(nil);

    for (auto& slot : data)
    {
      SourceData* slot_data = sdata->addData(
        *sfile,
        slot.key,
        nil);

      $(unpack.call(subtype))(slot.elem, slot_data);
    }
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "reflect::TypedPtr", function(decl)
$   local subtype = decl.args[1]:desugar()
$   local subdecl = subtype.decl
$   for derived in subdecl:allDerived() do
$     av:handleDecl(derived)
$   end
  /* --------------------------------------------------------------------------
   */
  $(unpack.declare(decl))
  {
    if (isnil(data.type) || data.ptr == nullptr)
      return;

    switch (data.type.val)
    {
$   for derived in subdecl:allDerived() do
    case "$(derived.qname)"_typeid_val:
      sdata->type = "$(derived.qname)"_str;
      $(unpack.call(derived))(*(const $(derived.qname)*)data.ptr, sdata);
      break;
$   end
    }
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:previsit(ast.Record, function(decl)
$   if not decl:findMetadata "ref" then
$     return
$   end
  $(unpack.declare(decl))
  {
    if (isnil(data.name))
      return;

    sdata->setStringValue(*sfile, data.name);
  }
$   return av.handled
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "iro::Flags", function(decl)
$   local subtype = decl.args[1]:desugar()
$   local subdecl = subtype.decl
  /* --------------------------------------------------------------------------
   */
  $(unpack.declare(decl))
  {
    sdata->setObject(nil);

$   for elem in subdecl.elems:each() do
$     if not elem.metadata.hidden and elem.name ~= "COUNT" then
    if (data.test($(subdecl.qname)::$(elem.name)))
    {
      sdata->addStringValue(*sfile, "$(elem.name)"_str);
    }
$     end
$   end
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(ast.TypedefDecl, function(decl)
  /* --------------------------------------------------------------------------
   */
  $(unpack.declare(decl))
  {
    $(unpack.call(decl.subtype))(data, sdata);
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:begin(function(decl)
$   return decl.metadata.def ~= nil
$ end)

}; // struct Unpacker

/* ----------------------------------------------------------------------------
 */
SourceData* unpackData(const UnpackParams& params)
{
  assert(notnil(params.type));
  assert(notnil(params.data));
  assert(params.sfile != nullptr);

  Unpacker unpacker = {};
  unpacker.sfile = params.sfile;

  SourceData* unpacked_data = params.sfile->allocateSourceData();

  unpacked_data->type = rtr::typenameFromTypeId(params.type);

  switch (params.type.val)
  {
$ av:eachVisited(function(decl)
$   local name = decl.type.qname
  case "$(name)"_typeid_val:
    {
      auto* data = ($(name)*)params.data.ptr;
      unpacker.$(unpack.call(decl))(*data, unpacked_data);
    }
    break;
$ end)
  default: 
    assert(!"unhandled type given to unpackData");
  }

  return unpacked_data;
}

} // namespace reflect
