---
--- Our internal representation of clang's AST.
---
--- This is generated by AstContext.lua, and we do this to avoid needing to
--- directly interact with the lppclang interface to clang. Trying to is 
--- pretty tedious and annoying, trust me! This also allows us to diverge
--- from the information that clangs stores as well as define some of our 
--- own information. This may also be viewed as giving a clearer idea of 
--- what we support from clang's ast.
---
--- Note that the new methods of derivations of Type/Decl are really only 
--- for internal use, and so are left undocumented.
---
---@meta reflect.ast

local IroType = require "iro.Type"
local List = require "iro.List"
local buffer = require "string.buffer"

--- Little helper for forming a string using a luajit buffer. For the syntax 
--- and also to avoid overusing lua's concat operator, since its bad!
local function qstr(...)
  return buffer.new():put(...):get()
end

--- The ast module containing the types we support in our ast.
local ast = {}

-- TODO(sushi) all of this has made me realize the issue with iro's type 
--             system is that the new methods for types does not optionally
--             take an already existing object to fill out, in the case of 
--             a derived type wrapping its new. I don't feel like fixing that
--             right now, but I should soon. Please.
--
--             Honestly I should REALLY redo iro.Type. That was implemented 
--             AGES ago when I had much less of an understanding of how it 
--             should work!

--- A representation of a Type in the AST.
---@class ast.Type : iro.Type
---
--- Any metadata that was attached to this type via the metadata
--- module. These are actually represented as specially formatted comments 
--- that we extract using clang.
---@field metadata table
local Type = IroType.make()

--- A representation of a Decl in the AST.
---@class ast.Decl : iro.Type
---
--- Most Decls store a name, I believe!
---@field name string
---
--- Any metadata that was attached to this declaration via the metadata
--- module. These are actually represented as specially formatted comments 
--- that we extract using clang.
---@field metadata table
local Decl = IroType.make()

-- By default, every Decl and Type has an empty metadata table.
Decl.metadata = {}
Type.metadata = {}

--- Representation of a builtin type, eg. char, int, short, etc.
---
---@class ast.Builtin : ast.Type
---
--- The name of this builtin type.
---@field name string
---
--- This type's size, in bytes.
---@field size number
---
local Builtin = Type:derive()
ast.Builtin = Builtin

--- A table of builtin types for easy access.
ast.builtins = {}

---@return ast.Builtin
Builtin.new = function(name, size)
  local o = Builtin:derive()
  o.name = name
  o.size = size
  ast.builtins[name] = o
  return o
end

Builtin.__tostring = function(self)
  return qstr("Builtin(", self.name, ',', self.size, ")")
end

-- Generate the basic builtin types.
Builtin("void", 0)
Builtin("float", 4)
Builtin("double", 8)

List
{
  { "char",  1 }, 
  { "short", 2 },
  { "int",   4 },
  { "long",  8 },
}
:each(function(i)
  Builtin(i[1], i[2])
  Builtin("signed "..i[1], i[2])
  Builtin("unsigned "..i[1], i[2])
end)

--- Represents a pointer type.
--- @class ast.Pointer : ast.Type
---
--- The type this pointer points to.
---@field subtype ast.Type
---
local Pointer = Type:derive()
ast.Pointer = Pointer

---@return ast.Pointer
Pointer.new = function(subtype)
  local o = Pointer:derive()
  o.subtype = subtype
  return o
end

Pointer.__tostring = function(self)
  return qstr("Pointer(", self.subtype, ")")
end

--- Represents a reference type.
--- @class ast.ReferenceType : ast.Type
---
--- The type this reference references.
---@field subtype ast.Type
---
local ReferenceType = Type:derive()
ast.ReferenceType = ReferenceType

---@return ast.ReferenceType
ReferenceType.new = function(subtype)
  local o = ReferenceType:derive()
  o.subtype = subtype
  return o
end

ReferenceType.__tostring = function(self)
  return qstr("Reference(", self.subtype, ")")
end

--- Represents a function pointer.
--- @class ast.FunctionPointerType : ast.Type
---
--- TODO(sushi) add a way to get the actual function signature and such.
---
local FunctionPointerType = Type:derive()
ast.FunctionPointerType = FunctionPointerType

---@return ast.FunctionPointerType
FunctionPointerType.new = function()
  local o = FunctionPointerType:derive()
  return o
end

FunctionPointerType.__tostring = function(self)
  return qstr("FunctionPointer()")
end

--- Represents a C array.
--- @class ast.CArray : ast.Type
---
--- The type of the elements in the array.
---@field subtype ast.Type
---
--- The number of elements in the array.
---@field len number
---
local CArray = Type:derive()
ast.CArray = CArray

---@return ast.CArray
CArray.new = function(subtype, len)
  local o = CArray:derive()
  o.subtype = subtype
  o.len = len
  return o
end

CArray.__tostring = function(self)
  return qstr("CArray(", self.len, ',', self.subtype, ')')
end

--- Represents a typedef type. This stores the declaration of the typedef,
--- so to get more information about it, such as the name, you must access 
--- the decl.
---
--- @class ast.TypedefType : ast.Type
---
--- The declaration of the typedef.
---@field decl ast.Decl
---
local TypedefType = Type:derive()
ast.TypedefType = TypedefType

---@return ast.TypedefType
TypedefType.new = function(decl)
  local o = TypedefType:derive()
  o.decl = decl
  return o
end

TypedefType.__tostring = function(self)
  return qstr("TypedefType(", self.decl, ")")
end

--- Represents a 'tag' type. This stores a tag decl that the type represents.
---
--- @class ast.TagType : ast.Type
---
--- The declaration of the tag.
---@field decl ast.TagDecl
---
local TagType = Type:derive()
ast.TagType = TagType

---@return ast.TagType
TagType.new = function(decl)
  local o = TagType:derive()
  o.decl = decl
  return o
end

TagType.__tostring = function(self)
  return qstr("TagType(", self.decl, ")")
end

--- A 'tag' declaration, eg. one that is named. More information of the 
--- decl is stored in subtypes, such as Record, or Struct.
---
--- @class ast.TagDecl : ast.Decl
---
--- The name of the tag.
---@field name string
---
local TagDecl = Decl:derive()
ast.TagDecl = TagDecl

---@return ast.TagDecl
TagDecl.new = function(name)
  local o = TagDecl:derive()
  o.name = name
  return o
end

TagDecl.__tostring = function(self)
  return qstr("TagDecl(", self.name, ")")
end

--- A declaration of a typedef.
--- @class ast.TypedefDecl : ast.Decl
---
--- The name of the typedef.
---@field name string
--- 
--- The type this typedef wraps. This isn't just a declaration, because 
--- typedef declarations can wrap arbitrary types, such as pointers.
---@field subtype ast.Type
---
local TypedefDecl = Decl:derive()
ast.TypedefDecl = TypedefDecl

---@return ast.TypedefDecl
TypedefDecl.new = function(name, subtype)
  local o = TypedefDecl:derive()
  o.name = name
  o.subtype = subtype
  return o
end

--- A representation of an 'elaborated' type. This is a concept from clang,
--- and it represents 'sugar' wrapping some other type. In this case, 
--- Elaborated represents the way a type was actually written in the source 
--- code it was retrieved from.
---
--- @class ast.Elaborated : ast.Type
---
--- The name this type was actually written with in the source code.
---@field name string
---
--- The type this elaborated type wraps.
---@field subtype ast.Type
---
local Elaborated = Type:derive()
ast.Elaborated = Elaborated

---@return ast.Elaborated
Elaborated.new = function(name, subtype)
  local o = Elaborated:derive()
  o.name = name
  o.subtype = subtype
  return o
end

Elaborated.__tostring = function(self)
  return qstr("Elaborated(", self.name, ",", self.subtype, ")")
end

--- An enum declaration.
--- @class ast.Enum : ast.TagDecl
---
--- The elements of the enum.
---@field elems iro.List
---
local Enum = TagDecl:derive()
ast.Enum = Enum

---@return ast.Enum
Enum.new = function(name)
  local o = Enum:derive()
  o.name = name 
  o.elems = List{}
  return o
end

Enum.__tostring = function(self)
  return qstr("Enum(", self.name, ")")
end

--- A record declaration, which is either a struct or union.
---
--- Note that while we store inheritance relations, ecs' reflection system
--- does not support multiple inheritance. This is something we explicitly
--- avoid throughout our projects!
--- 
--- @class ast.Record : ast.TagDecl
---
--- The members of this record. These could be fields, methods, or other 
--- kinds of nested declarations that C++ supports. This list is ordered the
--- same as the members were declared in the source.
---@field members iro.List
---
--- The base class of this record, if any.
---@field base ast.Decl
--- 
--- The derived classes of this record.
---@field derived iro.List
---
local Record = TagDecl:derive()
ast.Record = Record

---@return ast.Record
Record.new = function(name)
  local o = Record:derive()
  o.name = name
  o.members = List {}
  o.derived = List {}
  return setmetatable(o, Record)
end

Record.__tostring = function(self)
  return qstr("Record(", self.name, ")")
end

--- A field of a record.
---
--- @class ast.Field : ast.Decl
---
--- The name of the field.
---@field name string
---
--- The type of the field.
---@field type ast.Type
---
--- The offset in BITS of this field into the record it belongs 
--- to.
---@field offset number
---
local Field = Decl:derive()
ast.Field = Field

---@return ast.Field
Field.new = function(name, type, offset)
  local o = Decl:derive()
  o.name = name
  o.type = type
  o.offset = offset
  return o
end

--- A struct declaration. This type exists primarily as a convenience for 
--- checking if a decl is specifically a struct, not a union.
--- 
--- @class ast.Struct : ast.Record
---
local Struct = Record:derive()
ast.Struct = Struct

---@return ast.Struct
Struct.new = function(name)
  local o = Struct:derive()
  o.name = name
  o.members = List {}
  o.derived = List {}
  return o
end

Struct.__tostring = function(self)
  return qstr("Struct(", self.name, ")")
end

--- A union declaration. This type exists primarily as a convenience for 
--- checking if a decl is specifically a union, not a struct.
--- 
--- @class ast.Union : ast.Record
---
local Union = Record:derive()
ast.Union = Union

---@return ast.Union
Union.new = function(name)
  local o = Union:derive()
  o.name = name
  o.members = List {}
  o.derived = List {}
  return o
end

Union.__tostring = function(self)
  return qstr("Union(", self.name, ")")
end

--- A specialization of a template. Note that at the moment, we don't support
--- representing the specialized template decl as an ast.Decl. We just store
--- its name. I don't remember why. Maybe we should...
---
--- @class ast.TemplateSpec : ast.Decl
---
--- The arguments to this template specialization.
---@field args iro.List
---
--- The name of the template that this specialization is of.
---@field specialized_name string
---
local TemplateSpec = Record:derive()
ast.TemplateSpec = TemplateSpec

---@return ast.TemplateSpec
TemplateSpec.new = function(name, specialized_name)
  local o = TemplateSpec:derive()
  o.name = name
  o.specialized_name = specialized_name
  o.args = List {}
  return o
end

TemplateSpec.__tostring = function(self)
  local buf = buffer.new()
  buf:put("TemplateSpec(", self.specialized_name)
  for arg in self.args:each() do
    buf:put ","
    if type(arg) == "number" then
      buf:put(arg)
    else
      buf:put(tostring(arg))
    end
  end
  buf:put ")"
  return buf:get()
end


return ast
