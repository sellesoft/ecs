---
--- Our internal representation of clang's AST.
---
--- This is generated by AstContext.lua, and we do this to avoid needing to
--- directly interact with the lppclang interface to clang. Trying to is 
--- pretty tedious and annoying, trust me! This also allows us to diverge
--- from the information that clangs stores as well as define some of our 
--- own information. This may also be viewed as giving a clearer idea of 
--- what we support from clang's ast.
---
--- Note that the new methods of derivations of Type/Decl are really only 
--- for internal use, and so are left undocumented.
---
---@meta reflect.ast

local IroType = require "iro.Type"
local List = require "iro.List"
local buffer = require "string.buffer"
local dump = require "reflect.astdump"

--- Little helper for forming a string using a luajit buffer. For the syntax 
--- and also to avoid overusing lua's concat operator, since its bad!
local function qstr(...)
  local buf = buffer.new()
  local function recur(x, ...)
    if x then
      buf:put(tostring(x))
      recur(...)
    end
  end
  recur(...)
  return buf:get()
end

--- The ast module containing the types we support in our ast.
local ast = {}

ast.dump = function(root)
  local out = dump.new()
  root:dump(out)

  out:form()
  return out.buffer:get()
end

ast.dumpout = function(root)
  io.write(ast.dump(root), '\n')
end

-- TODO(sushi) all of this has made me realize the issue with iro's type 
--             system is that the new methods for types does not optionally
--             take an already existing object to fill out, in the case of 
--             a derived type wrapping its new. I don't feel like fixing that
--             right now, but I should soon. Please.
--
--             Honestly I should REALLY redo iro.Type. That was implemented 
--             AGES ago when I had much less of an understanding of how it 
--             should work! But its also kinda used everywhere!

--- A representation of a Type in the AST.
---@class ast.Type : iro.Type
---
--- The size of this type in bytes.
---@field size number
---
--- Any metadata that was attached to this type via the metadata
--- module. These are actually represented as specially formatted comments 
--- that we extract using clang.
---@field metadata table
local Type = IroType.make()
ast.Type = Type

--- Attempts to desugar this type, eg. removing layers of elaboration
--- and typedefs.
---
---@return ast.Type?
Type.desugar = function(self)
  if self:is(ast.Elaborated) then
    return (self.subtype:desugar())
  elseif self:is(ast.TypedefType) then
    return (self.decl.subtype:desugar())
  else 
    return self
  end
end

--- A representation of a Decl in the AST.
---@class ast.Decl : iro.Type
---
--- The name of this declaration. Note that we only store named declarations,
--- eg. clang's NamedDecl. For now. I hope that I don't decide to change that
--- in the future.
---@field name string
---
--- The fully qualified name of this declaration, that is, with the namespace 
--- or struct or union or whatever it belongs to prepended to its plain name.
---@field qname string
---
--- If this declaration belongs to a namespace, it is specified here.
---@field namespace ast.Namespace
---
--- The comment that clang attached to this decl, if any.
---@field comment string?
---
--- Any metadata that was attached to this declaration via the metadata
--- module. These are actually represented as specially formatted comments 
--- that we extract using clang.
---@field metadata table
---
--- If this declaration is nested within another one, eg. a field, nested
--- record decl, method, etc. this points to its parent. Note that this 
--- is distinct from the namespace it may be in!
---@field parent ast.Decl?
local Decl = IroType.make()
ast.Decl = Decl

-- By default, every Decl and Type has an empty metadata table.
Decl.metadata = {}
Type.metadata = {}

--- Representation of the translation unit that was parsed. This contains 
--- all 'top-level' declarations that were parsed in a given AstContext.
---
--- @class ast.TranslationUnit : ast.Decl
---
--- The list of top-level decls in this translation unit.
---@field decls iro.List
---
local TranslationUnit = Decl:derive()
ast.TranslationUnit = TranslationUnit

---@return ast.TranslationUnit
TranslationUnit.new = function()
  local o = TranslationUnit:derive()
  o.decls = List {}
  return o
end

TranslationUnit.__tostring = function(self)
  return qstr("TranslationUnit(", self.decls, ")")
end

TranslationUnit.dump = function(self, dump)
  dump:node("TranslationUnit", function()
    for decl in self.decls:each() do
      decl:dump(dump)
    end
  end)
end

--- A namespace, which contains declarations declared within it. The 
--- declarations are ordered as they are found in any instance of that 
--- namespace, eg. if it is begun in multiple places, we don't store multiple
--- namespace decls, the declarations of that namespace are merged into one.
--- 
--- @class ast.Namespace : ast.Decl
---
--- The name of the namespace.
---@field name string
---
--- If this namespace is nested in another one, it is specified here.
---@field prev ast.Namespace
---
--- The declarations in this namespace.
---@field decls iro.List
---
local Namespace = Decl:derive()
ast.Namespace = Namespace

---@return ast.Namespace
Namespace.new = function(name, prev)
  local o = Namespace:derive()
  o.name = name
  o.prev = prev
  o.decls = List {}
  return o
end

Namespace.__tostring = function(self)
  return qstr("Namespace(", self.name, ")")
end

Namespace.dump = function(self, dump)
  dump:node("Namespace", function()
    dump:inline_name(self.name)
    for decl in self.decls:each() do
      decl:dump(dump)
    end
  end)
end

Namespace.formCSafeName = function(self, out)
  out = out or buffer.new()

  if self.prev then
    self.prev:formCSafeName(out)
    out:put "_"
  end
  out:put(self.name)
end

--- Representation of a builtin type, eg. char, int, short, etc.
---
---@class ast.Builtin : ast.Type
---
--- The name of this builtin type.
---@field name string
---
--- This type's size, in bytes.
---@field size number
---
local Builtin = Type:derive()
ast.Builtin = Builtin

--- A table of builtin types for easy access.
ast.builtins = {}

---@return ast.Builtin
Builtin.new = function(name, size)
  local o = Builtin:derive()
  o.name = name
  o.size = size
  ast.builtins[name] = o
  return o
end

Builtin.__tostring = function(self)
  return qstr("Builtin(", self.name, ',', self.size, ")")
end

Builtin.dump = function(self, dump)
  dump:node("Builtin", function()
    dump:inline_name(self.name)
  end)
end

Builtin.formCSafeName = function(self, out)
  out = out or buffer.new()
  out:put((self.name:gsub(" ", "_")))
  return out
end

-- Generate the basic builtin types.
Builtin("void", 0)
Builtin("float", 4)
Builtin("double", 8)

List
{
  { "char",  1 }, 
  { "short", 2 },
  { "int",   4 },
  { "long",  8 },
  { "long long", 8 } 
}
:each(function(i)
  Builtin(i[1], i[2])
  Builtin("signed "..i[1], i[2])
  Builtin("unsigned "..i[1], i[2])
end)

--- Represents a pointer type.
--- @class ast.Pointer : ast.Type
---
--- The type this pointer points to.
---@field subtype ast.Type
---
local Pointer = Type:derive()
ast.Pointer = Pointer

---@return ast.Pointer
Pointer.new = function(subtype)
  local o = Pointer:derive()
  o.subtype = subtype
  return o
end

Pointer.__tostring = function(self)
  return qstr("Pointer(", self.subtype, ")")
end

Pointer.dump = function(self, dump)
  dump:typenode("Pointer", function()
    self.subtype:dump(dump)
  end)
end

Pointer.formCSafeName = function(self, out)
  out = out or buffer.new()
  self.subtype:formCSafeName(out)
  out:put '_ptr'
  return out
end

--- Represents a reference type.
--- @class ast.Reference : ast.Type
---
--- The type this reference references.
---@field subtype ast.Type
---
local Reference = Type:derive()
ast.Reference = Reference

---@return ast.Reference
Reference.new = function(subtype)
  local o = Reference:derive()
  o.subtype = subtype
  return o
end

Reference.__tostring = function(self)
  return qstr("Reference(", self.subtype, ")")
end

Reference.dump = function(self, dump)
  dump:typenode("Reference", function()
    self.subtype:dump(dump)
  end)
end

--- Represents a function pointer.
--- @class ast.FunctionPointer : ast.Type
---
local FunctionPointer = Type:derive()
ast.FunctionPointer = FunctionPointer

---@return ast.FunctionPointer
FunctionPointer.new = function()
  local o = FunctionPointer:derive()
  return o
end

FunctionPointer.__tostring = function(self)
  return qstr("FunctionPointer()")
end

FunctionPointer.dump = function(self, dump)
  dump:typenode("FunctionPointer", function()

  end)
end

--- Represents a C array.
--- @class ast.CArray : ast.Type
---
--- The type of the elements in the array.
---@field subtype ast.Type
---
--- The number of elements in the array.
---@field len number
---
local CArray = Type:derive()
ast.CArray = CArray

---@return ast.CArray
CArray.new = function(subtype, len)
  local o = CArray:derive()
  o.subtype = subtype
  o.len = len
  return o
end

CArray.__tostring = function(self)
  return qstr("CArray(", self.len, ',', self.subtype, ')')
end

CArray.dump = function(self, dump)
  dump:typenode("CArray", function()
    dump:tag("len", self.len)
    self.subtype:dump(dump)
  end)
end

CArray.formCSafeName = function(self, out)
  out = out or buffer.new()
  self.subtype:formCSafeName(out)
  out:put('_carr_', self.len)
  return out
end

--- A declaration which declares a Type!
---
--- @class ast.TypeDecl : ast.Decl
---
--- The type this declaration declares.
---@field type ast.Type
---
local TypeDecl = Decl:derive()
ast.TypeDecl = TypeDecl

---@return ast.TypeDecl
TypeDecl.new = function(name, type)
  local o = TypeDecl:derive()
  o.name = name
  o.type = type
  return o
end

TypeDecl.__tostring = function(self)
  return qstr("TypeDecl(", self.name, ',', self.type, ")")
end

TypeDecl.dump = function(self, dump)
  dump:declnode("TypeDecl", function()
    dump:inline_name(self.name)
    self.type:dump(dump)
  end)
end

--- Represents a typedef type. This stores the declaration of the typedef,
--- so to get more information about it, such as the name, you must access 
--- the decl.
---
--- @class ast.TypedefType : ast.Type
---
--- The declaration of the typedef.
---@field decl ast.Decl
---
local TypedefType = Type:derive()
ast.TypedefType = TypedefType

---@return ast.TypedefType
TypedefType.new = function(decl)
  local o = TypedefType:derive()
  o.decl = decl
  return o
end

TypedefType.__tostring = function(self)
  return qstr("TypedefType(", self.decl, ")")
end

TypedefType.dump = function(self, dump)
  dump:typenode("TypedefType", function()
    dump:tag("decl", self.decl)
  end)
end

--- Represents a 'tag' type. This stores a tag decl that the type represents.
---
--- @class ast.TagType : ast.Type
---
--- The declaration of the tag.
---@field decl ast.TagDecl
---
local TagType = Type:derive()
ast.TagType = TagType

---@return ast.TagType
TagType.new = function(decl)
  local o = TagType:derive()
  o.decl = decl
  return o
end

TagType.__tostring = function(self)
  return qstr("TagType(", self.decl, ")")
end

TagType.dump = function(self, dump)
  dump:typenode("TagType", function()
    dump:tag("decl", self.decl)
  end)
end

TagType.formCSafeName = function(self, out)
  out = out or buffer.new()
  self.decl:formCSafeName(out)
  return out
end

--- A 'tag' declaration, eg. one that is named. More information of the 
--- decl is stored in subtypes, such as Record, or Struct.
---
--- @class ast.TagDecl : ast.TypeDecl
---
--- The name of the tag.
---@field name string
---
--- Whether or not this tag is considered complete.
---@field is_complete boolean
---
--- If this tag does not have a name.
---@field is_anonymous boolean
---
local TagDecl = TypeDecl:derive()
ast.TagDecl = TagDecl

---@return ast.TagDecl
TagDecl.new = function(name)
  local o = TagDecl:derive()
  o.name = name
  return o
end

TagDecl.__tostring = function(self)
  return qstr("TagDecl(", self.name, ")")
end

TagDecl.dump = function(self, dump)
  dump:node("TagDecl", function()
    dump:tag("name", self.name)
  end)
end

TagDecl.formCSafeName = function(self, out)
  out = out or buffer.new()
  if self.namespace then
    self.namespace:formCSafeName(out)
    out:put '_'
  end

  if self.parent then
    self.parent:formCSafeName(out)
    out:put '_'
  end

  out:put(self.name)
  return out
end

--- A declaration of a typedef.
--- @class ast.TypedefDecl : ast.TypeDecl
---
--- The name of the typedef.
---@field name string
--- 
--- The type this typedef wraps. This isn't just a declaration, because 
--- typedef declarations can wrap arbitrary types, such as pointers.
---@field subtype ast.Type
---
local TypedefDecl = TypeDecl:derive()
ast.TypedefDecl = TypedefDecl

---@return ast.TypedefDecl
TypedefDecl.new = function(name, subtype)
  local o = TypedefDecl:derive()
  o.name = name
  o.subtype = subtype
  return o
end

TypedefDecl.__tostring = function(self)
  return qstr("TypedefDecl(", self.name, ",", self.subtype, ")")
end

--- Attempts to find metadata of the given name on this typedef decl. If its 
--- not find, attempts to unwrap the typedef to a decl that may have metadata
--- and asks it for it instead.
---
--- Currently, this only supports unwrapping to subtypes that are also typedefs
--- and subtypes that are TagDecls.
---
---@param name string
---@return string?
TypedefDecl.findMetadata = function(self, name)
  if self.metadata[name] then
    return self.metadata[name]
  end

  local subtype = self.subtype
  if subtype:is(ast.Elaborated) then
    subtype = subtype.subtype
  end

  if subtype:is(ast.TypedefType) or subtype:is(ast.TagType) then
    return (subtype.decl:findMetadata(name))
  end
end

TypedefDecl.dump = function(self, dump)
  dump:node("TypedefDecl", function()
    dump:tag("name", self.name)
    for k,v in pairs(self.metadata) do
      dump:tag("<meta> "..k, v)
    end
    dump:tag("subtype", self.subtype)
  end)
end

TypedefDecl.formCSafeName = function(self, out)
  out = out or buffer.new()
  if self.namespace then
    self.namespace:formCSafeName(out)
    out:put '_'
  end
  out:put(self.name)
  return out
end

--- A representation of an 'elaborated' type. This is a concept from clang,
--- and it represents 'sugar' wrapping some other type. In this case, 
--- Elaborated represents the way a type was actually written in the source 
--- code it was retrieved from.
---
--- @class ast.Elaborated : ast.Type
---
--- The name this type was actually written with in the source code.
---@field name string
---
--- The type this elaborated type wraps.
---@field subtype ast.Type
---
local Elaborated = Type:derive()
ast.Elaborated = Elaborated

---@return ast.Elaborated
Elaborated.new = function(name, subtype)
  local o = Elaborated:derive()
  o.name = name
  o.subtype = subtype
  return o
end

Elaborated.__tostring = function(self)
  return qstr("Elaborated(", self.name, ",", self.subtype, ")")
end

Elaborated.dump = function(self, dump)
  dump:typenode("Elaborated", function()
    dump:inline_name(self.name)
    self.subtype:dump(dump)
  end)
end

--- An enum declaration.
--- @class ast.Enum : ast.TagDecl
---
--- The elements of the enum.
---@field elems iro.List
---
local Enum = TagDecl:derive()
ast.Enum = Enum

---@return ast.Enum
Enum.new = function(name)
  local o = Enum:derive()
  o.name = name 
  o.elems = List{}
  return o
end

Enum.__tostring = function(self)
  return qstr("Enum(", self.name, ")")
end

Enum.dump = function(self, dump)
  dump:node("Enum", function()
    dump:inline_name(self.name)
    for elem in self.elems:each() do
      dump:node(elem.name, function()
        dump:inline_name(elem.value)
      end)
    end
  end)
end

--- A record declaration, which is either a struct or union.
---
--- Note that while we store inheritance relations, ecs' reflection system
--- does not support multiple inheritance. This is something we explicitly
--- avoid throughout our projects!
--- 
--- @class ast.Record : ast.TagDecl
---
--- The members of this record. These could be fields, methods, or other 
--- kinds of nested declarations that C++ supports. This list is ordered the
--- same as the members were declared in the source.
---@field members iro.List
---
--- The base class of this record, if any.
---@field base ast.Record
--- 
--- The derived classes of this record.
---@field derived iro.List
---
local Record = TagDecl:derive()
ast.Record = Record

Record.construct = function(o, name)
  o.name = name
  o.members = List {}
  o.derived = List {}
end

---@return ast.Record
Record.new = function(name)
  local o = Record:derive()
  Record.construct(o, name)
  return setmetatable(o, Record)
end

Record.__tostring = function(self)
  return qstr("Record(", self.qname, ")")
end

Record.addMember = function(self, name, decl)
  -- TODO(sushi) we could cache some info like storing fields, methods, 
  --             subtypes, etc. in their own tables.
  -- io.write("*********** Record.addMember: ", name, " to ", self.name, "\n")
  -- io.write(debug.traceback(), '\n')
  self.members:push(decl)
end

Record.dumpBase = function(self, name, dump)
  dump:node(name, function()
    dump:inline_name(self.name)
    dump:tag("typesize: ", self.type.size)
    for k,v in pairs(self.metadata) do
      dump:tag("<meta> "..k, v)
    end
    if self.base then
      dump:tag("base", self.base)
    end
    for member in self.members:each() do
      member:dump(dump)
    end
  end)
end

--- Returns an iterator over this Record's Field members.
---
---@return function
Record.eachField = function(self)
  local iter = self.members:each()
  return function()
    while true do
      local member = iter()
      if not member then
        return
      end
      if member:is(ast.Field) then
        return member
      end
    end
  end
end

--- Returns an iterator over all fields that would exist in this Record,
--- base Records included. The Record that the field comes from is provided
--- as a second parameter.
---
---@return function
Record.allFields = function(self)
  -- TODO(sushi) there's probably a fancier way to do this with recursion and
  --             such to avoid allocating a table like this but I'll leave
  --             that for later as I wanna get other stuff working.
  --             Could also use coroutines prob, but I am not yet familiar 
  --             with using them that way and don't want to get bogged down
  --             in doing so.
  local base_list = List {}
  
  local base = self.base
  while base do
    base_list:pushFront(base)
    base = base.base
  end

  base_list:push(self)

  local base_idx = 1
  local iter = base_list[base_idx].members:each()
  return function()
    while true do
      local member = iter()
      if not member then
        while true do
          base_idx = base_idx + 1
          if base_idx > #base_list then
            return
          end
          iter = base_list[base_idx].members:each()
          member = iter()
          if member then
            break
          end
        end
      end
      if member:is(ast.Field) then
        return member, base_list[base_idx]
      end
    end
  end
end

--- Returns an iterator over all Records deriving from this one.
---
---@return function
Record.allDerived = function(self)
  -- Whatever.
  local derived = List {}

  local function recur(r)
    for d in r.derived:each() do
      recur(d)
      derived:push(d)
    end
  end

  recur(self)
  return derived:each()
end

--- Returns an iterator over this Record's Field members along with an 
--- index of that member.
---
---@return function
Record.eachFieldWithIndex = function(self)
  local iter = self.members:each()
  local i = 0
  return function()
    while true do
      local member = iter()
      if not member then
        return
      end
      if member:is(ast.Field) then
        i = i + 1
        return member, i
      end
    end
  end
end

--- Finds a Field with the given name.
---
---@param name string
---@return ast.Field?
Record.findField = function(self, name)
  for member in self.members:each() do
    if member:is(ast.Field) and member.name == name then
      return member
    end
  end
  if self.base then
    return self.base:findField(name)
  end
end

--- Returns an iterator over nested Records.
---
---@return function
Record.eachNestedRecord = function(self)
  local iter = self.members:each()
  return function()
    while true do
      local member = iter()
      if not member then
        return
      end
      if member:is(ast.Record) then
        return member
      end
    end
  end
end

--- Attempts to find a nested Record by name.
---
---@param name string
---@return ast.Record?
Record.findNestedRecord = function(self, name)
  for member in self.members:each() do
    if member:is(ast.Record) and member.name == name then
      return member
    end
  end
end

--- Attempts to find a nested Enum by name.
---
---@param name string
---@return ast.Enum?
Record.findNestedEnum = function(self, name)
  for member in self.members:each() do
    if member:is(ast.Enum) and member.name == name then
      return member
    end
  end
end

--- Returns an iterator over nested Enums.
---
---@return function
Record.eachNestedEnum = function(self)
  local iter = self.members:each()
  return function()
    while true do
      local member = iter()
      if not member then
        return
      end
      if member:is(ast.Enum) then
        return member
      end
    end
  end
end

--- Gets the number of fields this Record contains.
---
---@return number
Record.countFields = function(self)
  local sum = 0
  for member in self.members:each() do
    if member:is(ast.Field) then
      sum = sum + 1
    end
  end
  return sum
end

--- Attempts to find a method of the given name.
---
---@return ast.Function?
Record.findMethod = function(self, name)
  for member in self.members:each() do
    if member:is(ast.Function) and member.name == name then
      return member
    end
  end
end

--- Returns true if this Record is derived from the given Record.
---
---@param base ast.Record
---@return boolean
Record.isDerivedFrom = function(self, base)
  if self.base then
    if self.base == base then
      return true
    else
      return self.base:isDerivedFrom(base)
    end
  end
  return false
end

--- Finds metadata attached to this record of the given name. This also 
--- searches the Record's base, recursively, which is the primariy reason to
--- use this helper. Otherwise it's better to just write decl.metadata.<key>.
---
---@return any?
Record.findMetadata = function(self, key)
  if self.metadata[key] then
    return self.metadata[key]
  elseif self.base then
    return self.base:findMetadata(key)
  end
end 

--- A forward declaration of a Record decl. This is primarily for marking 
--- when a record is forward declared in the TranslationUnit. 
---
--- This avoids an issue that ecs' reflection used to have where upon 
--- encountering a forward decl, the underlying decl was inserted into the 
--- 'top-level' decl list immediately (we didn't have a concept of the 
--- translation unit back then, because ecs was trying to do too much!).
--- This made generating code based on reflection very difficult to do 
--- properly, as the order in which dependended on each other was not 
--- properly stored.
---
--- If there exists a definition of the underlying record, then it is stored
--- on this node. 
---
--- Perhaps we should store all forward declarations, but for now I think this
--- is all we need.
---
--- @class ast.ForwardRecord : ast.Decl
---
--- The underlying decl, if it is defined in the containing translation unit.
---@field decl ast.Record
---
local ForwardRecord = Decl:derive()
ast.ForwardRecord = ForwardRecord

---@return ast.ForwardRecord
ForwardRecord.new = function(name, decl)
  local o = ForwardRecord:derive()
  o.name = name
  o.decl = decl
  return o
end

ForwardRecord.__tostring = function(self)
  return qstr("ForwardRecord(", self.name, ")")
end

ForwardRecord.dump = function(self, dump)
  dump:node("ForwardRecord", function()
    dump:inline_name(self.name)
    dump:tag("decl", self.decl or "<incomplete>")
  end)
end

ForwardRecord.formCSafeName = function(self, out)
  out = out or buffer.new()
  if self.decl then
    self.decl:formCSafeName(out)
  else
    out:put(self.name)
  end
  return out
end

--- A field of a record.
---
--- @class ast.Field : ast.Decl
---
--- The name of the field.
---@field name string
---
--- The type of the field.
---@field type ast.Type
---
--- The offset in BITS of this field into the record it belongs 
--- to.
---@field offset number
---
local Field = Decl:derive()
ast.Field = Field

---@return ast.Field
Field.new = function(name, type, offset)
  local o = Field:derive()
  o.name = name
  o.type = type
  o.offset = offset
  return o
end

Field.__tostring = function(self)
  return qstr("Field(", self.name, ",", self.type, ")")
end

Field.dump = function(self, dump)
  dump:node("Field", function()
    dump:inline_name(self.name)
    dump:tag("offset", self.offset)
    dump:tag("size", self.type.size)
    for k,v in pairs(self.metadata) do
      dump:tag("<meta> "..k, v)
    end
    self.type:dump(dump)
  end)
end

--- A struct declaration. This type exists primarily as a convenience for 
--- checking if a decl is specifically a struct, not a union.
--- 
--- @class ast.Struct : ast.Record
---
local Struct = Record:derive()
ast.Struct = Struct

---@return ast.Struct
Struct.new = function(name)
  local o = Struct:derive()
  Record.construct(o, name)
  return o
end

Struct.__tostring = function(self)
  return qstr("Struct(", self.qname, ")")
end

Struct.dump = function(self, dump)
  Record.dumpBase(self, "Struct", dump)
end

--- A union declaration. This type exists primarily as a convenience for 
--- checking if a decl is specifically a union, not a struct.
--- 
--- @class ast.Union : ast.Record
---
local Union = Record:derive()
ast.Union = Union

---@return ast.Union
Union.new = function(name)
  local o = Union:derive()
  Record.construct(o, name)
  return o
end

Union.__tostring = function(self)
  return qstr("Union(", self.name, ")")
end

Union.dump = function(self, dump)
  Record.dumpBase(self, "Union", dump)
end

--- A declaration of a template.
---
---@class ast.Template : ast.Decl
---
--- The name of the template.
---@field name string
---
local Template = Decl:derive()
ast.Template = Template

---@return ast.Template
Template.new = function(name)
  local o = Template:derive()
  o.name = name
  return o
end

Template.__tostring = function(self)
  return qstr("Template(", self.name, ")")
end

Template.dump = function(self, dump)
  dump:node("Template", function()
    dump:inline_name(self.name)
  end)
end

--- A specialization of a template. Note that at the moment, we don't support
--- representing the specialized template decl as an ast.Decl. We just store
--- its name. I don't remember why. Maybe we should...
---
--- @class ast.TemplateSpec : ast.Record
---
--- The arguments to this template specialization.
---@field args iro.List
---
--- The Template declaration this specializes.
---@field specialized ast.Template
---
local TemplateSpec = Record:derive()
ast.TemplateSpec = TemplateSpec

---@return ast.TemplateSpec
TemplateSpec.new = function(name, specialized_name)
  local o = TemplateSpec:derive()
  Record.construct(o, name)
  o.specialized_name = specialized_name
  o.args = List {}
  return o
end

TemplateSpec.__tostring = function(self)
  local buf = buffer.new()
  buf:put("TemplateSpec(", self.specialized_name)
  for arg in self.args:each() do
    buf:put ","
    if type(arg) == "number" then
      buf:put(arg)
    else
      buf:put(tostring(arg))
    end
  end
  buf:put ")"
  return buf:get()
end

TemplateSpec.dump = function(self, dump)
  dump:node(name, function()
    dump:inline_name(self.name)
    if self.base then
      dump:tag("base", self.base)
    end
    for arg in self.args:each() do
      dump:tag("arg", arg)
    end
    for member in self.members:each() do
      member:dump(dump)
    end
  end)
end

TemplateSpec.formCSafeName = function(self, out)
  out = out or buffer.new()
  if self.namespace then
    self.namespace:formCSafeName(out)
    out:put '_'
  end

  out:put(self.name)
  for arg in self.args:each() do
    out:put "_"
    if type(arg) == "number" then
      out:put(arg)
    elseif arg:is(ast.Builtin) then
      arg:formCSafeName(out)
    elseif arg:is(ast.TagType) then
      arg.decl:formCSafeName(out)
    else
      arg:formCSafeName(out)
    end
  end

  return out
end

--- A function declaration. At the moment, these only exist to represent 
--- methods of record decls, and their use is very limited.
---
--- @class ast.Function : ast.Decl
---
local Function = Decl:derive()
ast.Function = Function

---@return ast.Function
Function.new = function(name)
  local o = Function:derive()
  o.name = name
  return o
end

Function.__tostring = function(self)
  return qstr("Function(", self.name, ")")
end

Function.dump = function(self, dump)
  dump:node("Function", function()
    dump:tag("name", self.name)
  end)
end

Function.formCSafeName = function(self, out)
  out = out or buffer.new()
  out:put(self.name)
  return out
end

-- Cheat and call our typedefs of the standard builtins builtin, because
-- its annoying to deal with having to unwrap them in reflection code.
Builtin("b8",  1)
Builtin("u8",  1)
Builtin("u16", 2)
Builtin("u32", 4)
Builtin("u64", 8)
Builtin("s8",  1)
Builtin("s16", 2)
Builtin("s32", 4)
Builtin("s64", 8)
Builtin("f32", 4)
Builtin("f64", 8)
Builtin("void", 0)

-- TODO(sushi) maybe make some kinda special decl type for iro's String.
--             I'm not really sure how I'd like that to work yet.

for k,v in pairs(ast) do
  if Decl:isTypeOf(v) or Type:isTypeOf(v) then
    if not v.dump then
      error(k.." does not define a dump method")
    end
  end
end

return ast
