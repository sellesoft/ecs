---
--- Our internal representation of clang's AST.
---
--- This is generated by AstContext.lua, and we do this to avoid needing to
--- directly interact with the lppclang interface to clang. Trying to is 
--- pretty tedious and annoying, trust me! This also allows us to diverge
--- from the information that clangs stores as well as define some of our 
--- own information. This may also be viewed as giving a clearer idea of 
--- what we support from clang's ast.
---
--- Note that the new methods of derivations of Type/Decl are really only 
--- for internal use, and so are left undocumented.
---
---@meta reflect.ast

local IroType = require "iro.Type"
local List = require "iro.List"
local buffer = require "string.buffer"
local dump = require "reflect.astdump"

--- Little helper for forming a string using a luajit buffer. For the syntax 
--- and also to avoid overusing lua's concat operator, since its bad!
local function qstr(...)
  return buffer.new():put(...):get()
end

--- The ast module containing the types we support in our ast.
local ast = {}

ast.dump = function(root)
  local out = dump.new()
  root:dump(out)

  out:form()
  return out.buffer:get()
end

-- TODO(sushi) all of this has made me realize the issue with iro's type 
--             system is that the new methods for types does not optionally
--             take an already existing object to fill out, in the case of 
--             a derived type wrapping its new. I don't feel like fixing that
--             right now, but I should soon. Please.
--
--             Honestly I should REALLY redo iro.Type. That was implemented 
--             AGES ago when I had much less of an understanding of how it 
--             should work! But its also kinda used everywhere!

--- A representation of a Type in the AST.
---@class ast.Type : iro.Type
---
--- The size of this type in bytes.
---@field size number
---
--- Any metadata that was attached to this type via the metadata
--- module. These are actually represented as specially formatted comments 
--- that we extract using clang.
---@field metadata table
local Type = IroType.make()
ast.Type = Type

--- A representation of a Decl in the AST.
---@class ast.Decl : iro.Type
---
--- The name of this declaration. Note that we only store named declarations,
--- eg. clang's NamedDecl. For now. I hope that I don't decide to change that
--- in the future.
---@field name string
---
--- If this declaration belongs to a namespace, it is specified here.
---@field namespace ast.Namespace
---
--- The comment that clang attached to this decl, if any.
---@field comment string?
---
--- Any metadata that was attached to this declaration via the metadata
--- module. These are actually represented as specially formatted comments 
--- that we extract using clang.
---@field metadata table
---
--- If this declaration is nested within another one, eg. a field, nested
--- record decl, method, etc. this points to its parent. Note that this 
--- is distinct from the namespace it may be in!
---@field parent ast.Decl?
local Decl = IroType.make()
ast.Decl = Decl

-- By default, every Decl and Type has an empty metadata table.
Decl.metadata = {}
Type.metadata = {}

--- Representation of the translation unit that was parsed. This contains 
--- all 'top-level' declarations that were parsed in a given AstContext.
---
--- @class ast.TranslationUnit : ast.Decl
---
--- The list of top-level decls in this translation unit.
---@field decls iro.List
---
local TranslationUnit = Decl:derive()
ast.TranslationUnit = TranslationUnit

---@return ast.TranslationUnit
TranslationUnit.new = function()
  local o = TranslationUnit:derive()
  o.decls = List {}
  return o
end

TranslationUnit.__tostring = function(self)
  return qstr("TranslationUnit(", self.decls, ")")
end

TranslationUnit.dump = function(self, dump)
  dump:node("TranslationUnit", function()
    for decl in self.decls:each() do
      decl:dump(dump)
    end
  end)
end

--- A namespace, which contains declarations declared within it. The 
--- declarations are ordered as they are found in any instance of that 
--- namespace, eg. if it is begun in multiple places, we don't store multiple
--- namespace decls, the declarations of that namespace are merged into one.
--- 
--- @class ast.Namespace : ast.Decl
---
--- The name of the namespace.
---@field name string
---
--- If this namespace is nested in another one, it is specified here.
---@field prev ast.Namespace
---
--- The declarations in this namespace.
---@field decls iro.List
---
local Namespace = Decl:derive()
ast.Namespace = Namespace

---@return ast.Namespace
Namespace.new = function(name, prev)
  local o = Namespace:derive()
  o.name = name
  o.prev = prev
  o.decls = List {}
  return o
end

Namespace.__tostring = function(self)
  return qstr("Namespace(", self.name, ")")
end

Namespace.dump = function(self, dump)
  dump:node("Namespace", function()
    dump:inline_name(self.name)
    for decl in self.decls:each() do
      decl:dump(dump)
    end
  end)
end

--- Representation of a builtin type, eg. char, int, short, etc.
---
---@class ast.Builtin : ast.Type
---
--- The name of this builtin type.
---@field name string
---
--- This type's size, in bytes.
---@field size number
---
local Builtin = Type:derive()
ast.Builtin = Builtin

--- A table of builtin types for easy access.
ast.builtins = {}

---@return ast.Builtin
Builtin.new = function(name, size)
  local o = Builtin:derive()
  o.name = name
  o.size = size
  ast.builtins[name] = o
  return o
end

Builtin.__tostring = function(self)
  return qstr("Builtin(", self.name, ',', self.size, ")")
end

Builtin.dump = function(self, dump)
  dump:node("Builtin", function()
    dump:inline_name(self.name)
  end)
end

-- Generate the basic builtin types.
Builtin("void", 0)
Builtin("float", 4)
Builtin("double", 8)

List
{
  { "char",  1 }, 
  { "short", 2 },
  { "int",   4 },
  { "long",  8 },
}
:each(function(i)
  Builtin(i[1], i[2])
  Builtin("signed "..i[1], i[2])
  Builtin("unsigned "..i[1], i[2])
end)

-- Cheat and call our typedefs of the standard builtins builtin, because
-- its annoying to deal with having to unwrap them in reflection code.
Builtin("u8",  1)
Builtin("u16", 2)
Builtin("u32", 4)
Builtin("u64", 8)
Builtin("s8",  1)
Builtin("s16", 2)
Builtin("s32", 4)
Builtin("s64", 8)
Builtin("f32", 4)
Builtin("f64", 8)

--- Represents a pointer type.
--- @class ast.Pointer : ast.Type
---
--- The type this pointer points to.
---@field subtype ast.Type
---
local Pointer = Type:derive()
ast.Pointer = Pointer

---@return ast.Pointer
Pointer.new = function(subtype)
  local o = Pointer:derive()
  o.subtype = subtype
  return o
end

Pointer.__tostring = function(self)
  return qstr("Pointer(", self.subtype, ")")
end

Pointer.dump = function(self, dump)
  dump:typenode("Pointer", function()
    self.subtype:dump(dump)
  end)
end

--- Represents a reference type.
--- @class ast.Reference : ast.Type
---
--- The type this reference references.
---@field subtype ast.Type
---
local Reference = Type:derive()
ast.Reference = Reference

---@return ast.Reference
Reference.new = function(subtype)
  local o = Reference:derive()
  o.subtype = subtype
  return o
end

Reference.__tostring = function(self)
  return qstr("Reference(", self.subtype, ")")
end

--- Represents a function pointer.
--- @class ast.FunctionPointer : ast.Type
---
local FunctionPointer = Type:derive()
ast.FunctionPointer = FunctionPointer

---@return ast.FunctionPointer
FunctionPointer.new = function()
  local o = FunctionPointer:derive()
  return o
end

FunctionPointer.__tostring = function(self)
  return qstr("FunctionPointer()")
end

--- Represents a C array.
--- @class ast.CArray : ast.Type
---
--- The type of the elements in the array.
---@field subtype ast.Type
---
--- The number of elements in the array.
---@field len number
---
local CArray = Type:derive()
ast.CArray = CArray

---@return ast.CArray
CArray.new = function(subtype, len)
  local o = CArray:derive()
  o.subtype = subtype
  o.len = len
  return o
end

CArray.__tostring = function(self)
  return qstr("CArray(", self.len, ',', self.subtype, ')')
end

CArray.dump = function(self, dump)
  dump:typenode("CArray", function()
    dump:tag("len", self.len)
    self.subtype:dump(dump)
  end)
end

--- Represents a typedef type. This stores the declaration of the typedef,
--- so to get more information about it, such as the name, you must access 
--- the decl.
---
--- @class ast.TypedefType : ast.Type
---
--- The declaration of the typedef.
---@field decl ast.Decl
---
local TypedefType = Type:derive()
ast.TypedefType = TypedefType

---@return ast.TypedefType
TypedefType.new = function(decl)
  local o = TypedefType:derive()
  o.decl = decl
  return o
end

TypedefType.__tostring = function(self)
  return qstr("TypedefType(", self.decl, ")")
end

TypedefType.dump = function(self, dump)
  dump:typenode("TypedefType", function()
    dump:tag("decl", self.decl)
  end)
end

--- Represents a 'tag' type. This stores a tag decl that the type represents.
---
--- @class ast.TagType : ast.Type
---
--- The declaration of the tag.
---@field decl ast.TagDecl
---
local TagType = Type:derive()
ast.TagType = TagType

---@return ast.TagType
TagType.new = function(decl)
  local o = TagType:derive()
  o.decl = decl
  return o
end

TagType.__tostring = function(self)
  return qstr("TagType(", self.decl, ")")
end

TagType.dump = function(self, dump)
  dump:typenode("TagType", function()
    dump:tag("decl", self.decl)
  end)
end

--- A 'tag' declaration, eg. one that is named. More information of the 
--- decl is stored in subtypes, such as Record, or Struct.
---
--- @class ast.TagDecl : ast.Decl
---
--- The name of the tag.
---@field name string
---
--- Whether or not this tag is considered complete.
---@field is_complete boolean
---
local TagDecl = Decl:derive()
ast.TagDecl = TagDecl

---@return ast.TagDecl
TagDecl.new = function(name)
  local o = TagDecl:derive()
  o.name = name
  return o
end

TagDecl.__tostring = function(self)
  return qstr("TagDecl(", self.name, ")")
end

TagDecl.dump = function(self, dump)
  dump:node("TagDecl", function()
    dump:tag("name", self.name)
  end)
end

--- A declaration of a typedef.
--- @class ast.TypedefDecl : ast.Decl
---
--- The name of the typedef.
---@field name string
--- 
--- The type this typedef wraps. This isn't just a declaration, because 
--- typedef declarations can wrap arbitrary types, such as pointers.
---@field subtype ast.Type
---
local TypedefDecl = Decl:derive()
ast.TypedefDecl = TypedefDecl

---@return ast.TypedefDecl
TypedefDecl.new = function(name, subtype)
  local o = TypedefDecl:derive()
  o.name = name
  o.subtype = subtype
  return o
end

TypedefDecl.__tostring = function(self)
  return qstr("TypedefDecl(", self.name, ",", self.subtype, ")")
end

TypedefDecl.dump = function(self, dump)
  dump:node("TypedefDecl", function()
    dump:tag("name", self.name)
    dump:tag("subtype", self.subtype)
  end)
end

--- A representation of an 'elaborated' type. This is a concept from clang,
--- and it represents 'sugar' wrapping some other type. In this case, 
--- Elaborated represents the way a type was actually written in the source 
--- code it was retrieved from.
---
--- @class ast.Elaborated : ast.Type
---
--- The name this type was actually written with in the source code.
---@field name string
---
--- The type this elaborated type wraps.
---@field subtype ast.Type
---
local Elaborated = Type:derive()
ast.Elaborated = Elaborated

---@return ast.Elaborated
Elaborated.new = function(name, subtype)
  local o = Elaborated:derive()
  o.name = name
  o.subtype = subtype
  return o
end

Elaborated.__tostring = function(self)
  return qstr("Elaborated(", self.name, ",", self.subtype, ")")
end

Elaborated.dump = function(self, dump)
  dump:typenode("Elaborated", function()
    dump:inline_name(self.name)
    self.subtype:dump(dump)
  end)
end

--- An enum declaration.
--- @class ast.Enum : ast.TagDecl
---
--- The elements of the enum.
---@field elems iro.List
---
local Enum = TagDecl:derive()
ast.Enum = Enum

---@return ast.Enum
Enum.new = function(name)
  local o = Enum:derive()
  o.name = name 
  o.elems = List{}
  return o
end

Enum.__tostring = function(self)
  return qstr("Enum(", self.name, ")")
end

Enum.dump = function(self, dump)
  dump:node("Enum", function()
    dump:inline_name(self.name)
    for elem in self.elems:each() do
      dump:node(elem.name, function()
        dump:inline_name(elem.value)
      end)
    end
  end)
end

--- A record declaration, which is either a struct or union.
---
--- Note that while we store inheritance relations, ecs' reflection system
--- does not support multiple inheritance. This is something we explicitly
--- avoid throughout our projects!
--- 
--- @class ast.Record : ast.TagDecl
---
--- The members of this record. These could be fields, methods, or other 
--- kinds of nested declarations that C++ supports. This list is ordered the
--- same as the members were declared in the source.
---@field members iro.List
---
--- The base class of this record, if any.
---@field base ast.Decl
--- 
--- The derived classes of this record.
---@field derived iro.List
---
local Record = TagDecl:derive()
ast.Record = Record

Record.construct = function(o, name)
  o.name = name
  o.members = List {}
  o.derived = List {}
end

---@return ast.Record
Record.new = function(name)
  local o = Record:derive()
  Record.construct(o, name)
  return setmetatable(o, Record)
end

Record.__tostring = function(self)
  return qstr("Record(", self.name, ")")
end

Record.addMember = function(self, name, decl)
  -- TODO(sushi) we could cache some info like storing fields, methods, 
  --             subtypes, etc. in their own tables.
  -- io.write("*********** Record.addMember: ", name, " to ", self.name, "\n")
  -- io.write(debug.traceback(), '\n')
  self.members:push(decl)
end

Record.dumpBase = function(self, name, dump)
  dump:node(name, function()
    dump:inline_name(self.name)
    if self.base then
      dump:tag("base", self.base)
    end
    for member in self.members:each() do
      member:dump(dump)
    end
  end)
end

--- A forward declaration of a Record decl. This is primarily for marking 
--- when a record is forward declared in the TranslationUnit. 
---
--- This avoids an issue that ecs' reflection used to have where upon 
--- encountering a forward decl, the underlying decl was inserted into the 
--- 'top-level' decl list immediately (we didn't have a concept of the 
--- translation unit back then, because ecs was trying to do too much!).
--- This made generating code based on reflection very difficult to do 
--- properly, as the order in which dependended on each other was not 
--- properly stored.
---
--- If there exists a definition of the underlying record, then it is stored
--- on this node. 
---
--- Perhaps we should store all forward declarations, but for now I think this
--- is all we need.
---
--- @class ast.ForwardRecord : ast.Decl
---
--- The underlying decl, if it is defined in the containing translation unit.
---@field decl ast.Record
---
local ForwardRecord = Decl:derive()
ast.ForwardRecord = ForwardRecord

---@return ast.ForwardRecord
ForwardRecord.new = function(name, decl)
  local o = ForwardRecord:derive()
  o.name = name
  o.decl = decl
  return o
end

ForwardRecord.__tostring = function(self)
  return qstr("ForwardRecord(", self.name, ")")
end

ForwardRecord.dump = function(self, dump)
  dump:node("ForwardRecord", function()
    dump:inline_name(self.name)
    dump:tag("decl", self.decl or "<incomplete>")
  end)
end

--- A field of a record.
---
--- @class ast.Field : ast.Decl
---
--- The name of the field.
---@field name string
---
--- The type of the field.
---@field type ast.Type
---
--- The offset in BITS of this field into the record it belongs 
--- to.
---@field offset number
---
local Field = Decl:derive()
ast.Field = Field

---@return ast.Field
Field.new = function(name, type, offset)
  local o = Field:derive()
  o.name = name
  o.type = type
  o.offset = offset
  return o
end

Field.__tostring = function(self)
  return qstr("Field(", self.name, ",", self.type, ")")
end

Field.dump = function(self, dump)
  dump:node("Field", function()
    dump:inline_name(self.name)
    dump:tag("offset", self.offset)
    self.type:dump(dump)
  end)
end

--- A struct declaration. This type exists primarily as a convenience for 
--- checking if a decl is specifically a struct, not a union.
--- 
--- @class ast.Struct : ast.Record
---
local Struct = Record:derive()
ast.Struct = Struct

---@return ast.Struct
Struct.new = function(name)
  local o = Struct:derive()
  Record.construct(o, name)
  return o
end

Struct.__tostring = function(self)
  return qstr("Struct(", self.name, ")")
end

Struct.dump = function(self, dump)
  Record.dumpBase(self, "Struct", dump)
end

--- A union declaration. This type exists primarily as a convenience for 
--- checking if a decl is specifically a union, not a struct.
--- 
--- @class ast.Union : ast.Record
---
local Union = Record:derive()
ast.Union = Union

---@return ast.Union
Union.new = function(name)
  local o = Union:derive()
  Record.construct(o, name)
  return o
end

Union.__tostring = function(self)
  return qstr("Union(", self.name, ")")
end

Union.dump = function(self, dump)
  Record.dumpBase(self, "Union", dump)
end

--- A specialization of a template. Note that at the moment, we don't support
--- representing the specialized template decl as an ast.Decl. We just store
--- its name. I don't remember why. Maybe we should...
---
--- @class ast.TemplateSpec : ast.Record
---
--- The arguments to this template specialization.
---@field args iro.List
---
--- The name of the template that this specialization is of.
---@field specialized_name string
---
local TemplateSpec = Record:derive()
ast.TemplateSpec = TemplateSpec

---@return ast.TemplateSpec
TemplateSpec.new = function(name, specialized_name)
  local o = TemplateSpec:derive()
  Record.construct(o, name)
  o.specialized_name = specialized_name
  o.args = List {}
  return o
end

TemplateSpec.__tostring = function(self)
  local buf = buffer.new()
  buf:put("TemplateSpec(", self.specialized_name)
  for arg in self.args:each() do
    buf:put ","
    if type(arg) == "number" then
      buf:put(arg)
    else
      buf:put(tostring(arg))
    end
  end
  buf:put ")"
  return buf:get()
end

TemplateSpec.dump = function(self, dump)
  Record.dumpBase(self, "TemplateSpec", dump)
end

--- A function declaration. At the moment, these only exist to represent 
--- methods of record decls, and their use is very limited.
---
--- @class ast.Function : ast.Decl
---
local Function = Decl:derive()
ast.Function = Function

---@return ast.Function
Function.new = function(name)
  local o = Function:derive()
  o.name = name
  return o
end

Function.__tostring = function(self)
  return qstr("Function(", self.name, ")")
end

Function.dump = function(self, dump)
  dump:node("Function", function()
    dump:tag("name", self.name)
  end)
end

return ast
