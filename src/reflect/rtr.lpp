$ local cmn = require "common"
$ local ast = require "reflect.ast"

#define private public

$$$
local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/**/*.lh",
}
$$$
@imported:get

@lpp.import "reflect/rtr.lh"

$ local function eachDecl(f)
$   for decl in astctx.type_decls:each() do
$     if not decl.is_anonymous then 
$       f(decl)
$     end
$   end
$ end

namespace rtr
{

$ local decls_with_metadata = {}
$ eachDecl(function(decl)
$   local has_metadata = false
$   for _ in pairs(decl.metadata) do
$     has_metadata = true
$     decls_with_metadata[decl.type.name] = true
$     break
$   end
$   if decl:is(ast.TypedefDecl) then return end

/* ----------------------------------------------------------------------------
 */
template<>
TypeId getTypeId<$(decl.type.name)>()
{
  return "$(decl.type.name)"_typeid;
}

/* ----------------------------------------------------------------------------
 */
template<>
String getTypename<$(decl.type.name)>()
{
  return "$(decl.type.name)"_str;
}

$ if has_metadata then
template<>
String getMetadataValue<"$(decl.type.name)"_typeid>(String name)
{
  switch (name.hash())
  {
$ for k,v in pairs(decl.metadata) do
  case "$(k)"_hashed:
    return R"mval($(v))mval"_str;
$ end
  }

  return nil;
}
$ end

$ if decl:is(ast.Enum) then
/* ----------------------------------------------------------------------------
 */
template<>
String getEnumElementName($(decl.type.name) x)
{
$ local placed_values = {}
  switch (x)
  {
$ for elem in decl.elems:each() do
$   if not placed_values[elem.value] then
$     placed_values[elem.value] = true
  case $(decl.type.name)::$(elem.name):
    return "$(elem.name)"_str;
$   end
$ end
  }

  return "** Invalid value for enum $(decl.type.name) **"_str;
}
$ end

$ end)

/* ----------------------------------------------------------------------------
 */
String getMetadataValue(TypeId type, String name)
{
  switch (type.val)
  {
$ eachDecl(function(decl)
$   if decls_with_metadata[decl.type.name] then
  case "$(decl.type.name)"_typeid_val:
$     if decl:is(ast.TypedefDecl) then
    switch (name.hash())
    {
$       for k,v in pairs(decl.metadata) do
    case "$(k)"_hashed:
      return "$(v)"_str;
$       end
    }
    break;
$     else
    return getMetadataValue<"$(decl.type.name)"_typeid>(name);
$     end
$   end
$ end)
  }
  return nil;
}

/* ----------------------------------------------------------------------------
 */
String typenameFromTypeId(TypeId type)
{
  switch (type.val)
  {
$ local placed = {}
$ eachDecl(function(decl)
$   if not placed[decl.type.name] then
  case "$(decl.type.name)"_typeid_val:
    return "$(decl.type.name)"_str;
$     placed[decl.type.name] = true
$   end
$ end)
  }

  return "** unknown typeid **"_str;
}

/* ----------------------------------------------------------------------------
 */
u64 typeSizeFromTypeId(TypeId type)
{
  switch (type.val)
  {
$ local placed = {}
$ eachDecl(function(decl)
$   if not decl.is_complete then return end
$   if not placed[decl.type.name] then
  case "$(decl.type.name)"_typeid_val: return sizeof($(decl.type.name));
$     placed[decl.type.name] = true
$   end
$ end)
  }
  assert(false);
  return 0;
}

}
