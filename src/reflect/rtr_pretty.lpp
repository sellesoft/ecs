$ local cmn = require "common"
$ local ast = require "reflect.ast"
$ local List = require "iro.List"
$ local glob = require "iro.fs.glob"

#define private public

$ if not ECS_GEN_PRETTY_PRINT or 0 == ECS_GEN_PRETTY_PRINT then

@log.import
@lpp.import "reflect/rtr.lh"

namespace rtr
{

/* ----------------------------------------------------------------------------
 */
void prettyPrint(
    io::WStream* out, 
    rtr::TypeId type, 
    const void* val,
    const PrettyPrintOpts& opts)
{
  @log.warn(reflect, "rtr::prettyPrint was not enabled for this build!\n");
}

/* ----------------------------------------------------------------------------
 */
void prettyPrint(
    rtr::TypeId type, 
    const void* val,
    const PrettyPrintOpts& opts)
{
  @log.warn(reflect, "rtr::prettyPrint was not enabled for this build!\n");
}

}

$ else

$$$

local AstContext = require "reflect.AstContext"

ECS_REFLECTION_IMPORT = true

local imported = require "string.buffer" .new()
local function importpattern(pattern)
  glob(pattern):each(function(path)
    if not path:find "ServerAllocator" and
       not path:find "server" and
       not path:find "Window_linux" and
       not path:find "Profiling.lh"
    then
      local result = lpp.import(path)

      if result then
        imported:put((result:getOutput()) or "")
      end
    end
  end)
end

importpattern "src/**/*.lh"

local astctx = require "reflect.AstContext".fromString(tostring(imported))

-- io.write(ast.dump(astctx.translation_unit), '\n')

-- Shorthand helper for looking up a declaration by name.
local function lookup(name)
  return astctx:lookupTypeDecl(name)
end

$$$
@imported:get

$ local reflect_types = require "reflect.types.get" (astctx)

namespace rtr
{

struct Printer
{
  io::WStream* out;

  // The current nesting depth, incremented when printing structs and 
  // such.
  u64 depth = 0;

  const PrettyPrintOpts& opts;

  Printer(
    io::WStream* out,
    const PrettyPrintOpts& opts) 
    : out(out),
      opts(opts) {}

  // Small stack of addresses we have already dereferenced and will not 
  // dereference again, to avoid showing the same data at an address multiple 
  // times and to avoid cyclical references causing infinite loops.
  // If this fills up, we just don't reference addresses anymore.
  StackArray<const void*, 64> dereferenced_addresses;

  void indent()
  {
    for (u64 i = 0; i < depth; ++i)
      io::format(out, ' ');
  }

  struct ScopedIndent
  {
    Printer& printer;

    ScopedIndent(Printer& printer) : printer(printer) { printer.depth++; }
    ~ScopedIndent() { printer.depth--; }
  };

$ local function scopedIndent() 
$   -- TODO(sushi) lpp needs a proper way to get file/line like the macros 
$   --             in the C preprocessor.
  ScopedIndent __indent_(*this);
$ end

$ -- * ------------------------------------------------------------------------

$ local putDeclPrinter
$ local putTypePrinter
$ local placed_decls = List {}

$ -- * ------------------------------------------------------------------------

$ local function recordPlaced(decl)
$   decl.user = decl.user or {}
$   decl.user.placed = true
$   placed_decls:push(decl)
$ end

$ -- * ------------------------------------------------------------------------

$ local function getPrinterName(decl)
$   return "prettyPrint_"..decl:formCSafeName()
$ end

$ -- * ------------------------------------------------------------------------

$ local function getTypePrinterName(type)
$   type = type:desugar()
$   if type:is(ast.TagType) then
$     return (getPrinterName(type.decl))
$   elseif type:is(ast.Builtin) then
$     return "prettyPrint_"..type:formCSafeName()
$   else
$     error("unhandled type passed to getTypePrinterName: "..tostring(type))
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ local function getPrinterSig(decl)
$   return getPrinterName(decl)..
$          "(const "..decl.type.name.."& val)"
$ end

$ -- * ------------------------------------------------------------------------

$ local function declareDeclPrinter(decl)
$   recordPlaced(decl)
$   return "void "..getPrinterSig(decl)
$ end

$ -- * ------------------------------------------------------------------------

$ local function declareDeclPrinterFromName(name)
$   local decl = lookup(name)
$   if not decl then
$     error("failed to get decl for '"..name.."'")
$   end
$   return declareDeclPrinter(decl)
$ end

$ -- * ------------------------------------------------------------------------

$ local function putAmbiguousNumberPrinter(builtin, cast)
  /* --------------------------------------------------------------------------
   */
  void prettyPrint_$(builtin:formCSafeName())($(builtin.name) val)
  {
    io::format(out, ($(cast))val);
  }
$ end

$ -- * ------------------------------------------------------------------------

$ local function putNumberPrinter(builtin)
$   if builtin.name == "void" then
$     return
$   else
$     -- WHy the FUCK did C define all therse STUPID ASS TYPES
$     local ambiguous_types = 
$     {
$       ["long long"] = "s64",
$       ["unsigned long long"] = "u64",
$       ["signed long long"] = "s64",
$       ["long double"] = "f64",
$       -- whatever dude
$       ["__int128"] = "s64",
$       ["unsigned __int128"] = "u64",
$     }
$     local ambiguous = ambiguous_types[builtin.name]
$     if ambiguous then
$       putAmbiguousNumberPrinter(builtin, ambiguous)
$     else
  /* --------------------------------------------------------------------------
   */
  void prettyPrint_$(builtin:formCSafeName())($(builtin.name) val)
  {
    io::format(out, val);
  }
$     end
$   end
$ end

$ for _,builtin in pairs(ast.builtins) do
$   putNumberPrinter(builtin)
$ end

$ -- * ------------------------------------------------------------------------

  /* --------------------------------------------------------------------------
   */
  $(declareDeclPrinterFromName "iro::utf8::String")
  {
    io::formatv(out, '"', val, '"');
  }

$ -- * ------------------------------------------------------------------------

$ local function putVec2Printer(name)
  /* --------------------------------------------------------------------------
   */
  $(declareDeclPrinterFromName(name))
  {
    io::formatv(out, val);
  }
$ end

$ putVec2Printer "vec2<int>"
$ putVec2Printer "vec2<float>"

$ -- * ------------------------------------------------------------------------

  $(declareDeclPrinterFromName "Rect")
  {
    io::format(out, val);
  }

$ -- * ------------------------------------------------------------------------

  $(declareDeclPrinterFromName "Color")
  {
    io::formatv(out, val, ' ', 
      "\e[48;2;", val.r, ";", val.g, ";", val.b, "m", "     ", "\e[0m");
  }

$ -- * ------------------------------------------------------------------------

$ local function callTypePrinter(type, valaccess)
$   if type:is(ast.Pointer) then
    if ($(valaccess) == nullptr)
    {
      io::formatv(out, "nullptr"_str);
    }
    else
    {
$     local can_deref = true
$     local subtype = type.subtype:desugar()
$     if subtype:is(ast.TagType) then
$       -- Can't deref incomplete types.
$       if subtype.decl:is(ast.ForwardRecord) then
$         can_deref = false
$       end
$     elseif subtype:is(ast.Builtin) and subtype.name == "void" then
$       can_deref = false
$     end
$     if can_deref then
      if (!opts.deref_ptrs)
      {
        io::formatv(out, "ptr(", $(valaccess), ")");
      }
      else if (dereferenced_addresses.isFull())
      {
        io::formatv(out, "<deref limit hit> ptr(", $(valaccess), ")");
      }
      else
      {
        b8 should_deref = true;
        for (const void* dereffed : dereferenced_addresses)
        {
          if (dereffed == $(valaccess))
          {
            should_deref = false;
            io::formatv(out, "<already deref'd> ptr(", $(valaccess), ")");
            break;
          }
        }

        if (should_deref)
        {
          dereferenced_addresses.push($(valaccess));
$       callTypePrinter(type.subtype, "*("..valaccess..")")
        }
      }
$     else
    io::formatv(out, "ptr(", $(valaccess), ")");
$     end
    }
$   elseif type:is(ast.Reference) then
    io::formatv(out, "ref(", &$(valaccess), ")");
$   elseif type:is(ast.FunctionPointer) then
    io::formatv(out, "funcptr");
$   elseif type:is(ast.CArray) then
$     local subtype = type.subtype
    {
      io::format(out, '\n');
      @scopedIndent
      for (s32 i = 0; i < $(type.len); ++i)
      {
        indent();
        io::formatv(out, '[', i, "]: ");
        @scopedIndent
$     callTypePrinter(subtype, valaccess.."[i]")
        if (i != $(type.len) - 1)
          io::format(out, '\n');

        if (opts.hide_long_arrays && i >= 10)
        {
          indent();
          io::formatv(out, "... ", $(type.len) - i, " more elems\n");
          break;
        }
      }
    }
$   else
$     type = type:desugar()
$     if type:is(ast.TagType) and type.decl.user.break_before_field then
    io::format(out, '\n');
$     end

    // $(tostring(type):gsub('\n', ' '))
    $(getTypePrinterName(type))($(valaccess));
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ local function putStructPrinter(decl)
$   for field in decl:eachField() do
$     putTypePrinter(field.type)
$   end
$
$   for nested in decl:eachNestedRecord() do
$     putDeclPrinter(nested)
$   end
$
$   for nested in decl:eachNestedEnum() do
$     if not nested.is_anonymous then
$       putDeclPrinter(nested)
$     end
$   end

  /* --------------------------------------------------------------------------
   */
  $(declareDeclPrinter(decl))
  {
    @scopedIndent
      
    if (opts.depth_limit && depth > opts.depth_limit)
    {
      indent();
      io::format(out, "...");
      return;
    }

$ if decl.base then
    indent();
    io::formatv(out, "<$(decl.base.name)>:\n");
    $(getPrinterName(decl.base))(val);
    io::format(out, '\n');
$ end

$ for field in decl:eachField() do
$   if field.name ~= nil and field.name ~= "" then
    indent();
    io::formatv(out, "$(field.name): "_str);
$   callTypePrinter(field.type, "val."..field.name)
$   if not field.is_last then
    io::format(out, "\n");
$   end
$   end
$ end
  }
$ end

$ -- * ------------------------------------------------------------------------

$ local function putEnumPrinter(decl)
  /* --------------------------------------------------------------------------
   */
  $(declareDeclPrinter(decl))
  {
$ -- It really sucks how little semantic info C applies to its syntax but 
$ -- y'know it also rocks just not at this particular moment.
$ --
$ -- This is primarily an issue with vulkan's enums. Oh well.
$ local val_to_name = {}
$ for elem in decl.elems:each() do
$   val_to_name[elem.value+1] = elem.name
$ end
    switch ((s64)val)
    {
$ for val,name in ipairs(val_to_name) do
  case $(val-1):
    io::formatv(out, "$(name)", " ($(val-1))");
    break;
$ end
    }
  }
$ end

$ -- * ------------------------------------------------------------------------

$ local function putArrayPrinter(decl)
$   local subtype = decl.args[1]
$   putTypePrinter(subtype)
$   local len_access = decl.specialized == 
$         reflect_types.Array and "len" or "len()"

  /* --------------------------------------------------------------------------
   */
  $(declareDeclPrinter(decl))
  {
    @scopedIndent

    if (val.$(len_access) == 0)
    {
      indent();
      io::formatv(out, "{empty}");
      return;
    }

    for (s32 i = 0; i < val.$(len_access); ++i)
    {
      indent();
      io::formatv(out, '[', i, "]:");
      @scopedIndent
      if (i >= val.$(len_access))
        break; // NOTE(sushi) extra check incase we are printing something 
               //             that is touched by another thread.
$     callTypePrinter(subtype, "val[i]")
      if (i != val.$(len_access) - 1)
        io::format(out, '\n');

      if (opts.hide_long_arrays && i >= 10)
      {
        indent();
        io::formatv(out, "[", val.$(len_access) - i, " more elems..]\n");
        break;
      }
    }
  }
$ end

$ -- * ------------------------------------------------------------------------

$ local function putFlagsPrinter(decl)
$   local subtype = decl.args[1]
$   putTypePrinter(subtype)
$ 
  /* --------------------------------------------------------------------------
   */
  $(declareDeclPrinter(decl))
  {
    b8 first = true;

$ for elem in subtype.decl.elems:each() do
    if (val.test($(subtype.name)::$(elem.name)))
    {
      if (!first)
        io::formatv(out, " | ");
      io::formatv(out, "$(elem.name)");
      first = false;
    }
$ end
  }
$  decl.user.break_before_field = false
$ end

$ -- * ------------------------------------------------------------------------

$ local function putStringMapPrinter(decl)
$   local subtype = decl.args[1]
  /* --------------------------------------------------------------------------
   */
  $(declareDeclPrinter(decl))
  {
    @scopedIndent

    if (val.len == 0)
    {
      io::format(out, "{empty}");
      return;
    }

    for (s32 i = 0; i < val.len; ++i)
    {
      indent();
      io::formatv(out, val.slots[i].key, ":");
      @scopedIndent
$     callTypePrinter(subtype, "val.slots[i].elem")
      if (val.len - 1 != i)
        io::format(out, '\n');
    }
  }
$ end

$ -- * ------------------------------------------------------------------------

$ local function putEnumBitArrayPrinter(decl)
$   local enum = decl.args[1].decl
  /* --------------------------------------------------------------------------
   */
  $(declareDeclPrinter(decl))
  {
    @scopedIndent
  
    if (!val.testAny())
    {
      indent();
      io::format(out, "{empty}");
      return;
    }
    
    b8 first = true;
$   for elem in enum.elems:each() do
    if (val.test($(enum.type.name)::$(elem.name)))
    {
      // if (!first)
      //   io::format(out, '\n');
      // first = false;

      io::formatv(out, "$(elem.name)", ' ');
    }
$   end
  }
$  decl.user.break_before_field = false
$ end

$ -- * ------------------------------------------------------------------------

$ local function putDLinkedPoolPrinter(decl)
$   local subtype = decl.args[1]
$   local subdecl = subtype:desugar().decl
$   print(subdecl)
    $(declareDeclPrinter(decl))
    {
      for (auto& elem : val)
      {
        @scopedIndent
$   callTypePrinter(subtype, "elem")
        io::format(out, '\n');
      }
    }
$ end

$ -- * ------------------------------------------------------------------------

$ local function putDListPrinter(decl)
$   local subtype = decl.args[1]
  $(declareDeclPrinter(decl))
  {
    @scopedIndent

    for (auto& elem : val)
    {
      @scopedIndent
$     callTypePrinter(subtype, "elem")
      io::format(out, '\n');
    }
  }
$ end

$ -- * ------------------------------------------------------------------------

$ local function putAVLPrinter(decl)
$   local subtype = decl.args[1]
  $(declareDeclPrinter(decl))
  {
    for (auto& elem : val)
    {
      @scopedIndent
$    callTypePrinter(subtype, "elem")
      io::format(out, '\n');
    }
  }
$ end

$ -- * ------------------------------------------------------------------------

$ local function putAtomicPrinter(decl)
$   local subtype = decl.args[1]
  $(declareDeclPrinter(decl))
  {
$   callTypePrinter(subtype, "val.loadRelaxed()")
  }
$  decl.user.break_before_field = false
$ end

$ -- * ------------------------------------------------------------------------

$ local function putTypedPtrPrinter(decl)
$   local subtype = decl.args[1]
$   local subdecl = subtype.decl
$   for derived in subdecl.derived:each() do
$     putDeclPrinter(derived)
$   end
  $(declareDeclPrinter(decl))
  {
    if (isnil(val.type))
      io::format(out, "invalid type");

    switch (val.type.val)
    {
$ for derived in subdecl.derived:each() do
    case "$(derived.qname)"_typeid_val:
      {
        @scopedIndent
        indent();
        io::formatv(out, "type: $(derived.qname)");
        auto* ptr = val.getAs<$(derived.qname)>();
$   callTypePrinter(derived.type, "*ptr")
      }
      break;
$ end
    default: 
      io::format(out, "invalid type");
    }
  }
$ end

$ -- * ------------------------------------------------------------------------

$ local function putTemplateSpecPrinter(decl)
$   for arg in decl.args:each() do
$     if ast.Type:isTypeOf(arg) then
$       putTypePrinter(arg)
$     end
$   end
$  
$   local name = decl.specialized_name
$   if name == "Array" or name == "ArrayDef" then
$     putArrayPrinter(decl)
$   elseif name == "AVL" then
$     putAVLPrinter(decl)
$   elseif name == "DList" then
$     putDListPrinter(decl)
$   elseif name == "DLinkedPool" then
$     putDLinkedPoolPrinter(decl)
$   elseif name == "Flags" then
$     putFlagsPrinter(decl)
$   elseif name == "StringMap" then
$     putStringMapPrinter(decl)
$   elseif name == "Atomic" then
$     putAtomicPrinter(decl)
$   elseif name == "EnumBitArray" then
$     putEnumBitArrayPrinter(decl)
$   elseif name == "TypedPtr" then
$     putTypedPtrPrinter(decl)
$   else
  $(declareDeclPrinter(decl))
  {
    indent();
    io::formatv(out, "<unhandled template spec>");
  }
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ local function putRefPrinter(decl)
  /* --------------------------------------------------------------------------
   */
  $(declareDeclPrinter(decl))
  {
    if (val.isValid())
      io::formatv(out, "loaded "_str);
    else
      io::formatv(out, "not-loaded "_str);

    io::formatv(out, '"', val.name, '"');
  }
$   decl.user.break_before_field = false
$ end


$ -- * ------------------------------------------------------------------------

$ local function putRecordPrinter(decl)
$   decl.user.break_before_field = true
$   if decl.base then
$     putDeclPrinter(decl.base)
$   end
$ 
$   for nested in decl:eachNestedRecord() do
$     if not nested.is_anonymous then
$       putDeclPrinter(nested)
$     end
$   end
$
$   if decl:findMetadata "ref" then
$     putRefPrinter(decl)
$   elseif decl:is(ast.TemplateSpec) then
$     putTemplateSpecPrinter(decl)
$   elseif decl:is(ast.Struct) then
$     putStructPrinter(decl)
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ local placing = {}
$ putDeclPrinter = function(decl)
$   decl.user = decl.user or {}
$   if decl.user.placed then return end
$
$   if decl.user.placing then
$     return
$   end
$
$   decl.user.placing = true
$ 
$   if decl:is(ast.TagDecl) then
$     if decl:is(ast.Record) then
$       putRecordPrinter(decl)
$     elseif decl:is(ast.Enum) then
$       putEnumPrinter(decl)
$     end
$   end
$   decl.user.placing = false
$ end

$ -- * ------------------------------------------------------------------------

$ local type_nest = 0
$ putTypePrinter = function(type)
$   type_nest = type_nest + 1
$   if type_nest > 50 then
$     error "bad recurse"
$   end
$   type = type:desugar()
$   if type:is(ast.TagType) then
$     putDeclPrinter(type.decl)
$   elseif type:is(ast.CArray) then
$     putTypePrinter(type.subtype)
$   end
$   type_nest = type_nest - 1
$ end

$ -- * ------------------------------------------------------------------------

$ local function putDeclListPrinters(list)
$   for decl in list:each() do
$     if decl:is(ast.TagDecl) and not decl.is_anonymous then
$       putDeclPrinter(decl)
$     elseif decl:is(ast.Namespace) then
$       putDeclListPrinters(decl.decls)
$     end
$   end
$ end

$ putDeclListPrinters(astctx.translation_unit.decls)

};

/* ----------------------------------------------------------------------------
 */
void prettyPrint(
    io::WStream* out, 
    rtr::TypeId type, 
    const void* val,
    const PrettyPrintOpts& opts)
{
  Printer printer(out, opts);

  switch (type.val)
  {
$ for decl in placed_decls:each() do
  case "$(decl.type.name)"_typeid_val:
    printer.$(getPrinterName(decl))(*(const $(decl.type.name)*)val);
    break;
$ end
  }

  io::format(out, '\n');
}

/* ----------------------------------------------------------------------------
 */
void prettyPrint(
    rtr::TypeId type, 
    const void* val,
    const PrettyPrintOpts& opts)
{
  prettyPrint(fs::stdout(), type, val, PrettyPrintOpts());
}

}

$ end
