/*
 *  Internal representation of our source data format.
 */

#include "iro/Common.h"
#include "iro/Unicode.h"
#include "iro/containers/Array.h"
#include "iro/containers/AVL.h"
#include "iro/io/Stream.h"

// TODO(sushi) this sucks.
#include "math/vec.h"

using namespace iro;

struct SourceDataFile;

/* ============================================================================
 */
struct SourceData
{
  // NOTE(sushi) all Strings on a SourceData are ALWAYS assumed to be 
  //             stored elsewhere! A SourceData will NEVER clean up 
  //             Strings stored on it upon deletion!!!
  //             Typically, the Strings are allocated from the SourceDataFile
  //             containing this SourceData, however this may not always
  //             be the case!

  String name = nil;

  struct Value
  {
    enum class Kind : u8
    {
      None,
      String,
      Number,
      NumberHex,
      True,
      False,
    };

    String str = nil;
    Kind kind = Kind::None;
  };

  Value val = {};
  String type = nil;

  SourceData* base = nullptr;

  // The line/column this SourceData was found at in the input text we 
  // parsed it from. Note that its up to the user to keep track of the 
  // actual input some SourceData came from.
  u32 line;
  u32 column;

  Array<SourceData*> children = nil;

  SourceData() {}

  /* --------------------------------------------------------------------------
   */
  b8 hasStringValue() const
  {
    return notnil(val.str) && val.kind == Value::Kind::String;
  }

  /* --------------------------------------------------------------------------
   */
  b8 hasNumberValue() const
  {
    return notnil(val.str) && val.kind == Value::Kind::Number;
  }

  /* --------------------------------------------------------------------------
   */
  b8 hasNumberHexValue() const
  {
    return notnil(val.str) && val.kind == Value::Kind::NumberHex;
  }

  /* --------------------------------------------------------------------------
   */
  b8 hasBooleanValue() const
  {
    return  
      val.kind == Value::Kind::True ||
      val.kind == Value::Kind::False;
  }

  /* --------------------------------------------------------------------------
   */
  b8 testBooleanValue() const
  {
    assert(hasBooleanValue());
    return val.kind == Value::Kind::True;
  }

  /* --------------------------------------------------------------------------
   */
  b8 hasObjectData() const
  {
    return notnil(children);
  }

  /* --------------------------------------------------------------------------
   */
  b8 hasChildren() const
  {
    return hasObjectData() && children.len != 0;
  }

  /* --------------------------------------------------------------------------
   */
  SourceData* addChild(SourceData* sdata)
  {
    assert(hasObjectData());
    children.push(sdata);
    return sdata;
  }

  /* --------------------------------------------------------------------------
   */
  b8 hasData() const
  {
    return hasObjectData()  || 
           hasStringValue() || 
           hasNumberValue() ||
           hasNumberHexValue();
  }

  /* --------------------------------------------------------------------------
   */
  void destroy()
  {
    if (hasChildren())
    {
      for (SourceData* child : children)
        child->destroy();
    }

    children.destroy();
  }

  /* --------------------------------------------------------------------------
   */
  const SourceData* findChildByName(String name) const
  {
    if (hasObjectData())
    {
      for (const SourceData* child : children)
      {
        if (child->name == name)
          return child;
      }
    }
    
    // If we dont have the child, try asking base for it if we have one.
    if (base != nullptr)
      return base->findChildByName(name);

    return nullptr;
  }

  /* --------------------------------------------------------------------------
   */
  SourceData* findChildByName(String name)
  {
    return (SourceData*)((const SourceData*)this)->findChildByName(name);
  } 

  /* --------------------------------------------------------------------------
   */
  SourceData* deepCopy(SourceDataFile* sfile);

  /* --------------------------------------------------------------------------
   *  Reading helpers.
   */
  u64 as_u64()
  {
    assert(val.kind == Value::Kind::Number);
    return atoll((char*)val.str.ptr);
  }

  f32 as_f32()
  {
    assert(val.kind == Value::Kind::Number);
    return atof((char*)val.str.ptr);
  }

  vec2f as_vec2f()
  {
    assert(hasObjectData());
    assert(children.len == 2);
    return vec2f(children[0]->as_f32(), children[1]->as_f32());
  }

  /* --------------------------------------------------------------------------
   *  Editing helpers.
   */

  // Adds generic data without any internal Value type or child data.
  // `name` and `type` may be nil. This SourceData must be Object data.
  SourceData* addData(SourceDataFile& file, String name, String type);

  void        setObject(String name);
  SourceData* addObject(SourceDataFile& file, String name);
  SourceData* addObject(SourceDataFile& file, String name, String type);



  void setStringValue(String value)
  {
    val.kind = Value::Kind::String;
    val.str = value;
  }

  void setStringValue(SourceDataFile& file, String value);

  SourceData* addStringValue(
    SourceDataFile& file, String name, String value);

  SourceData* addStringValue(SourceDataFile& file, String value)
    { return addStringValue(file, nil, value); }
  
  // TODO(sushi) make this explicitly f32/f64 (or always f64) if that 
  //             ever becomes an issue.
  void setNumberValue(SourceDataFile& file, f32 val);
  SourceData* addNumberValue(SourceDataFile& file, f32 val);
  SourceData* addNumberValue(SourceDataFile& file, String name, f32 val);

  void setIntValue(SourceDataFile& file, s64 val);
  SourceData* addIntValue(SourceDataFile& file, s64 val);
  SourceData* addIntValue(SourceDataFile& file, String name, s64 val);

  void setUIntValue(SourceDataFile& file, u64 val);
  SourceData* addUIntValue(SourceDataFile& file, u64 val);
  SourceData* addUIntValue(SourceDataFile& file, String name, u64 val);

  void setHexValue(SourceDataFile& file, u64 val);

  void setBooleanValue(b8 value)
  {
    val.kind = value? Value::Kind::True : Value::Kind::False;
  }

  void        setVec2f(SourceDataFile& file, vec2f v);
  SourceData* addVec2f(SourceDataFile& file, String name, vec2f v);

  void        setVec2i(SourceDataFile& file, vec2i v);
  SourceData* addVec2i(SourceDataFile& file, String name, vec2i v);

  void        setVec2u(SourceDataFile& file, vec2u v);
  SourceData* addVec2u(SourceDataFile& file, String name, vec2u v);

  /* --------------------------------------------------------------------------
   */
  void dump(u32 depth = 0) const;
  void dump(io::WStream* out, u32 depth = 0) const;
};
