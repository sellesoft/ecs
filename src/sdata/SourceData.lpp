$ local cmn = require "common"

@lpp.import "sdata/SourceData.lh"
@lpp.import "sdata/SourceDataFile.lh"

@lpp.import "Color.lh"

#include "iro/io/Stream.h"
#include "iro/fs/fs.h"

#include "stdlib.h"

using namespace iro;

/* ----------------------------------------------------------------------------
 */
u8 SourceData::as_u8()
{
  assert(val.kind == Value::Kind::Number);
  s64 v = atoll((char*)val.str.ptr);
  assert(v >= 0 && v <= 255);
  return v;
}

/* ----------------------------------------------------------------------------
 */
u64 SourceData::as_u64()
{
  assert(val.kind == Value::Kind::Number);
  return atoll((char*)val.str.ptr);
}

/* ----------------------------------------------------------------------------
 */
f32 SourceData::as_f32()
{
  assert(val.kind == Value::Kind::Number);
  return atof((char*)val.str.ptr);
}

/* ----------------------------------------------------------------------------
 */
Color SourceData::as_Color()
{
  Color result = {};
  if (hasObjectData())
  {
    if (SourceData* r = findChildByName("r"_str))
      result.r = r->as_u8();
    if (SourceData* g = findChildByName("g"_str))
      result.g = g->as_u8();
    if (SourceData* b = findChildByName("b"_str))
      result.b = b->as_u8();
    if (SourceData* a = findChildByName("a"_str))
      result.a = a->as_u8();
    else
      result.a = 255;
  }
  else if (val.kind == Value::Kind::NumberHex)
    result = u32(strtoll((char*)val.str.ptr, nullptr, 16));
  else
    assert(!"invalid SourceData for Color");
  return result;
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceData::deepCopy(SourceDataFile* sfile)
{
  SourceData* nu = sfile->allocateSourceData();

  if (notnil(name))
    nu->name = name.allocateCopy(&sfile->string_cache);
  if (notnil(type))
    nu->type = type.allocateCopy(&sfile->string_cache);

  if (!hasObjectData())
  {
    nu->val.kind = val.kind;
    if (notnil(val.str))
      nu->val.str = val.str.allocateCopy(&sfile->string_cache);
  }
  else
  {
    nu->children.init();
    for (SourceData* child : children)
      nu->children.push(child->deepCopy(sfile));
  }

  return nu;
}

/* ----------------------------------------------------------------------------
 */
void SourceData::dump(io::WStream* out, u32 depth) const
{
  auto indent = [&]()
  {
    for (u32 i = 0; i < depth; ++i)
      out->write("  "_str);
  };

  indent();
  if (notnil(name))
    io::formatv(out, name, " = ");

  if (notnil(val.str))
  {
    if (matchAny(val.kind, Value::Kind::Number, Value::Kind::NumberHex))
      io::format(out, val.str);
    else
      io::formatv(out, '"', val.str, '"');
  }
  else if (hasObjectData())
  {
    if (base != nullptr)
      io::formatv(out, base->name, " : ");

    if (notnil(type))
      io::formatv(out, type);

    if (hasChildren())
    {
      io::format(out, '\n');
      indent();
      io::format(out, "{\n");

      for (const SourceData* child : children)
      {
        child->dump(out, depth + 1);
        io::format(out, ",\n");
      }

      indent();
      io::format(out, '}');
    }
    else
    {
      io::format(out, "{}");
    }
  }
  else if (hasBooleanValue())
  {
    io::format(out, testBooleanValue()? "true" : "false");
  }
  else
  {
    // This is not defined, and is more to indicate invalid source data.
    // We could maybe define it in its language though
    io::format(out, "nil");
  }
}

/* ----------------------------------------------------------------------------
 */
void SourceData::dump(u32 depth) const
{
  dump(fs::stdout(), depth);
  io::format(fs::stdout(), '\n');
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceData::addData(SourceDataFile& file, String name, String type)
{
  assert(hasObjectData());

  SourceData* child = addChild(file.allocateSourceData());
  child->name = name;
  child->type = type;
  return child;
}

/* ----------------------------------------------------------------------------
 */
void SourceData::setObject(String name)
{
  if (!hasObjectData())
    children.init();
  else
    children.clear();

  if (notnil(name))
    this->name = name;
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceData::addObject(SourceDataFile& file, String name)
{
  return addObject(file, name, nil);
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceData::addObject(
    SourceDataFile& file, 
    String name, 
    String type)
{
  SourceData* child = file.allocateSourceData();
  child->children.init();

  children.push(child);

  child->name = name;
  child->type = type;

  return child;
}

/* ----------------------------------------------------------------------------
 */
void SourceData::setVec2f(SourceDataFile& file, vec2f v)
{
  setObject(nil);

  addNumberValue(file, "x"_str, v.x);
  addNumberValue(file, "y"_str, v.y);
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceData::addVec2f(SourceDataFile& file, String name, vec2f v)
{
  SourceData* child = file.allocateSourceData();

  children.push(child);

  child->name = name;
  child->setVec2f(file, v);

  return child;
}

/* ----------------------------------------------------------------------------
 */
void SourceData::setVec2i(SourceDataFile& file, vec2i v)
{
  setObject(nil);

  addIntValue(file, "x"_str, v.x);
  addIntValue(file, "y"_str, v.y);
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceData::addVec2i(SourceDataFile& file, String name, vec2i v)
{
  SourceData* child = file.allocateSourceData();

  children.push(child);

  child->name = name;
  child->setVec2i(file, v);

  return child;
}

/* ----------------------------------------------------------------------------
 */
void SourceData::setVec2u(SourceDataFile& file, vec2u v)
{
  setObject(nil);

  addUIntValue(file, "x"_str, v.x);
  addUIntValue(file, "y"_str, v.y);
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceData::addVec2u(SourceDataFile& file, String name, vec2u v)
{
  SourceData* child = file.allocateSourceData();

  children.push(child);

  child->name = name;
  child->setVec2u(file, v);

  return child;
}

/* ----------------------------------------------------------------------------
 */
void SourceData::setStringValue(SourceDataFile& file, String value)
{
  value = value.allocateCopy(&file.string_cache);
  setStringValue(value);
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceData::addStringValue(
    SourceDataFile& file, 
    String name,
    String value)
{
  assert(notnil(children));

  SourceData* child = file.allocateSourceData();

  children.push(child);

  if (notnil(name))
    child->name = name.allocateCopy(&file.string_cache);
  child->setStringValue(value.allocateCopy(&file.string_cache));

  return child;
}

/* ----------------------------------------------------------------------------
 */
void SourceData::setNumberValue(SourceDataFile& file, f32 value)
{
  io::StaticBuffer<64> buffer;
  io::format(&buffer, value);

  val.kind = Value::Kind::Number;
  val.str = String(buffer).allocateCopy(&file.string_cache);
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceData::addNumberValue(SourceDataFile& file, f32 val)
{
  return addNumberValue(file, nil, val);
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceData::addNumberValue(
    SourceDataFile& file,
    String name, 
    f32 value)
{
  assert(notnil(children));

  SourceData* child = file.allocateSourceData();

  children.push(child);

  child->name = name;
  child->setNumberValue(file, value);

  return child;
}

/* ----------------------------------------------------------------------------
 */
void SourceData::setIntValue(SourceDataFile& file, s64 value)
{
  io::StaticBuffer<64> buffer;
  io::format(&buffer, value);

  val.kind = Value::Kind::Number;
  val.str = String(buffer).allocateCopy(&file.string_cache);
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceData::addIntValue(SourceDataFile& file, s64 val)
{
  return addIntValue(file, nil, val);
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceData::addIntValue(
    SourceDataFile& file,
    String name, 
    s64 value)
{
  assert(notnil(children));

  SourceData* child = file.allocateSourceData();

  children.push(child);

  child->name = name;
  child->setIntValue(file, value);

  return child;
}

/* ----------------------------------------------------------------------------
 */
void SourceData::setUIntValue(SourceDataFile& file, u64 value)
{
  io::StaticBuffer<64> buffer;
  io::format(&buffer, value);

  val.kind = Value::Kind::Number;
  val.str = String(buffer).allocateCopy(&file.string_cache);
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceData::addUIntValue(SourceDataFile& file, u64 val)
{
  return addUIntValue(file, nil, val);
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceData::addUIntValue(
    SourceDataFile& file,
    String name, 
    u64 value)
{
  assert(notnil(children));

  SourceData* child = file.allocateSourceData();

  children.push(child);

  child->name = name;
  child->setUIntValue(file, value);

  return child;
}

/* ----------------------------------------------------------------------------
 */
void SourceData::setHexValue(SourceDataFile& file, u64 value)
{
  io::StaticBuffer<32> buf;
  io::format(&buf, io::Hex(value));

  val.kind = Value::Kind::NumberHex;
  val.str  = String(buf).allocateCopy(&file.string_cache);
}
