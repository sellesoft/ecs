$ local cmn = require "common"
$ local glob = require "iro.fs.glob"
$ local List = require "iro.List"
$ local minfo = require "math.info"
$ local ast = require "reflect.ast"

$$$
local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/**/*.defs.lh",
  "src/**/*.comp.lh",
}

local av = require "reflect.AstVisitor" .new(astctx)

local function lookup(name)
  return astctx:lookupDecl(name)
end

$$$
$(imported)

@lpp.import "sdata/SourceDataEditor.lh"

@lpp.import "Engine.lh"

@lpp.import "sdata/SourceData.lh"
@lpp.import "sdata/SourceDataParser.lh"

@lpp.import "ui/UI.lh"
@lpp.import "graphics/Geo.lh"

using namespace ui;

@log.import

@lpp.import "Profiling.lh"

#include "iro/io/StaticBuffer.h"

/* ============================================================================
 */
enum class NodeFlag
{
  // The type of this node displays content 'inline', i.e. in the same row
  // as its name.
  InlineContent,

  // The type of this node displays content in its 'body', i.e. below the 
  // row containing its name. 
  BodyContent,
  
  // No SourceData for this node exists in the input yet.
  MissingData,
  
  // For nodes with children, if they are open or not.
  Open,

  COUNT
};

typedef Flags<NodeFlag> NodeFlags;

/* ============================================================================
 *  Arbitrary state that a Node can allocate.
 */
struct NodeState
{
  void* ptr = nullptr;

  template<typename T>
  T* as()
  {
    assert(ptr != nullptr);
    return (T*)ptr;
  }
};

/* ============================================================================
 */
struct Node
{
  String name = nil;

  Node* next = nullptr;
  Node* first_child = nullptr;
  Node* last_child = nullptr;

  SourceData* data = nullptr;

  NodeFlags flags = {};

  rtr::TypeId type = nil;

  NodeState state;

  b8 hasChildren() const
  {
    return first_child != nullptr;
  }

  b8 isOpen() const
  {
    return flags.test(NodeFlag::Open);
  }

  b8 isMissingData() const
  {
    return flags.test(NodeFlag::MissingData);
  }
};

/* ============================================================================
 */
struct NodeIterState
{
  Node* current;

  Node* operator ++ ()
  {
    current = current->next;
    return current;
  }

  bool operator != (const NodeIterState& rhs) const
  {
    return current != rhs.current;
  }

  Node* operator -> ()
  {
    return current;
  }

  Node& operator * ()
  {
    return *current;
  }
};

struct NodeIter
{
  Node* node;

  NodeIterState begin() 
  {
    return NodeIterState { node };
  }

  NodeIterState end()
  {
    return NodeIterState { nullptr };
  }
};

/* ----------------------------------------------------------------------------
 */
NodeIter eachChild(Node* node)
{
  return NodeIter { node->first_child };
}

/* ----------------------------------------------------------------------------
 *  Formats the given args and returns a String cached in the bump buffer.
 */
static String fmt(SourceDataEditor& self, auto&&... args)
{
  io::SmallBuffer<512> buf;
  io::formatv(&buf, args...);
  return String(buf).allocateCopy(&self.bump);
}

/* ----------------------------------------------------------------------------
 */
static Node* addChild(
    SourceDataEditor& self, 
    String name, 
    Node* parent,
    SourceData* data,
    rtr::TypeId type)
{
  auto* child = self.bump.construct<Node>();

  child->name = name;
  child->data = data;
  child->type = type;

  if (parent->first_child == nullptr)
  {
    parent->first_child = child;
    parent->last_child = child;
  }
  else
  {
    parent->last_child->next = child;
    parent->last_child = child;
  }

  return child;
}

/* ----------------------------------------------------------------------------
 */
static Node* addChildAndSearchName(
    SourceDataEditor& self, 
    String name, 
    Node* parent,
    rtr::TypeId type)
{
  assert(parent->data != nullptr);

  Node* child = addChild(
    self, 
    name, 
    parent, 
    parent->data->findChildByName(name),
    type);

  if (child->data == nullptr)
  {
    // Expected data is missing (this happens with structs), 
    // so create a placeholder and mark node as missing.
    child->data = self.default_data.allocateSourceData();
    child->data->name = name;
    child->flags.set(NodeFlag::MissingData);
  }

  return child;
}

/* ----------------------------------------------------------------------------
 */
static Node* addChildFromIdx(
    SourceDataEditor& self, 
    String name, 
    Node* parent,
    rtr::TypeId type,
    u32 idx)
{
  assert(parent->data != nullptr);

  SourceData* child_data = parent->data->findChildByIndex(idx);
  assert(child_data != nullptr);

  return addChild(
    self,
    name,
    parent,
    child_data,
    type);
}

/* ----------------------------------------------------------------------------
 */
static void clearChildren(SourceDataEditor& self, Node* node)
{
  // TODO(sushi) actually clean up the children. We use a bump allocator 
  //             atm though so not really possible. I feel like this shouldn't
  //             happen much, though, so maybe not a huuuuge deal.
  node->first_child = nullptr;
  node->last_child = nullptr;
}

/* ----------------------------------------------------------------------------
 */
static void removeChild(
    SourceDataEditor& self, 
    Node* parent,
    Node* child)
{
  if (child == parent->first_child)
  {
    if (child == parent->last_child)
    {
      parent->first_child = nullptr;
      parent->last_child = nullptr;
    }
    else
    {
      parent->first_child = child->next;
    }
  }
  else
  {
    Node* preceeding = nullptr;
    for (Node& other_child : eachChild(parent))
    {
      if (other_child.next == child)
      {
        preceeding = &other_child;
        break;
      }
    }
    assert(preceeding != nullptr);

    preceeding->next = child->next;
    if (child == parent->last_child)
      parent->last_child = preceeding;
  }
}

/* ----------------------------------------------------------------------------
 */
template<typename T>
static T* allocNodeState(SourceDataEditor& self, Node* node)
{
  assert(node->state.ptr == nullptr);
  node->state.ptr = self.bump.construct<T>();
  return node->state.as<T>();
}

/* ============================================================================
 */
enum class DataPart
{
  Name,
  Type,
  Value
};

/* ----------------------------------------------------------------------------
 */
static inline String getPartString(SourceData* data, DataPart part)
{
  switch (part)
  {
  case DataPart::Name:
    return data->name;
  case DataPart::Type:
    return data->type;
  case DataPart::Value:
    return data->val.str;
  }
  return nil;
}

/* ============================================================================
 */
struct TextField
{
  ui::TextFieldState state;
  
  io::StaticBuffer<256> buffer;

  void init(SourceData* data, DataPart part)
  {
    state.edit.setBuffer(
    {
      .ptr = buffer.arr,
      .len = &buffer.len,
      .space = buffer.capacity(),
    });

    String init = getPartString(data, part);
    if (init.len > buffer.capacity())
    {
      @log.error(sdata, 
        "source data string is too long to store in a text field");
      return;
    }

    io::format(&buffer, init);
  }

  void put(
      ui::UI& ui, 
      ui::ItemId id,
      Rect bounds,
      DataPart part, 
      SourceData* data,
      const SourceDataEditorSkinDef& skin)
  {
    ui::TextFieldResult result = ui.putTextField(
      id,
      bounds,
      &state,
      skin.text_field);
    
    if (result.test(ui::TextFieldFlag::Commit))
    {
      println("commit");
    }
  }
};

$ -- * ------------------------------------------------------------------------

@[init_tree] av:funcgen(
  sde_initTree_,
  static void,
  SourceDataEditor& self,
  Node* node)

$ -- * ------------------------------------------------------------------------

@[put_inline] av:funcgen(
  sde_putInlineContent_,
  static void,
  SourceDataEditor& self,
  ui::UI& ui,
  Rect bounds,
  Node* node,
  const SourceDataEditorSkinDef& skin)

$ local inline_nodes = List {}

$ local function declareInline(node)
$   inline_nodes:push(node)
$   return put_inline.declare(node)
$ end

$ -- * ------------------------------------------------------------------------
$ -- Implement for types that need to place some inline UI before their 
$ -- children do, eg. reflect::Array's buttons.

@[put_inline_pre_child] av:funcgen(
  sde_putInlinePreChildContent_,
  static f32,
  SourceDataEditor& self,
  ui::UI& ui,
  Rect bounds,
  Node* node,
  Node* child,
  const SourceDataEditorSkinDef& skin)

$ local inline_pre_child_nodes = List {}

$ local function declareInlinePreChild(node)
$   inline_pre_child_nodes:push(node)
$   return put_inline_pre_child.declare(node)
$ end

$ -- * ------------------------------------------------------------------------

$ av:previsit(ast.iro_builtins, function(type)
$   if type == ast.builtins.b8 then
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(type))
  {
    if (node->isMissingData())
    {
      node->data->setBooleanValue(false);
    }
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(type))
  {
    b8 val = node->data->testBooleanValue();
    
    Rect button_bounds = Rect::from(bounds.x,bounds.y,bounds.h,bounds.h);

    if (ui.putCheckbox(
          "checkbox"_fid,
          button_bounds,
          &val,
          skin.checkbox))
    {
      node->data->setBooleanValue(val);
    }
  }
$   else -- Not b8
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(type)) 
  {
    allocNodeState<TextField>(self, node)->init(
      node->data,
      DataPart::Value);
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(type))
  {
    node->state.as<TextField>()->put(
      ui,
      "number-field"_fid,
      bounds,
      DataPart::Value,
      node->data,
      skin);
  }
$   end
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "iro::utf8::String", function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    allocNodeState<TextField>(self, node)->init(
      node->data,
      DataPart::Value);
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    node->state.as<TextField>()->put(
      ui,
      "string-field"_fid,
      bounds,
      DataPart::Value,
      node->data,
      skin);
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "StringHash", function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    allocNodeState<TextField>(self, node)->init(
      node->data,
      DataPart::Value);
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    node->state.as<TextField>()->put(
      ui,
      "string-field"_fid,
      bounds,
      DataPart::Value,
      node->data,
      skin);
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ local function visitVectorLikeType(decl, comps)
$   local comps = List(comps)
$   local TState = "VectorLike_"..decl:formCSafeName().."_State"
/* ============================================================================
 */
struct $(TState)
{
$ for comp in comps:each() do
  TextField $(comp);
$ end
};

$ av:visit(decl, function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    if (!node->data->hasObjectData())
      node->data->setObject(nil);

    auto* state = allocNodeState<$(TState)>(self, node);

$ for comp in comps:each() do
    {
      SourceData* comp_data = node->data->findChildByName("$(comp)"_str);
      if (comp_data == nullptr)
        comp_data = node->data->addNumberValue(
          self.default_data, 
          "$(comp)"_str, 
          0.f);
    
      state->$(comp).init(comp_data, DataPart::Value);
    }
$ end
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    auto* state = node->state.as<$(TState)>();

    Rect comp_bounds = {};
    comp_bounds.x = bounds.x;
    comp_bounds.y = bounds.y;
    comp_bounds.w = math::floor(bounds.w / $(#comps).f);
    comp_bounds.h = bounds.h;

$   local function placeNameAndField(name)
    {
      f32 comp_offset = ui.putText(comp_bounds, "$(name)"_str, skin.text).x;
      Rect field_bounds = comp_bounds
        .contractedLeft(comp_offset)
        .contractedX(6.f);

      state->$(name).put(
        ui, 
        "veclike-comp-$(name)"_fid, 
        field_bounds,
        DataPart::Value,
        node->data->findChildByName("$(name)"_str),
        skin);

      comp_bounds.x += comp_bounds.w;
    }
$   end

$   for comp in comps:each() do
$     placeNameAndField(comp)
$   end
  }
  
$ end)

$ end

$$$ 
-- Note that colors are not handled here, since they can be specified as 
-- a hex number or object data.
visitVectorLikeType(lookup "Rect", { "x", "y", "w", "h" })

local vec_comps = List { "x", "y", "z", "w" }
for vec_type in minfo.vec_types:each() do
  visitVectorLikeType(lookup(vec_type.name), vec_comps:sub(1, vec_type.len))
end
$$$

$ -- * ------------------------------------------------------------------------

/* ============================================================================
 */
struct ColorState
{
  TextField r;
  TextField g;
  TextField b;
  TextField a;
};

$ av:visit(lookup "Color", function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    if (node->data->val.kind == SourceData::Value::Kind::NumberHex)
    {
      Color val = node->data->as_Color();

      node->data->setObject(nil);

      node->data->addUIntValue(self.default_data, "r"_str, val.r);
      node->data->addUIntValue(self.default_data, "g"_str, val.g);
      node->data->addUIntValue(self.default_data, "b"_str, val.b);
      node->data->addUIntValue(self.default_data, "a"_str, val.a);
    }
    else if (!node->data->hasChildren())
    {
      node->data->setObject(nil);
    }

    auto* state = allocNodeState<ColorState>(self, node);

$ local function initCompState(comp)
    {
      SourceData* comp_data = node->data->findChildByName("$(comp)"_str);
      if (comp_data == nullptr)
        comp_data = node->data->addUIntValue(
          self.default_data, 
          "$(comp)"_str, 
          $(comp == "a" and "255" or "0"));
    
      state->$(comp).init(comp_data, DataPart::Value);
    }
$ end
    
    @initCompState "r"
    @initCompState "g"
    @initCompState "b"
    @initCompState "a"
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    auto* state = node->state.as<ColorState>();

    f32 preview_width = skin.row.height;
    f32 comps_width = bounds.w - preview_width - 5.f;

    ui.putQuad(
      Rect::from(bounds.x, bounds.y, preview_width, preview_width),
      node->data->as_Color());

    Rect comp_bounds = {};
    comp_bounds.x = bounds.x + preview_width + 5.f;
    comp_bounds.y = bounds.y;
    comp_bounds.w = math::floor(comps_width / 4.f);
    comp_bounds.h = bounds.h;

$   local function placeNameAndField(name)
    {
      f32 comp_offset = ui.putText(comp_bounds, "$(name)"_str, skin.text).x;
      Rect field_bounds = comp_bounds
        .contractedLeft(comp_offset)
        .contractedX(6.f);

      state->$(name).put(
        ui, 
        "color-comp-$(name)"_fid, 
        field_bounds,
        DataPart::Value,
        node->data->findChildByName("$(name)"_str),
        skin);

      comp_bounds.x += comp_bounds.w;
    }
$   end

    @placeNameAndField "r"
    @placeNameAndField "g"
    @placeNameAndField "b"
    @placeNameAndField "a"
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(ast.Enum, function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.stub(decl)) // no children, edited inline.
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "iro::Flags", function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.stub(decl))
$ end)

$ -- * ------------------------------------------------------------------------
  
$ av:visit(ast.Struct, function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
$ for field in decl:eachField() do
    {
      Node* child = addChildAndSearchName(
        self, 
        "$(field.name)"_str, 
        node,
        "$(field.type.qname)"_typeid);

      $(init_tree.call(field.type))(self, child);
    }
$ end
  }
$ end)

$ -- * ------------------------------------------------------------------------

static const f32 array_button_size = 14.f;

struct ArrayState
{
  Node* to_remove = nullptr;
};

$ av:visit(lookup "reflect::Array", function(decl)
$   local subtype = decl.args[1]

  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    for (s32 i = 0; i < node->data->children.len; ++i)
    {
      Node* child = addChildFromIdx(
        self,
        fmt(self, '[', i, ']'),
        node,
        "$(subtype.qname)"_typeid,
        i);

      $(init_tree.call(subtype))(self, child);
    }

    allocNodeState<ArrayState>(self, node);
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    auto* state = node->state.as<ArrayState>();

    if (state->to_remove != nullptr)
    {
      // If we need to remove a node (see the inline pre-child func below)
      // find its index, remove it from our SourceData child list, and 
      // fix the names of Node children following it.
      Node* to_remove = state->to_remove;
      state->to_remove = nullptr;

      u32 child_idx = 0;
      b8 passed = false;
      for (Node& child : eachChild(node))
      {
        defer { child_idx += 1; };

        if (&child == to_remove)
        {
          passed = true;
          node->data->children.remove(child_idx);
        }
        else if (passed)
        {
          child.name = fmt(self, '[', child_idx - 1, ']');
        }
      }

      removeChild(self, node, to_remove);
    }

    auto add_bounds = Rect::from(bounds.pos(), vec2f(array_button_size));

    if (ui.putButton("array-add"_fid,
          add_bounds,
          skin.array_add))
    {
      SourceData* child_data = self.default_data.allocateSourceData();

      Node* child = addChild(
        self,
        fmt(self, '[', node->data->children.len, ']'),
        node,
        child_data,
        "$(subtype.qname)"_typeid);

      node->data->children.push(child_data);
    }
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInlinePreChild(decl))
  {
    auto* state = node->state.as<ArrayState>();

    auto remove_bounds = Rect::from(bounds.pos(), vec2f(array_button_size));

    ui::ScopedId id(ui, ui.generateIdFromPointer(child));

    if (ui.putButton("array-remove"_fid,
          remove_bounds,
          skin.array_remove))
    {
      // Defer removal of the child. We can't just remove it here, because
      // this function is called while putNode() is interating our children.
      state->to_remove = child;
    }

    return remove_bounds.w + 5.f;
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "reflect::StringMap", function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "reflect::TypedPtr", function(decl)
$   local subtype = decl.args[1]:desugar()
$   local subdecl = subtype.decl
$   for derived in subdecl:allDerived() do
$     av:handleDecl(derived)
$   end
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    switch (node->data->type.hash())
    {
$   for derived in subdecl:allDerived() do
    case "$(derived.type.qname)"_typeid_val:
      $(init_tree.call(derived))(self, node);
      break;
$   end
    }
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    if (ui.beginDropDown("typed-ptr-dropdown"_fid,
          bounds,
          100.f,
          node->data->type,
          skin.dropdown))
    {
      Rect button_bounds = {};
      button_bounds.x = 0.f;
      button_bounds.y = 0.f;
      button_bounds.w = ui.getWidth();
      button_bounds.h = 14.f;

$   for derived in subdecl:allDerived() do
      if (ui.putButton("typed-ptr-select-$(derived.qname)"_fid,
            button_bounds,
            "$(derived.qname)"_str,
            skin.dropdown_option))
      {
        node->data->type = "$(derived.qname)"_str;
        node->data->children.clear();

        clearChildren(self, node);

        $(init_tree.call(derived))(self, node);

        println("select $(derived.qname)");
        ui.closePopup();        
      }
      button_bounds.y += button_bounds.h;
$   end

      ui.endDropDown();
    }
  }
$ end)

$ -- * ------------------------------------------------------------------------
$ -- For now, link types behave just like strings, but eventually they should
$ -- show a dropdown of assets matching the linked type.

$ av:previsit(ast.Record, function(decl)
$   if not decl:findMetadata "ref" then
$     return
$   end
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    allocNodeState<TextField>(self, node)->init(
      node->data,
      DataPart::Value);
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    node->state.as<TextField>()->put(
      ui,
      "link-field"_fid,
      bounds,
      DataPart::Value,
      node->data,
      skin);
  }
$   return av.handled
$ end)

$ -- * ------------------------------------------------------------------------
$ -- Typedefs just passthrough to their subtype for now. Eventually though 
$ -- we should be checking for metadata applied to them that may alter 
$ -- their behavior in the editor.

$ av:visit(ast.TypedefDecl, function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    $(init_tree.call(decl.subtype))(self, node);
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:begin(function(decl)
$   return decl.metadata.def ~= nil
$ end)

/* ----------------------------------------------------------------------------
 */
b8 SourceDataEditor::init()
{
  if (!bump.init())
    return false;

  if (!default_data.init())
    return false;

  return true;
}

/* ----------------------------------------------------------------------------
 */
void SourceDataEditor::setSourceData(
    SourceData* sdata, 
    SourceDataFile* sfile, 
    rtr::TypeId type_id)
{
  this->sdata = sdata;
  this->sfile = sfile;
  this->type_id = type_id;

  bump.clear();

  Node* root = bump.construct<Node>();
  root->type = type_id;
  root->data = sdata;

  root_node = root;

  switch (type_id.val)
  {
$ av:eachVisited(function(decl)
  case "$(decl.type.qname)"_typeid_val:
    $(init_tree.call(decl))(*this, root);
    break;
$ end)
  }
}

/* ============================================================================
 */
struct PutParams
{
  u32 depth = 0;
  f32 y = 0.f;
  f32 max_name_extent = 0.f;

  // x offset applied to the inline contents of the node we are placing,
  // likely due to its parent injecting some UI.
  f32 inline_offset = 0.f;

  u32* node_idx = 0;

  void bumpidx()
  {
    *node_idx += 1;
  }

  Color getRowColor(const SourceDataEditorSkinDef& skin)
  {
    return *node_idx % 2? skin.row.odd_color : skin.row.even_color;
  }
};

/* ============================================================================
 */
struct PutResult
{
  f32 height = 0.f;
};

$ -- * ------------------------------------------------------------------------

$ local function putNodeCases(node)
$   local qname
$   if node:is(ast.Type) then
$     qname = node.qname
$   else
$     qname = node.type.qname
$   end
$   if node:is(ast.Decl) then
$     if node.typedefs then
$       for typedef in node.typedefs:each() do
  case "$(typedef.type.qname)"_typeid_val:
$       end
$     end
$   end
  case "$(qname)"_typeid_val:
$ end

/* ----------------------------------------------------------------------------
 */
static void putInlineContent(
    SourceDataEditor& self,
    ui::UI& ui,
    Rect bounds,
    Node& node,
    PutParams& params,
    const SourceDataEditorSkinDef& skin)
{
  switch (node.type.val)
  {
$ for node in inline_nodes:each() do
$   putNodeCases(node)
    $(put_inline.call(node))(
      self, 
      ui, 
      bounds, 
      &node,
      skin);
    break;
$ end
  }
}

/* ----------------------------------------------------------------------------
 */
static f32 putInlineContentPreChild(
    SourceDataEditor& self,
    ui::UI& ui,
    Rect bounds,
    Node& node,
    Node& child,
    PutParams& params,
    const SourceDataEditorSkinDef& skin)
{
  f32 width = 0.f;
  switch (node.type.val)
  {
$ for node in inline_pre_child_nodes:each() do
$   putNodeCases(node)
  width = $(put_inline_pre_child.call(node))(
    self,
    ui,
    bounds,
    &node,
    &child,
    skin);
$ end
  }
  return width;
}

/* ----------------------------------------------------------------------------
 */
static inline String getNodeNamePrefix(Node& node)
{
  if (node.hasChildren())
    return node.isOpen()? "- "_str : "+ "_str;
  return "  "_str;
}

/* ----------------------------------------------------------------------------
 */
static inline Rect computeInlineBounds(
    ui::UI& ui,
    PutParams& params,
    f32 y,
    b8 use_inline_offset,
    const SourceDataEditorSkinDef& skin)
{
  Rect inline_bounds = {};
  
  inline_bounds.x = params.max_name_extent + skin.row.name_value_spacing;
  if (use_inline_offset)
    inline_bounds.x += params.inline_offset;

  inline_bounds.y = y;

  inline_bounds.w = ui.getWidth() - inline_bounds.x - skin.row.right_padding;
  inline_bounds.h = skin.row.height;

  inline_bounds.contractY(2.f);

  return inline_bounds;
}

/* ----------------------------------------------------------------------------
 */
static PutResult putNode(
    SourceDataEditor& self,
    ui::UI& ui,
    Node& node,
    PutParams& params,
    const SourceDataEditorSkinDef& skin)
{
  ui.pushId(ui.generateIdFromPointer(&node));
  defer { ui.popId(); };

  // Color row_color = params.getRowColor(skin);
  //
  // ui.putQuad(
  //   Rect::from(0.f, params.y, ui.getWidth(), skin.row.height), 
  //   row_color);
  //
  // params.bumpidx();

  auto name_bounds = Rect::from(
    params.depth * skin.children_indent,
    params.y,
    params.max_name_extent,
    skin.row.height);

  ui::Focus name_hit = ui.putFocusableBounds("name"_fid, name_bounds);
  if (name_hit.wasPrimaryReleased())
    node.flags.toggle(NodeFlag::Open);

  String prefix = getNodeNamePrefix(node);
  if (notnil(prefix))
    name_bounds.x += ui.putText(name_bounds, prefix, skin.text).x;

  vec2f name_size = ui.putText(name_bounds, node.name, skin.text);

  Rect inline_bounds = computeInlineBounds(
    ui,
    params,
    params.y,
    true,
    skin);

  putInlineContent(self, ui, inline_bounds, node, params, skin);

  f32 y = params.y + max(name_size.y, skin.row.height);

  if (node.hasChildren() && node.isOpen())
  {
    PutParams child_params = params;
    child_params.depth += 1;

    for (Node& child : eachChild(&node))
    {
      child_params.y = y;
      
      // TODO(sushi) should probably reuse this.
      Rect child_inline_bounds = computeInlineBounds(
        ui,
        params,
        child_params.y,
        false,
        skin);

      child_params.inline_offset = putInlineContentPreChild(
        self,
        ui,
        child_inline_bounds,
        node,
        child,
        params,
        skin);

      PutResult result = putNode(self, ui, child, child_params, skin);
      y += max(result.height, skin.row.height);
    }
  }

  if (name_hit.hasBeenIdleHoveredFor(ui, TimeSpan::fromSeconds(1.f)))
  {
    String type_name = rtr::typenameFromTypeId(node.type);

    auto tooltip_bounds = Rect::from(name_bounds)
      .alignBottomOutside(name_bounds, 4.f)
      .setSize(ui.measureText(Rect::inf(), type_name, skin.text))
      .expanded(5.f);

    TextItemSkin tooltip_skin = {};
    tooltip_skin.text = skin.text;
    tooltip_skin.text.align = vec2f(0.5, 0.5);
    tooltip_skin.item.color = 0x111111ff;
    tooltip_skin.item.border = Rect::from(10.f);
    tooltip_skin.item.border_color = 0xaaaaaaff;

    ui.pushLayer("type-tooltip"_fid, tooltip_bounds, {});
    ui.putTextItem(ui.getBounds(), type_name, tooltip_skin);
    ui.popLayer();
  }

  PutResult result = {};
  result.height = y - params.y;

  return result;
}

/* ----------------------------------------------------------------------------
 */
static f32 computeNodeNameExtent(
    SourceDataEditor& self,
    ui::UI& ui,
    Node& node,
    u32 depth,
    const SourceDataEditorSkinDef& skin)
{
  auto name_bounds = Rect::from(0, 0, 999.f, 999.f);

  vec2f name_size = ui.measureText(name_bounds, node.name, skin.text);

  String prefix = node.isOpen()? "- "_str : "+ "_str;
  name_size.x += ui.measureText(name_bounds, prefix, skin.text).x;

  f32 name_extent = name_size.x + skin.children_indent * depth;

  for (Node& child : eachChild(&node))
  {
    f32 child_extent = computeNodeNameExtent(
      self,
      ui,
      child,
      depth + 1,
      skin);

    name_extent = max(name_extent, child_extent);
  }

  return name_extent;
}

/* ----------------------------------------------------------------------------
 */
void SourceDataEditor::put(
    UI& ui,
    Rect bounds,
    const SourceDataEditorSkinDef& skin)
{
  ZoneScopedN("SourceDataEditor::update");

  ui.beginScrollGroup("sde-scroll"_fid, bounds, skin.scroll_bar);

  if (root_node != nullptr)
  {
    auto* root = (Node*)root_node;

    f32 max_name_extent = 0.f;
    for (Node& child : eachChild(root))
    {
      f32 child_extent = computeNodeNameExtent(*this, ui, child, 0, skin);
      max_name_extent = max(child_extent, max_name_extent);
    }

    max_name_extent = max(max_name_extent, skin.row.min_name_width);

    u32 node_idx = 0;

    PutParams params = {};
    params.depth = 0;
    params.y = 0.f;
    params.max_name_extent = max_name_extent;
    params.node_idx = &node_idx;

    for (Node& child : eachChild(root))
    {
      PutResult result = putNode(*this, ui, child, params, skin);

      params.y += max(result.height, skin.row.height);
    }
  }

  ui.endScrollGroup(skin.scroll_bar);
}
