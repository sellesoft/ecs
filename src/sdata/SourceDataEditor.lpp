$ local cmn = require "common"
$ local glob = require "iro.fs.glob"
$ local List = require "iro.List"
$ local minfo = require "math.info"
$ local ast = require "reflect.ast"

$$$
local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/**/*.defs.lh",
  "src/**/*.comp.lh",
}

local av = require "reflect.AstVisitor" .new(astctx)

local function lookup(name)
  return astctx:lookupDecl(name)
end

$$$
$(imported)

@lpp.import "sdata/SourceDataEditor.lh"

@lpp.import "Engine.lh"

@lpp.import "sdata/SourceData.lh"
@lpp.import "sdata/SourceDataParser.lh"

@lpp.import "ui/UI.lh"
@lpp.import "graphics/Geo.lh"

using namespace ui;

@log.import

@lpp.import "Profiling.lh"

#include "iro/io/StaticBuffer.h"

/* ============================================================================
 */
enum class NodeFlag
{
  // The type of this node displays content 'inline', i.e. in the same row
  // as its name.
  InlineContent,

  // The type of this node displays content in its 'body', i.e. below the 
  // row containing its name. 
  BodyContent,
  
  // No SourceData for this node exists in the input yet.
  MissingData,
  
  // For nodes with children, if they are open or not.
  Open,

  COUNT
};

typedef Flags<NodeFlag> NodeFlags;

/* ============================================================================
 *  Arbitrary state that a Node can allocate.
 */
struct NodeState
{
  void* ptr = nullptr;

  template<typename T>
  T* as()
  {
    assert(ptr != nullptr);
    return (T*)ptr;
  }
};

/* ============================================================================
 */
struct Node
{
  String name = nil;

  Node* next = nullptr;
  Node* first_child = nullptr;
  Node* last_child = nullptr;

  SourceData* data = nullptr;

  NodeFlags flags = {};

  rtr::TypeId type = nil;

  NodeState state;

  b8 hasChildren() const
  {
    return first_child != nullptr;
  }

  b8 isOpen() const
  {
    return flags.test(NodeFlag::Open);
  }

  b8 isMissingData() const
  {
    return flags.test(NodeFlag::MissingData);
  }
};

/* ============================================================================
 */
struct NodeIterState
{
  Node* current;

  Node* operator ++ ()
  {
    current = current->next;
    return current;
  }

  bool operator != (const NodeIterState& rhs) const
  {
    return current != rhs.current;
  }

  Node* operator -> ()
  {
    return current;
  }

  Node& operator * ()
  {
    return *current;
  }
};

struct NodeIter
{
  Node* node;

  NodeIterState begin() 
  {
    return NodeIterState { node };
  }

  NodeIterState end()
  {
    return NodeIterState { nullptr };
  }
};

/* ----------------------------------------------------------------------------
 */
NodeIter eachChild(Node* node)
{
  return NodeIter { node->first_child };
}

/* ============================================================================
 */
struct SDETreeState
{
  Node root_node;
  f32 divider_x;
  f32 max_name_extent;
  b8 first_frame;

  b8 dragging_divider;
};

/* ----------------------------------------------------------------------------
 *  Formats the given args and returns a String cached in the bump buffer.
 */
static String fmt(SourceDataEditor& self, auto&&... args)
{
  io::SmallBuffer<512> buf;
  io::formatv(&buf, args...);
  return String(buf).allocateCopy(&self.bump);
}

/* ----------------------------------------------------------------------------
 */
static Node* addChild(
    SourceDataEditor& self, 
    String name, 
    Node* parent,
    SourceData* data,
    rtr::TypeId type)
{
  auto* child = self.bump.construct<Node>();

  child->name = name;
  child->data = data;
  child->type = type;

  if (parent->first_child == nullptr)
  {
    parent->first_child = child;
    parent->last_child = child;
  }
  else
  {
    parent->last_child->next = child;
    parent->last_child = child;
  }

  return child;
}

/* ----------------------------------------------------------------------------
 */
static Node* addChildAndSearchName(
    SourceDataEditor& self, 
    String name, 
    Node* parent,
    rtr::TypeId type)
{
  assert(parent->data != nullptr);

  Node* child = addChild(
    self, 
    name, 
    parent, 
    parent->data->findChildByName(name),
    type);

  if (child->data == nullptr)
  {
    // Expected data is missing (this happens with structs), 
    // so create a placeholder and mark node as missing.
    child->data = self.default_data.allocateSourceData();
    child->data->name = name;
    child->flags.set(NodeFlag::MissingData);
  }

  return child;
}

/* ----------------------------------------------------------------------------
 */
static Node* addChildFromIdx(
    SourceDataEditor& self, 
    String name, 
    Node* parent,
    rtr::TypeId type,
    u32 idx)
{
  assert(parent->data != nullptr);

  SourceData* child_data = parent->data->findChildByIndex(idx);
  assert(child_data != nullptr);

  return addChild(
    self,
    name,
    parent,
    child_data,
    type);
}

/* ----------------------------------------------------------------------------
 */
static void clearChildren(SourceDataEditor& self, Node* node)
{
  // TODO(sushi) actually clean up the children. We use a bump allocator 
  //             atm though so not really possible. I feel like this shouldn't
  //             happen much, though, so maybe not a huuuuge deal.
  node->first_child = nullptr;
  node->last_child = nullptr;
}

/* ----------------------------------------------------------------------------
 */
static void removeChild(
    SourceDataEditor& self, 
    Node* parent,
    Node* child)
{
  if (child == parent->first_child)
  {
    if (child == parent->last_child)
    {
      parent->first_child = nullptr;
      parent->last_child = nullptr;
    }
    else
    {
      parent->first_child = child->next;
    }
  }
  else
  {
    Node* preceeding = nullptr;
    for (Node& other_child : eachChild(parent))
    {
      if (other_child.next == child)
      {
        preceeding = &other_child;
        break;
      }
    }
    assert(preceeding != nullptr);

    preceeding->next = child->next;
    if (child == parent->last_child)
      parent->last_child = preceeding;
  }
}

/* ----------------------------------------------------------------------------
 */
template<typename T>
static T* allocNodeState(SourceDataEditor& self, Node* node)
{
  assert(node->state.ptr == nullptr);
  node->state.ptr = self.bump.construct<T>();
  return node->state.as<T>();
}

/* ----------------------------------------------------------------------------
 */
static u32 findChildIdx(Node* node, Node* child)
{
  u32 child_idx = 0;
  for (Node& other_child : eachChild(node))
  {
    if (&other_child == child)
      return child_idx;
    child_idx += 1;
  }
  assert(!"improper child search");
}

/* ============================================================================
 */
enum class DataPart
{
  Name,
  Type,
  Value
};

/* ----------------------------------------------------------------------------
 */
static inline String getPartString(SourceData* data, DataPart part)
{
  switch (part)
  {
  case DataPart::Name:
    return data->name;
  case DataPart::Type:
    return data->type;
  case DataPart::Value:
    return data->val.str;
  }
  return nil;
}

/* ============================================================================
 */
struct TextField
{
  ui::TextFieldState state;
  
  io::StaticBuffer<256> buffer;

  void init(SourceData* data, DataPart part)
  {
    state.edit.setBuffer(
    {
      .ptr = buffer.arr,
      .len = &buffer.len,
      .space = buffer.capacity(),
    });

    String init = getPartString(data, part);
    if (init.len > buffer.capacity())
    {
      @log.error(sdata, 
        "source data string is too long to store in a text field");
      return;
    }

    io::format(&buffer, init);
  }

  void put(
      ui::UI& ui, 
      ui::ItemId id,
      Rect bounds,
      DataPart part, 
      SourceData* data,
      const SourceDataEditorSkinDef& skin)
  {
    ui::TextFieldResult result = ui.putTextField(
      id,
      bounds,
      &state,
      skin.text_field);
    
    if (result.test(ui::TextFieldFlag::Commit))
    {
      println("commit");
    }
  }
};

$ -- * ------------------------------------------------------------------------

@[init_tree] av:funcgen(
  sde_initTree_,
  static void,
  SourceDataEditor& self,
  Node* node)

$ -- * ------------------------------------------------------------------------

@[put_child_name] av:funcgen(
  sde_putChildName_,
  static f32,
  SourceDataEditor& self,
  ui::UI& ui,
  Rect bounds,
  Node* node,
  Node* child,
  u32 child_idx,
  const SourceDataEditorSkinDef& skin)

$ local child_name_placers = List {}
$ local function declarePutChildName(node)
$   child_name_placers:push(node)
$   return put_child_name.declare(node)
$ end

$ -- * ------------------------------------------------------------------------

@[put_inline] av:funcgen(
  sde_putInlineContent_,
  static void,
  SourceDataEditor& self,
  ui::UI& ui,
  Rect bounds,
  Node* node,
  const SourceDataEditorSkinDef& skin)

$ local inline_nodes = List {}
$ local function declareInline(node)
$   inline_nodes:push(node)
$   return put_inline.declare(node)
$ end

$ -- * ------------------------------------------------------------------------

@[put_body] av:funcgen(
  sde_putBody_,
  static f32,
  SourceDataEditor& self,
  ui::UI& ui,
  vec2f pos,
  f32 width,
  Node* node,
  const SourceDataEditorSkinDef& skin)

$ local body_nodes = List {}
$ local function declareBody(node)
$   body_nodes:push(node)
$   return put_body.declare(node)
$ end

$ -- * ------------------------------------------------------------------------
$ -- Implement for types that need to place some inline UI before their 
$ -- children do, eg. reflect::Array's buttons.

@[put_inline_pre_child] av:funcgen(
  sde_putInlinePreChildContent_,
  static void,
  SourceDataEditor& self,
  ui::UI& ui,
  Rect bounds,
  Node* node,
  Node* child,
  const SourceDataEditorSkinDef& skin)

$ local inline_pre_child_nodes = List {}
$ local function declareInlinePreChild(node)
$   inline_pre_child_nodes:push(node)
$   return put_inline_pre_child.declare(node)
$ end

$ -- * ------------------------------------------------------------------------

$ av:previsit(ast.iro_builtins, function(type)
$   if type == ast.builtins.b8 then
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(type))
  {
    if (node->isMissingData())
    {
      node->data->setBooleanValue(false);
    }
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(type))
  {
    b8 val = node->data->testBooleanValue();
    
    Rect button_bounds = Rect::from(bounds.x,bounds.y,bounds.h,bounds.h);

    if (ui.putCheckbox(
          "checkbox"_fid,
          button_bounds,
          &val,
          skin.checkbox))
    {
      node->data->setBooleanValue(val);
    }
  }
$   else -- Not b8
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(type)) 
  {
    allocNodeState<TextField>(self, node)->init(
      node->data,
      DataPart::Value);
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(type))
  {
    node->state.as<TextField>()->put(
      ui,
      "number-field"_fid,
      bounds,
      DataPart::Value,
      node->data,
      skin);
  }
$   end
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "iro::utf8::String", function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    allocNodeState<TextField>(self, node)->init(
      node->data,
      DataPart::Value);
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    node->state.as<TextField>()->put(
      ui,
      "string-field"_fid,
      bounds,
      DataPart::Value,
      node->data,
      skin);
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "StringHash", function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    allocNodeState<TextField>(self, node)->init(
      node->data,
      DataPart::Value);
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    node->state.as<TextField>()->put(
      ui,
      "string-field"_fid,
      bounds,
      DataPart::Value,
      node->data,
      skin);
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ local function visitVectorLikeType(decl, comps)
$   local comps = List(comps)
$   local TState = "VectorLike_"..decl:formCSafeName().."_State"
/* ============================================================================
 */
struct $(TState)
{
$ for comp in comps:each() do
  TextField $(comp);
$ end
};

$ av:visit(decl, function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    if (!node->data->hasObjectData())
      node->data->setObject(nil);

    auto* state = allocNodeState<$(TState)>(self, node);

$ for comp in comps:each() do
    {
      SourceData* comp_data = node->data->findChildByName("$(comp)"_str);
      if (comp_data == nullptr)
        comp_data = node->data->addNumberValue(
          self.default_data, 
          "$(comp)"_str, 
          0.f);
    
      state->$(comp).init(comp_data, DataPart::Value);
    }
$ end
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    auto* state = node->state.as<$(TState)>();

    Rect comp_bounds = {};
    comp_bounds.x = bounds.x;
    comp_bounds.y = bounds.y;
    comp_bounds.w = math::floor(bounds.w / $(#comps).f);
    comp_bounds.h = bounds.h;
    
    // TODO(sushi) fix how these are placed. Need to properly compute the 
    //             space occupied by names then size fields appropriately
    //             to fill in the row width completely.

$   local function placeNameAndField(name)
    {
      f32 comp_offset = ui.putText(comp_bounds, "$(name)"_str, skin.text).x;
      Rect field_bounds = comp_bounds
        .contractedLeft(comp_offset)
        .contractedX(6.f);

      state->$(name).put(
        ui, 
        "veclike-comp-$(name)"_fid, 
        field_bounds,
        DataPart::Value,
        node->data->findChildByName("$(name)"_str),
        skin);

      comp_bounds.x += comp_bounds.w;
    }
$   end

$   for comp in comps:each() do
$     placeNameAndField(comp)
$   end
  }
  
$ end)

$ end

$$$ 
-- Note that colors are not handled here, since they can be specified as 
-- a hex number or object data.
visitVectorLikeType(lookup "Rect", { "x", "y", "w", "h" })

local vec_comps = List { "x", "y", "z", "w" }
for vec_type in minfo.vec_types:each() do
  visitVectorLikeType(lookup(vec_type.name), vec_comps:sub(1, vec_type.len))
end
$$$

$ -- * ------------------------------------------------------------------------

/* ============================================================================
 */
struct ColorState
{
  TextField r;
  TextField g;
  TextField b;
  TextField a;
};

$ av:visit(lookup "Color", function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    if (node->data->val.kind == SourceData::Value::Kind::NumberHex)
    {
      Color val = node->data->as_Color();

      node->data->setObject(nil);

      node->data->addUIntValue(self.default_data, "r"_str, val.r);
      node->data->addUIntValue(self.default_data, "g"_str, val.g);
      node->data->addUIntValue(self.default_data, "b"_str, val.b);
      node->data->addUIntValue(self.default_data, "a"_str, val.a);
    }
    else if (!node->data->hasChildren())
    {
      node->data->setObject(nil);
    }

    auto* state = allocNodeState<ColorState>(self, node);

$ local function initCompState(comp)
    {
      SourceData* comp_data = node->data->findChildByName("$(comp)"_str);
      if (comp_data == nullptr)
        comp_data = node->data->addUIntValue(
          self.default_data, 
          "$(comp)"_str, 
          $(comp == "a" and "255" or "0"));
    
      state->$(comp).init(comp_data, DataPart::Value);
    }
$ end
    
    @initCompState "r"
    @initCompState "g"
    @initCompState "b"
    @initCompState "a"
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    auto* state = node->state.as<ColorState>();

    f32 preview_width = skin.row.height;
    f32 comps_width = bounds.w - preview_width - 5.f;

    ui.putQuad(
      Rect::from(bounds.x, bounds.y, preview_width, preview_width),
      node->data->as_Color());

    Rect comp_bounds = {};
    comp_bounds.x = bounds.x + preview_width + 5.f;
    comp_bounds.y = bounds.y;
    comp_bounds.w = math::floor(comps_width / 4.f);
    comp_bounds.h = bounds.h;

$   local function placeNameAndField(name)
    {
      f32 comp_offset = ui.putText(comp_bounds, "$(name)"_str, skin.text).x;
      Rect field_bounds = comp_bounds
        .contractedLeft(comp_offset)
        .contractedX(6.f);

      state->$(name).put(
        ui, 
        "color-comp-$(name)"_fid, 
        field_bounds,
        DataPart::Value,
        node->data->findChildByName("$(name)"_str),
        skin);

      comp_bounds.x += comp_bounds.w;
    }
$   end

    @placeNameAndField "r"
    @placeNameAndField "g"
    @placeNameAndField "b"
    @placeNameAndField "a"
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(ast.Enum, function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.stub(decl)) // no children, edited inline.

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    String selected_text = node->data->val.str;

    if (ui.beginDropDown("enum-dropdown-$(decl.type.qname)"_fid,
          bounds,
          90.f,
          selected_text,
          skin.dropdown))
    {
      Rect button_bounds;
      button_bounds.x = 0.f;
      button_bounds.y = 0.f;
      button_bounds.w = ui.getWidth();
      button_bounds.h = 20.f;

$   for elem in decl.elems:each() do
      if (selected_text != "$(elem.name)"_str)
      {
        if (ui.putButton("enum-select-$(elem.name)"_fid,
              button_bounds,
              "$(elem.name)"_str,
              skin.dropdown_option))
        {
          node->data->val.str = "$(elem.name)"_str;
          ui.closePopup();
        }

        button_bounds.y += button_bounds.h;
      }
$   end

      ui.endDropDown();
    }
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "iro::Flags", function(decl)
$   local subdecl = decl.args[1].decl
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    if (!node->data->hasObjectData())
      node->data->setObject(nil);
  }

  /* --------------------------------------------------------------------------
   */
  $(declareBody(decl))
  {
    Rect button_bounds = Rect::from(pos.x,pos.y,14.f,14.f);

    SourceData* data = node->data;

$ for elem in subdecl.elems:each() do
$   if not elem.metadata.hidden then
    {
      b8 enabled = false;
      u32 idx = 0;
      
      // Kinda sucks but whatever.
      for (s32 child_idx = 0; child_idx < data->children.len; ++child_idx)
      {
        if (data->children[child_idx]->val.str == "$(elem.name)"_str)
        {
          enabled = true;
          idx = child_idx;
        }
      }

      if (ui.putCheckbox("flag-$(elem.name)"_fid,
            button_bounds,
            &enabled,
            skin.checkbox))
      {
        if (!enabled)
          data->removeChildByIdx(idx);
        else
          data->addStringValue(self.default_data, "$(elem.name)"_str);
      }

      Rect name_bounds = Rect::zero()
        .setSize(width, 14.f)
        .alignRightOutside(button_bounds, 4.f)
        .alignCenteredYInside(button_bounds);

      ui.putText(name_bounds, "$(elem.name)"_str, skin.text);

      button_bounds.y += button_bounds.h;
    }
$   end
$ end

    return button_bounds.y - pos.y + 2.f;
  }
$ end)

$ -- * ------------------------------------------------------------------------
  
$ av:visit(ast.Struct, function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
$ for field in decl:eachField() do
    {
      Node* child = addChildAndSearchName(
        self, 
        "$(field.name)"_str, 
        node,
        "$(field.type.qname)"_typeid);

      $(init_tree.call(field.type))(self, child);
    }
$ end
  }
$ end)

$ -- * ------------------------------------------------------------------------

static const f32 array_button_size = 14.f;

struct ArrayState
{
  Node* to_remove = nullptr;
};

$ av:visit(lookup "reflect::Array", function(decl)
$   local subtype = decl.args[1]

  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    for (s32 i = 0; i < node->data->children.len; ++i)
    {
      Node* child = addChildFromIdx(
        self,
        nil,
        node,
        "$(subtype.qname)"_typeid,
        i);

      $(init_tree.call(subtype))(self, child);
    }

    allocNodeState<ArrayState>(self, node);
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    auto* state = node->state.as<ArrayState>();

    if (state->to_remove != nullptr)
    {
      removeChild(self, node, state->to_remove);
      state->to_remove = nullptr;
    }

    auto add_bounds = Rect::from(bounds.pos(), vec2f(array_button_size));

    if (ui.putButton("array-add"_fid,
          add_bounds,
          skin.array_add))
    {
      SourceData* child_data = self.default_data.allocateSourceData();

      Node* child = addChild(
        self,
        nil,
        node,
        child_data,
        "$(subtype.qname)"_typeid);

      node->data->children.push(child_data);
    }
  }

  /* --------------------------------------------------------------------------
   */
  $(declarePutChildName(decl))
  {
    auto* state = node->state.as<ArrayState>();

    io::StaticBuffer<32> name;
    io::formatv(&name, '[', child_idx, ']');

    ui.putText(bounds, String(name), skin.text);

    Rect remove_bounds = Rect::from(bounds)
      .setSize(vec2f(array_button_size))
      .alignRightInside(bounds, 0.f)
      .alignCenteredYInside(bounds);

    if (ui.putButton("array-remove"_fid,
          remove_bounds,
          skin.array_remove))
    {      
      // Defer removal of the child. We can't just remove it here, because
      // this function is called while putNode() is interating our children.
      state->to_remove = child;
    }

    return bounds.w;
  }
$ end)

$ -- * ------------------------------------------------------------------------

struct StringMapState
{
  Node* to_remove;

  // TODO(sushi) need to manage these better. Would be nice if parent nodes
  //             could associate some state with their children, but that
  //             sounds too complicated to implement atm. The memory management
  //             of all of this is quite bad anyways.
  Array<TextField> key_fields;
};

$ av:visit(lookup "reflect::StringMap", function(decl)
$   local subtype = decl.args[1]
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    auto* state = allocNodeState<StringMapState>(self, node);

    state->key_fields.init(node->data->children.len, &self.bump);
  
    for (s32 i = 0; i < node->data->children.len; ++i)
    {
      Node* child = addChildFromIdx(
        self,
        nil,
        node,
        "$(subtype.qname)"_typeid,
        i);

      $(init_tree.call(subtype))(self, child);

      TextField* key_field = state->key_fields.push();
      key_field->init(child->data, DataPart::Name);
    }
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    auto* state = node->state.as<StringMapState>();

    if (state->to_remove != nullptr)
    {
      u32 idx = findChildIdx(node, state->to_remove);
      state->key_fields.remove(idx);

      removeChild(self, node, state->to_remove);
      state->to_remove = nullptr;
    }

    auto add_bounds = Rect::from(bounds.pos(), vec2f(array_button_size));

    if (ui.putButton("array-add"_fid,
          add_bounds,
          skin.array_add))
    {
      SourceData* child_data = self.default_data.allocateSourceData();

      Node* child = addChild(
        self,
        nil,
        node,
        child_data,
        "$(subtype.qname)"_typeid);

      $(init_tree.call(subtype))(self, child);

      node->data->setObject(nil);
      node->data->children.push(child_data);

      TextField* key_field = state->key_fields.push();
      key_field->init(child_data, DataPart::Name);
    }
  }

  /* --------------------------------------------------------------------------
   */
  $(declarePutChildName(decl))
  {
    auto* state = node->state.as<StringMapState>();

    TextField* key_field = &state->key_fields[child_idx];

    Rect remove_bounds = Rect::from(bounds)
      .setSize(vec2f(array_button_size))
      .alignRightInside(bounds, 0.f)
      .alignCenteredYInside(bounds);

    Rect key_bounds = bounds;
    // Using divider margin so the spacing appears consistent.
    key_bounds.w = remove_bounds.x - bounds.x - skin.divider_margin;

    key_field->put(
      ui,
      "name-field"_fid,
      key_bounds,
      DataPart::Name,
      child->data,
      skin);

    if (ui.putButton("array-remove"_fid,
          remove_bounds,
          skin.array_remove))
    {      
      // Defer removal of the child. We can't just remove it here, because
      // this function is called while putNode() is interating our children.
      state->to_remove = child;
    }

    return bounds.w;
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "reflect::TypedPtr", function(decl)
$   local subtype = decl.args[1]:desugar()
$   local subdecl = subtype.decl
$   for derived in subdecl:allDerived() do
$     av:handleDecl(derived)
$   end
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    switch (node->data->type.hash())
    {
$   for derived in subdecl:allDerived() do
    case "$(derived.type.qname)"_typeid_val:
      $(init_tree.call(derived))(self, node);
      break;
$   end
    }
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    if (ui.beginDropDown("typed-ptr-dropdown"_fid,
          bounds,
          100.f,
          node->data->type,
          skin.dropdown))
    {
      Rect button_bounds = {};
      button_bounds.x = 0.f;
      button_bounds.y = 0.f;
      button_bounds.w = ui.getWidth();
      button_bounds.h = 20.f;

$   for derived in subdecl:allDerived() do
      if (ui.putButton("typed-ptr-select-$(derived.qname)"_fid,
            button_bounds,
            "$(derived.qname)"_str,
            skin.dropdown_option))
      {
        node->data->type = "$(derived.qname)"_str;
        node->data->children.clear();

        clearChildren(self, node);

        $(init_tree.call(derived))(self, node);

        println("select $(derived.qname)");
        ui.closePopup();        
      }
      button_bounds.y += button_bounds.h;
$   end

      ui.endDropDown();
    }
  }
$ end)

$ -- * ------------------------------------------------------------------------
$ -- For now, link types behave just like strings, but eventually they should
$ -- show a dropdown of assets matching the linked type.

$ av:previsit(ast.Record, function(decl)
$   if not decl:findMetadata "ref" then
$     return
$   end
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    allocNodeState<TextField>(self, node)->init(
      node->data,
      DataPart::Value);
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    node->state.as<TextField>()->put(
      ui,
      "link-field"_fid,
      bounds,
      DataPart::Value,
      node->data,
      skin);
  }
$   return av.handled
$ end)

$ -- * ------------------------------------------------------------------------
$ -- Typedefs just passthrough to their subtype for now. Eventually though 
$ -- we should be checking for metadata applied to them that may alter 
$ -- their behavior in the editor.

$ av:visit(ast.TypedefDecl, function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    $(init_tree.call(decl.subtype))(self, node);
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:begin(function(decl)
$   return decl.metadata.def ~= nil
$ end)

/* ============================================================================
 */
struct PutParams
{
  f32 x = 0.f;
  f32 y = 0.f;

  // x offset applied to the inline contents of the node we are placing,
  // likely due to its parent injecting some UI.
  f32 inline_offset = 0.f;

  u32* node_idx = 0;

  void bumpidx()
  {
    *node_idx += 1;
  }

  Color getRowColor(const SourceDataEditorSkinDef& skin)
  {
    return *node_idx % 2? skin.row.odd_color : skin.row.even_color;
  }
};

/* ============================================================================
 */
struct PutResult
{
  f32 height = 0.f;
};

/* ----------------------------------------------------------------------------
 */
static inline String getNodeNamePrefix(Node& node)
{
  if (node.hasChildren())
    return node.isOpen()? "- "_str : "+ "_str;
  return "  "_str;
}

$ -- * ------------------------------------------------------------------------

$ local function putNodeCases(node)
$   local qname
$   if node:is(ast.Type) then
$     qname = node.qname
$   else
$     qname = node.type.qname
$   end
$   if node:is(ast.Decl) then
$     if node.typedefs then
$       for typedef in node.typedefs:each() do
  case "$(typedef.type.qname)"_typeid_val:
$       end
$     end
$   end
  case "$(qname)"_typeid_val:
$ end

/* ----------------------------------------------------------------------------
 */
static void putInlineContent(
    SourceDataEditor& self,
    ui::UI& ui,
    Rect bounds,
    Node& node,
    PutParams& params,
    const SourceDataEditorSkinDef& skin)
{
  switch (node.type.val)
  {
$ for node in inline_nodes:each() do
$   putNodeCases(node)
    $(put_inline.call(node))(
      self, 
      ui, 
      bounds, 
      &node,
      skin);
    break;
$ end
  }
}

/* ----------------------------------------------------------------------------
 */
static f32 putInlineContentPreChild(
    SourceDataEditor& self,
    ui::UI& ui,
    Rect bounds,
    Node& node,
    Node& child,
    PutParams& params,
    const SourceDataEditorSkinDef& skin)
{
  f32 width = 0.f;
  switch (node.type.val)
  {
$ for node in inline_pre_child_nodes:each() do
$   putNodeCases(node)
    width = $(put_inline_pre_child.call(node))(
      self,
      ui,
      bounds,
      &node,
      &child,
      skin);
$ end
  }
  return width;
}

/* ----------------------------------------------------------------------------
 */
static f32 putChildName(
    SourceDataEditor& self,
    ui::UI& ui,
    Node& node,
    Node& child,
    u32 child_idx,
    PutParams& params,
    const SourceDataEditorSkinDef& skin)
{
  auto name_bounds = Rect::from(
    params.x, 
    params.y, 
    self.state->divider_x - params.x - skin.divider_margin,
    skin.row.height)
    .contractedY(2.f);

  f32 prefix_width = 0.f;
  if (node.hasChildren())
  {
    String prefix = getNodeNamePrefix(child);

    prefix_width = ui.putText(
      name_bounds,
      prefix,
      skin.text).x;

    ui::Focus open_hit = ui.putFocusableBounds(
      "open-hit"_fid,
      name_bounds);

    if (open_hit.wasPrimaryReleased())
      child.flags.toggle(NodeFlag::Open);
  }

  f32 name_width = 0.f;
  switch (node.type.val)
  {
$ for node in child_name_placers:each() do
$   putNodeCases(node)
    name_width = $(put_child_name.call(node))(
      self,
      ui,
      name_bounds.contractedLeft(prefix_width),
      &node,
      &child,
      child_idx,
      skin);
    break;
$ end
  default:
    name_width = ui.putText(
      name_bounds.contractedLeft(prefix_width),
      child.name,
      skin.text).x;
    break;
  }

  f32 total_width = name_width + prefix_width;

  self.state->max_name_extent = max(
    self.state->max_name_extent, 
    total_width);

  return total_width;
}

/* ----------------------------------------------------------------------------
 */
static f32 putBody( 
    SourceDataEditor& self,
    ui::UI& ui,
    Node& node,
    vec2f pos,
    f32 width,
    const SourceDataEditorSkinDef& skin)
{
  switch (node.type.val)
  {
$ for node in body_nodes:each() do
$   putNodeCases(node)
    return $(put_body.call(node))(
      self,
      ui,
      pos,
      width,
      &node,
      skin);
$ end
  }

  return 0.f;
}

/* ----------------------------------------------------------------------------
 */
static inline Rect computeInlineBounds(
    SourceDataEditor& self,
    ui::UI& ui,
    PutParams& params,
    f32 y,
    b8 use_inline_offset,
    const SourceDataEditorSkinDef& skin)
{
  Rect inline_bounds = {};
  
  inline_bounds.x = self.state->divider_x 
                  + skin.divider_width 
                  + skin.divider_margin;

  if (use_inline_offset)
    inline_bounds.x += params.inline_offset;

  inline_bounds.y = y;

  inline_bounds.w = ui.getWidth() - inline_bounds.x - skin.row.right_padding;
  inline_bounds.h = skin.row.height;

  inline_bounds.contractY(2.f);

  return inline_bounds;
}


/* ----------------------------------------------------------------------------
 */
static PutResult putNode(
    SourceDataEditor& self,
    ui::UI& ui,
    Node& node,
    PutParams& params,
    const SourceDataEditorSkinDef& skin)
{
  Rect inline_bounds = computeInlineBounds(
    self,
    ui,
    params,
    params.y,
    true,
    skin);

  putInlineContent(self, ui, inline_bounds, node, params, skin);

  f32 y = params.y + skin.row.height;

  // TODO(sushi) AGAIN we have ordering issues here. Need to figure out some 
  //             way to emit commands into some list that can be injected 
  //             later. Current setup doesn't work well for that.
  y += putBody(
    self,
    ui,
    node,
    vec2f(inline_bounds.x, y),
    inline_bounds.w,
    skin);

  if (node.hasChildren() && node.isOpen())
  {
    PutParams child_params = params;
    child_params.x = params.x + skin.children_indent;

    u32 child_idx = 0;
    for (Node& child : eachChild(&node))
    {
      defer { child_idx += 1; };

      ui.pushId(ui.generateIdFromPointer(&child));
      defer { ui.popId(); };

      child_params.y = y;

      Color row_color = params.getRowColor(skin);

      ui.putQuad(
          Rect::from(0.f, y, ui.getWidth(), skin.row.height), 
          row_color);

      params.bumpidx();

      putChildName(
        self,
        ui,
        node,
        child,
        child_idx,
        child_params,
        skin);
      
      // TODO(sushi) should probably reuse this.
      Rect child_inline_bounds = computeInlineBounds(
        self,
        ui,
        params,
        child_params.y,
        false,
        skin);

      child_params.inline_offset = putInlineContentPreChild(
        self,
        ui,
        child_inline_bounds,
        node,
        child,
        params,
        skin);

      PutResult result = putNode(self, ui, child, child_params, skin);
      y += max(result.height, skin.row.height);
    }
  }

  PutResult result = {};
  result.height = y - params.y;

  return result;
}

/* ----------------------------------------------------------------------------
 */
void SourceDataEditor::put(
    UI& ui,
    Rect bounds,
    const SourceDataEditorSkinDef& skin)
{
  ZoneScopedN("SourceDataEditor::update");

  ui.beginScrollGroup("sde-scroll"_fid, bounds, skin.scroll_bar);

  if (state != nullptr)
  {
    state->divider_x = max(skin.row.min_name_width, state->divider_x);

    auto* root = &state->root_node;

    u32 node_idx = 0;

    PutParams params = {};
    params.x = skin.padding.x;
    params.y = skin.padding.y;
    params.node_idx = &node_idx;
    
    u32 child_idx = 0;
    for (Node& child : eachChild(root))
    {
      defer { child_idx += 1; };

      ui.pushId(ui.generateIdFromPointer(&child));
      defer { ui.popId(); };

      Color row_color = params.getRowColor(skin);

      ui.putQuad(
          Rect::from(0.f, params.y, ui.getWidth(), skin.row.height), 
          row_color);

      params.bumpidx();

      putChildName(
        *this,
        ui,
        *root,
        child,
        child_idx,
        params,
        skin);

      PutResult result = putNode(*this, ui, child, params, skin);

      params.y += max(result.height, skin.row.height);
    }

    f32 group_height = ui.getHeight();
    while (params.y < group_height)
    {
      Color fill_color = params.getRowColor(skin);

      f32 fill_height = min(group_height - params.y, skin.row.height);

      ui.putQuad(
        Rect::from(
          0.f, 
          params.y, 
          ui.getWidth(), 
          fill_height),
        fill_color);

      params.y += fill_height;

      params.bumpidx();
    }

    if (state->first_frame)
    {
      state->divider_x = state->max_name_extent + skin.divider_margin;
      state->first_frame = false;
    }
  
    auto divider_bounds = Rect::from(
      state->divider_x, 
      0.f,
      skin.divider_width,
      params.y);

    ui::Focus divider_focus = ui.putFocusableBounds(
      "sde-divider"_fid,
      divider_bounds);

    Color divider_color = 0x444444ff;
    if (state->dragging_divider || divider_focus.isHovered())
      divider_color = 0xddddddff;

    ui.putQuad(divider_bounds, divider_color);

    if (state->dragging_divider)
    {
      state->divider_x = ui.getGroupLocalCursorPos().x;

      if (ui.wasPrimaryReleasedGlobally())
        state->dragging_divider = false;
    }
    else if (divider_focus.wasPrimaryPressed())
      state->dragging_divider = true;
  }

  ui.endScrollGroup(skin.scroll_bar);
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataEditor::init()
{
  if (!bump.init())
    return false;

  if (!default_data.init())
    return false;

  return true;
}

/* ----------------------------------------------------------------------------
 */
void SourceDataEditor::setSourceData(
    SourceData* sdata, 
    SourceDataFile* sfile, 
    rtr::TypeId type_id)
{
  this->sdata = sdata;
  this->sfile = sfile;
  this->type_id = type_id;

  bump.clear();

  state = bump.construct<SDETreeState>();

  state->first_frame = true;
  state->dragging_divider = false;

  Node* root = &state->root_node;
  root->type = type_id;
  root->data = sdata;

  switch (type_id.val)
  {
$ av:eachVisited(function(decl)
  case "$(decl.type.qname)"_typeid_val:
    $(init_tree.call(decl))(*this, root);
    break;
$ end)
  }
}
