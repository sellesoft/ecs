$ local cmn = require "common"
$ local glob = require "iro.fs.glob"
$ local List = require "iro.List"
$ local ast = require "reflect.ast"

$$$
local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/**/*.defs.lh",
  "src/**/*.comp.lh",
}
$$$
$(imported)

@lpp.import "sdata/SourceDataEditor.lh"

@lpp.import "Engine.lh"

@lpp.import "sdata/SourceData.lh"
@lpp.import "sdata/SourceDataParser.lh"

@lpp.import "ui/UI.lh"
@lpp.import "graphics/Geo.lh"

using namespace ui;

@log.import

@lpp.import "Profiling.lh"
  
$ local putDeclPlacer
$ local putTypePlacer

$ print(ast.Struct:is(ast.Decl))

$ local seen = {}

/* ============================================================================
 */
struct SDENode
{
  String name;
};

/* ============================================================================
 */
struct DatumInitParams
{
  String name;
  SourceDataFile& default_data;
  SourceDataEditor& editor;
};

/* ============================================================================
 */
struct DatumUpdateResult
{
  f32 height = 0.f;

  Rect name_bounds;

  // Incremental collection of child name extents.
  Rect name_extents;
};

/* ============================================================================
 */
struct DatumUpdateParams
{
  f32 x;
  f32 y;
  String name;
  u32 idx;
  f32 name_column_width;
  const SourceDataEditorSkinDef& skin;
  SourceDataEditor& editor;
  b8 embedded;
};

/* ----------------------------------------------------------------------------
 */
static inline f32 calcRowCenteredY(f32 height, const DatumUpdateParams& params)
{
  return params.y + math::floor(0.5f * (params.skin.row.height - height));
}

/* ----------------------------------------------------------------------------
 */
static inline f32 calcRowTextY(const DatumUpdateParams& params)
{
  return calcRowCenteredY(params.skin.text.font_height, params);
}

/* ----------------------------------------------------------------------------
 */
static inline f32 calcWidthToFill(
    ui::UI& ui, 
    f32 start_x, 
    const DatumUpdateParams& params)
{
  return (ui.getWidth() - params.skin.row.right_padding) - start_x;
}

/* ============================================================================
 */
struct Datum
{
  Datum* parent;
  SourceData* data;

  b8 init(Datum* parent, SourceData* data)
  {
    assert(data != nullptr && 
      "all Datum types must provide some SourceData to Datum::init");

    this->parent = parent;
    this->data = data;
    return true;
  }

  f32 putName(
      ui::UI& ui, 
      DatumUpdateResult* result,
      const DatumUpdateParams& params)
  {
    auto text_pos = vec2f(
      params.x + params.skin.row.name_padding,
      calcRowTextY(params));

    auto text_size = ui.putText(
      Rect::from(text_pos, {100.f, 100.f}),
      params.name,
      params.skin.text);

    setNameBounds(result, Rect::from(text_pos, text_size));

    return params.name_column_width + params.skin.row.name_value_spacing;
  }

  void setNameBounds(DatumUpdateResult* result, Rect bounds)
  {
    result->name_bounds = bounds;
    result->name_extents.expandToContain(bounds);
  }

  void computeHeight(
      f32 height, 
      DatumUpdateResult* result,
      const DatumUpdateParams& params)
  {
    if (params.embedded)
      result->height = height;
    else
      result->height = max<f32>(height, params.skin.row.height);
  }

  void mergeChildNameExtents(
      DatumUpdateResult* result, 
      const DatumUpdateResult& child_result)
  {
    result->name_extents.expandToContain(child_result.name_extents);
  }

  void putBackground(
      ui::UI& ui, 
      f32 height,
      const DatumUpdateParams& params)
  {
    ui.pushCmdList();

    Color row_color = params.idx % 2 
      ? params.skin.row.odd_color
      : params.skin.row.even_color;

    auto bg_bounds = Rect::from(
      params.x,
      params.y,
      ui.getWidth() - params.x,
      max(height, params.skin.row.height));

    ui.putQuad(bg_bounds, row_color);

    ui.popCmdListToFront();
  }
};

/* ============================================================================
 */
enum class DatumPart
{
  Name,
  Type,
  Value,
};

static String getDatumPartString(SourceData* data, DatumPart part)
{
  switch (part)
  {
  case DatumPart::Name: return data->name;
  case DatumPart::Type: return data->type;
  case DatumPart::Value: return data->val.str;
  }

  assert(false);
  return nil;
}

/* ============================================================================
 */
struct DatumTextField
{
  io::StaticBuffer<255> buffer;

  ui::TextFieldState state;

  b8 init(SourceData* data, DatumPart part)
  {
    state.edit.setBuffer({buffer.arr, &buffer.len, s32(buffer.capacity())});

    String val = getDatumPartString(data, part);

    if (isnil(val))
      return true;

    if (val.len > buffer.capacity())
      @log.warn(editor, "source data val too long for DatumTextField\n");

    buffer.len = min<u64>(val.len, buffer.capacity());
    mem::copy(buffer.arr, val.ptr, buffer.len);
    return true;
  }

  ui::TextFieldResult put(
      ui::UI& ui, 
      Rect bounds,
      SourceData* data, 
      DatumPart part,
      const TextFieldSkin& skin)
  {
    return ui.putTextField(
      ui.generateIdFromPointer(this),
      bounds,
      &state,
      skin);
  }
};

/* ============================================================================
 */
struct ObjectDatum
{
  b8 is_open;

  f32 putName(
      ui::UI& ui, 
      Datum* datum,
      DatumUpdateResult* result,
      const DatumUpdateParams& params)
  {
    if (notnil(params.name))
    {
      auto text_pos = vec2f(
        params.x + params.skin.row.name_padding,
        calcRowTextY(params));

      io::StaticBuffer<128> name_buffer;
      io::formatv(&name_buffer, (is_open? "- " : "+ "), params.name);

      auto text_size = ui.putText(
        Rect::from(text_pos, {100.f, 100.f}),
        String(name_buffer),
        params.skin.text);

      auto name_bounds = Rect::from(text_pos, text_size);

      datum->setNameBounds(result, name_bounds);

      ui::Focus focus = ui.putFocusableBounds(
        "obj-name-hit"_fid, 
        name_bounds);

      if (focus.wasPrimaryReleased())
        is_open = !is_open;
    }

    return params.name_column_width + params.skin.row.name_value_spacing;
  }
};

/* ============================================================================
 */
struct Datum_vec2
{
  Datum datum;
  
  b8 init(Datum* parent, SourceData* data, const DatumInitParams& params)
  {
    if (data == nullptr)
    {
      data = params.default_data.allocateSourceData();
      data->setVec2f(params.default_data, {0.f, 0.f});
    }

    return datum.init(parent, data);
  }

  DatumUpdateResult update(ui::UI& ui, const DatumUpdateParams& params)
  {
    DatumUpdateResult result = {};
    datum.putName(ui, &result, params);
    datum.computeHeight(0.f, &result, params);
    datum.putBackground(ui, result.height, params);
    return result;
  }
};

$ -- * ------------------------------------------------------------------------

$ local function putBuiltinPlacer(name)

/* ============================================================================
 */
struct Datum_$(name)
{
  Datum datum;

  b8 init(Datum* parent, SourceData* data, const DatumInitParams& params)
  {
    if (data == nullptr)
    {
      data = params.default_data.allocateSourceData();
      data->setNumberValue(params.default_data, 0.f);
    }

    return datum.init(parent, data);
  }

  DatumUpdateResult update(ui::UI& ui, const DatumUpdateParams& params)
  {
    DatumUpdateResult result = {};
    datum.putName(ui, &result, params);
    datum.computeHeight(0.f, &result, params);
    datum.putBackground(ui, result.height, params);
    return result;
  }
};

$ end

$ putBuiltinPlacer "u8"
$ putBuiltinPlacer "u16"
$ putBuiltinPlacer "u32"
$ putBuiltinPlacer "u64"
$ putBuiltinPlacer "s8"
$ putBuiltinPlacer "s16"
$ putBuiltinPlacer "s32"
$ putBuiltinPlacer "s64"
$ putBuiltinPlacer "f32"
$ putBuiltinPlacer "f64"

/* ============================================================================
 */
struct Datum_b8
{
  Datum datum;

  b8 init(Datum* parent, SourceData* data, const DatumInitParams& params)
  {
    if (data == nullptr)
    {
      data = params.default_data.allocateSourceData();
      data->setBooleanValue(false);
    }
    return datum.init(parent, data);
  }

  DatumUpdateResult update(ui::UI& ui, const DatumUpdateParams& params)
  {
    DatumUpdateResult result = {};
    datum.putName(ui, &result, params);
    datum.computeHeight(0.f, &result, params);
    datum.putBackground(ui, result.height, params);
    return result;
  }
};

$ -- * ------------------------------------------------------------------------

$ local function getDeclDatumName(decl)
$   return "Datum_"..decl:formCSafeName()
$ end

$ -- * ------------------------------------------------------------------------

$ local function getTypeDatumName(type)
$   type = type:desugar()
$   if type:is(ast.Builtin) then
$     return "Datum_"..type:formCSafeName()
$   elseif type:is(ast.TagType) then
$     local decl = type.decl
$     if decl:is(ast.TemplateSpec) then
$       if decl.specialized.name == "vec2" then
$         return "Datum_vec2"
$       end
$     end
$     return getDeclDatumName(decl)
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ local function declareDeclDatum(decl)
$   decl.user = decl.user or {}
$   decl.user.datum_placed = true 
$   return "struct "..getDeclDatumName(decl)
$ end

$ -- * ------------------------------------------------------------------------

$ local function declareDeclDatumByName(name)
$   local decl = astctx:lookupTypeDecl(name)
$   assert(decl, "declareDeclDatumByName got null decl: "..name)
$   return declareDeclDatum(decl)
$ end

/* ============================================================================
 */
$(declareDeclDatumByName "iro::utf8::String")
{
  Datum datum;

  DatumTextField text;

  b8 init(Datum* parent, SourceData* data, const DatumInitParams& params)
  {
    if (data == nullptr)
    {
      data = params.default_data.allocateSourceData();
      data->setStringValue(""_str);
    }

    if (!datum.init(parent, data))
      return false;

    if (!text.init(data, DatumPart::Value))
      return false;

    return true;
  }

  b8 hasRowContent() const
  {
    return true;
  }

  DatumUpdateResult update(ui::UI& ui, const DatumUpdateParams& params)
  {
    DatumUpdateResult result = {};

    f32 val_x = datum.putName(ui, &result, params);

    Rect field_bounds = {};
    field_bounds.x = val_x;
    field_bounds.h = result.name_bounds.h + 4.f;
    field_bounds.w = calcWidthToFill(ui, val_x, params);
    field_bounds.y = calcRowCenteredY(field_bounds.h, params);
    
    text.put(
      ui,
      field_bounds,
      datum.data,
      DatumPart::Value,
      params.skin.text_field);

    datum.computeHeight(0.f, &result, params);
    datum.putBackground(ui, result.height, params);
    return result;
  }
};

$ -- * ------------------------------------------------------------------------

$ local function putStructPlacer(decl)
$   for field in decl:eachField() do
$     putTypePlacer(field.type)
$   end
$   local name = getDeclDatumName(decl)

/* ============================================================================
 */
$(declareDeclDatum(decl))
{
  Datum datum;
  ObjectDatum object;

$ for field in decl:eachField() do
  $(getTypeDatumName(field.type) or "int") datum_$(field.name);
$ end

  b8 init(Datum* parent, SourceData* data, const DatumInitParams& params)
  {
    if (data == nullptr)
    {
      data = params.default_data.allocateSourceData();
      data->setObject(nil);
    }

    if (!datum.init(parent, data))
      return false;

$ for field in decl:eachField() do
    {
      SourceData* child = nullptr;
      if (data != nullptr)
        child = data->findChildByName("$(field.name)"_str);
      if (!datum_$(field.name).init(&datum, child, params))
        return false;
    }
$ end

    return true;
  }

  void placeFields(
      ui::UI& ui,
      f32 child_offset,
      f32 y,
      u64 datum_idx,
      const DatumUpdateParams& params,
      DatumUpdateResult* result)
  {
$ for field in decl:eachField() do
    {
      DatumUpdateParams sub_params = params;
      sub_params.x += child_offset;
      sub_params.y = y;
      sub_params.name = "$(field.name)"_str;
      sub_params.idx = datum_idx;
      sub_params.embedded = false;

      DatumUpdateResult sub_result = 
        datum_$(field.name).update(ui, sub_params);

      datum.mergeChildNameExtents(result, sub_result);

      y += sub_result.height;
      datum_idx += 1;
    }
$ end
  }



  DatumUpdateResult update(ui::UI& ui, const DatumUpdateParams& params)
  {
    DatumUpdateResult result = {};

    if (datum.parent != nullptr && !params.embedded)
      object.putName(ui, &datum, &result, params);

    f32 child_offset = 0.f;
    if (datum.parent != nullptr && !params.embedded)
      child_offset = params.skin.children_indent;

    f32 y = params.y;
    u64 datum_idx = params.idx + 1;
    if (datum.parent != nullptr && !params.embedded)
      y += params.skin.row.height;

    if (object.is_open || datum.parent == nullptr)
      placeFields(
        ui, 
        child_offset,
        y,
        datum_idx,
        params, 
        &result);

    datum.computeHeight(y - params.y, &result, params);
    datum.putBackground(ui, result.height, params);
    return result;
  }
};

$ end

$ -- * ------------------------------------------------------------------------

$ local function putEnumPlacer(decl)

/* ============================================================================
 */
$(declareDeclDatum(decl))
{
  Datum datum;

  b8 init(Datum* parent, SourceData* data, const DatumInitParams& params)
  {
    if (data == nullptr)
    {
      data = params.default_data.allocateSourceData();
      data->setStringValue(""_str);
    }

    return datum.init(parent, data);
  }

  DatumUpdateResult update(ui::UI& ui, const DatumUpdateParams& params)
  {
    DatumUpdateResult result = {};
    datum.putName(ui, &result, params);
    datum.computeHeight(0.f, &result, params);
    datum.putBackground(ui, result.height, params);
    return result;
  }
};

$ end

$ -- * ------------------------------------------------------------------------

$ local function putLinkPlacer(decl)

/* ============================================================================
 */
$(declareDeclDatum(decl))
{
  Datum datum;

  DatumTextField text;

  b8 init(Datum* parent, SourceData* data, const DatumInitParams& params)
  {
    if (data == nullptr)
    {
      data = params.default_data.allocateSourceData();
      data->setObject(nil);
    }
    if (!datum.init(parent, data))
      return false;

    if (!text.init(data, DatumPart::Value))
      return false;

    return true;
  }

  DatumUpdateResult update(ui::UI& ui, const DatumUpdateParams& params)
  {
    DatumUpdateResult result = {};

    f32 val_x = datum.putName(ui, &result, params);

    Rect field_bounds = {};
    field_bounds.x = val_x;
    field_bounds.w = calcWidthToFill(ui, val_x, params);
    field_bounds.h = result.name_bounds.h + 4.f;
    field_bounds.y = calcRowCenteredY(field_bounds.h, params);

    text.put(
      ui, 
      field_bounds,
      datum.data,
      DatumPart::Value,
      params.skin.text_field);

    datum.computeHeight(0.f, &result, params);
    datum.putBackground(ui, result.height, params);
    return result;
  }
};

$ end

$ -- * ------------------------------------------------------------------------

$ local function putArrayPlacer(decl)
$   local subtype = decl.args[1]
$   putTypePlacer(subtype)

/* ============================================================================
 */
$(declareDeclDatum(decl))
{
  Datum datum;
  ObjectDatum object;

  Array<$(getTypeDatumName(subtype))> children;

  b8 init(Datum* parent, SourceData* data, const DatumInitParams& params)
  {
    if (data == nullptr)
    {
      data = params.default_data.allocateSourceData();
      data->setObject(nil);
    }

    if (!datum.init(parent, data))
      return false;

    if (!children.init(data->children.len))
      return false;

    io::StaticBuffer<16> name;
    for (s32 i = 0; i < data->children.len; ++i)
    {
      name.clear();
      io::format(&name, i);
      auto* child = children.push();

      if (!child->init(&datum, data->children[i], params))
        return false;
    }

    return true;
  }

  DatumUpdateResult update(ui::UI& ui, const DatumUpdateParams& params)
  {
    DatumUpdateResult result = {};
    object.putName(ui, &datum, &result, params);

    f32 y = params.y + params.skin.row.height;
    u32 datum_idx = params.idx + 1;

    if (object.is_open)
    {
      for (s32 i = 0; i < children.len; ++i)
      {
        auto& child = children[i];

        io::StaticBuffer<16> name;
        io::format(&name, i);

        DatumUpdateParams child_params = params;
        child_params.name = String(name);
        child_params.y = y;
        child_params.x = params.x + params.skin.children_indent;
        child_params.idx = datum_idx;
    
        DatumUpdateResult child_result = child.update(ui, child_params);

        datum.mergeChildNameExtents(&result, child_result);
    
        assert(child_result.height > 0.f);

        y += child_result.height;
        datum_idx += 1;
      }
    }

    datum.computeHeight(y - params.y, &result, params);
    datum.putBackground(ui, result.height, params);
    return result;
  }
};

$ end

$ -- * ------------------------------------------------------------------------

$ local function putTypedPtrPlacer(decl)
$   local subtype = decl.args[1]:desugar()
$   local subdecl = subtype.decl
$   assert(subdecl, "TypedPtr contains a type that has no decl")
$ 
$   for derived in subdecl:allDerived() do
$     putDeclPlacer(derived)
$   end

/* ============================================================================
 */
$(declareDeclDatum(decl))
{
  Datum datum;
  ObjectDatum object;

  rtr::TypeId subdatum_type;
  Datum* subdatum;

  b8 init(Datum* parent, SourceData* data, const DatumInitParams& params)
  {
    if (data == nullptr)
    {
      data = params.default_data.allocateSourceData();
      data->setObject(nil);
    }

    if (!datum.init(parent, data))
      return false;

    allocateSubDatum(data, params.editor);
    return true;
  }

  void allocateSubDatum(SourceData* data, SourceDataEditor& editor)
  {
    if (data == nullptr || isnil(data->type))
    {
      // TODO(sushi) delete subdatum here and on change.
    }

    auto datatype = rtr::TypeId::fromString(data->type);
    subdatum_type = datatype;

    switch (datatype.val)
    {
$ for derived in subdecl:allDerived() do
    case "$(derived.qname)"_typeid_val:
      subdatum = editor.allocateAndInitDatum(datatype, data);
      (($(getDeclDatumName(derived))*)subdatum)->datum.parent = &datum;
      break;
$ end
    }
  }

  DatumUpdateResult update(ui::UI& ui, const DatumUpdateParams& params)
  {
    ui.pushId(ui.generateIdFromPointer(&datum));
    defer { ui.popId(); };

    DatumUpdateResult result = {};

    f32 val_x = object.putName(ui, &datum, &result, params);

    Rect dropdown_bounds = {};
    dropdown_bounds.x = val_x;
    dropdown_bounds.h = params.skin.row.height - 6.f;
    dropdown_bounds.y = calcRowCenteredY(dropdown_bounds.h, params);
    dropdown_bounds.w = calcWidthToFill(ui, dropdown_bounds.x, params);

    if (ui.beginDropDown(
          "type-id-select"_fid,
          dropdown_bounds,
          999.f,
          rtr::typenameFromTypeId(subdatum_type),
          params.skin.dropdown))
    {
      Rect option_bounds = {};
      option_bounds.x = 0.f;
      option_bounds.y = 0.f;
      option_bounds.w = ui.getWidth();
      option_bounds.h = 20.f;

$ for derived in subdecl:allDerived() do
      {
        const rtr::TypeId type = "$(derived.qname)"_typeid;

        if (ui.putButton(
              "$(derived.qname) selection"_fid,
              option_bounds,
              "$(derived.qname)"_str,
              params.skin.dropdown_option))
        {
          println("select $(derived.qname)");
          ui.closePopup();
        }

        option_bounds.y += option_bounds.h;
      }
$ end

      ui.endDropDown();
    }

    f32 child_h = 0.f;
    f32 child_y = params.y + params.skin.row.height;
    if (subdatum != nullptr && object.is_open)
    {
      DatumUpdateResult child_result;

      DatumUpdateParams child_params = params;
      child_params.x += params.skin.children_indent;
      child_params.y = child_y;
      child_params.name = nil;
      child_params.embedded = true;
      child_params.idx = params.idx + 1;

      switch (subdatum_type.val)
      {
$ for derived in subdecl:allDerived() do
      case "$(derived.qname)"_typeid_val:
        child_result = 
          (($(getDeclDatumName(derived))*)subdatum)->update(ui, child_params);
        break;
$ end
      }
        
      child_h = child_result.height;
      datum.mergeChildNameExtents(&result, child_result);
    }

    datum.computeHeight(child_h + params.skin.row.height, &result, params);
    datum.putBackground(ui, result.height, params);
    return result;
  }
};

$ end

$ -- * ------------------------------------------------------------------------

$ local function putTemplateSpecPlacer(decl)
$   if decl.specialized.qname == "reflect::Array" then
$     return (putArrayPlacer(decl))
$   elseif decl.specialized.qname == "reflect::TypedPtr" then
$     return (putTypedPtrPlacer(decl))
$   end

/* ============================================================================
 */
$(declareDeclDatum(decl))
{
  Datum datum;

  b8 init(Datum* parent, SourceData* data, const DatumInitParams& params)
  {
    if (data == nullptr)
    {
      data = params.default_data.allocateSourceData();
      data->setObject(nil);
    }

    return datum.init(parent, data);
  }

  DatumUpdateResult update(ui::UI& ui, const DatumUpdateParams& params)
  {
    DatumUpdateResult result = {};
    f32 val_x = datum.putName(ui, &result, params);
  
    ui::TextSkin text_skin = params.skin.text;
    text_skin.color = 0xff0000ff;

    Rect text_bounds = {};
    text_bounds.x = val_x;
    text_bounds.y = calcRowTextY(params);
    text_bounds.w = calcWidthToFill(ui, val_x, params);
    text_bounds.h = params.skin.row.height; // wrong

    ui.putText(text_bounds, "unhandled template spec"_str, text_skin);

    datum.computeHeight(0.f, &result, params);
    datum.putBackground(ui, result.height, params);
    return result;
  }
};

$ end

$ local function putRecordPlacer(decl)
$   if decl:findMetadata "ref" then
$     putLinkPlacer(decl)
$   elseif decl:is(ast.TemplateSpec) then
$     putTemplateSpecPlacer(decl)
$   elseif decl:is(ast.Struct) then
$     putStructPlacer(decl)
$   else
$       print(decl)
$   end
$ end

$ putDeclPlacer = function(decl)
$   decl.user = decl.user or {}
$   if decl.user.datum_placed then return end
$ 
$   decl.user.datum_placed = true
$ 
$   if decl:is(ast.TagDecl) then
$     if decl:is(ast.Record) then
$       putRecordPlacer(decl)
$     elseif decl:is(ast.Enum) then
$       putEnumPlacer(decl)
$     else
$     end
$   elseif decl:is(ast.TypedefDecl) then
$     local subtype = decl.subtype:desugar()
$     putDeclPlacer(subtype.decl)
typedef $(getDeclDatumName(subtype.decl)) $(getDeclDatumName(decl));
$   end
$ end

$ putTypePlacer = function(type)
$   type = type:desugar()
$   if type:is(ast.TagType) then
$     putDeclPlacer(type.decl)
$   end
$ end

$ for decl in astctx.type_decls:each() do
$   if decl.metadata.def then
$     putDeclPlacer(decl)
$   end
$ end

/* ----------------------------------------------------------------------------
 */
b8 SourceDataEditor::init()
{
  if (!datum_allocator.init())
    return false;

  if (!default_data.init())
    return false;

  return true;
}

/* ----------------------------------------------------------------------------
 */
Datum* SourceDataEditor::allocateAndInitDatum(
    rtr::TypeId type, 
    SourceData* data)
{
  switch (type_id.val)
  {
$ for decl in astctx.type_decls:each() do
$   if decl.user and decl.user.datum_placed then
  case "$(decl.type.name)"_typeid_val:
    {
      DatumInitParams init_params = 
      {
        .default_data = default_data,
        .editor = *this,
      };

      auto* new_datum = 
        mem::stl_allocator.construct<$(getDeclDatumName(decl))>();
      new_datum->init(nullptr, data, init_params);
      return (Datum*)new_datum;
    }
    break;
$   end
$ end
  }

  return nullptr;
}

/* ----------------------------------------------------------------------------
 */
void SourceDataEditor::setSourceData(
    SourceData* sdata, 
    SourceDataFile* sfile, 
    rtr::TypeId type_id)
{
  this->sdata = sdata;
  this->sfile = sfile;
  this->type_id = type_id;

  current_datum = allocateAndInitDatum(type_id, sdata);
}

/* ----------------------------------------------------------------------------
 */
void SourceDataEditor::update(
    UI& ui,
    Rect bounds,
    const SourceDataEditorSkinDef& skin)
{
  ZoneScopedN("SourceDataEditor::update");

  ui.beginScrollGroup("sde-scroll"_fid, bounds, skin.scroll_bar);

  switch (type_id.val)
  {
$ for decl in astctx.type_decls:each() do
$   if decl.user and decl.user.datum_placed then
  case "$(decl.type.name)"_typeid_val:
    {
      DatumUpdateParams params = 
      {
        .x = 0.f,
        .y = 0.f,
        .name = nil,
        .skin = skin,
        .name_column_width = name_column_width,
        .editor = *this,
      };
      auto* casted = (($(getDeclDatumName(decl))*)current_datum);

      DatumUpdateResult result = 
        casted->update(ui, params);

      name_column_width = result.name_extents.extent().x;
    }
    break;
$   end
$ end
  }

  ui.endScrollGroup(skin.scroll_bar);
}
