$ local cmn = require "common"
$ local glob = require "iro.fs.glob"
$ local List = require "iro.List"
$ local ast = require "reflect.ast"

$$$
local astctx, imported = require "reflect.AstContext" .fromGlobs
{
  "src/**/*.defs.lh",
  "src/**/*.comp.lh",
}

local av = require "reflect.AstVisitor" .new(astctx)

local function lookup(name)
  return astctx:lookupDecl(name)
end

$$$
$(imported)

@lpp.import "sdata/SourceDataEditor.lh"

@lpp.import "Engine.lh"

@lpp.import "sdata/SourceData.lh"
@lpp.import "sdata/SourceDataParser.lh"

@lpp.import "ui/UI.lh"
@lpp.import "graphics/Geo.lh"

using namespace ui;

@log.import

@lpp.import "Profiling.lh"

#include "iro/io/StaticBuffer.h"

/* ============================================================================
 */
enum class NodeFlag
{
  // The type of this node displays content 'inline', i.e. in the same row
  // as its name.
  InlineContent,

  // The type of this node displays content in its 'body', i.e. below the 
  // row containing its name. 
  BodyContent,
  
  // No SourceData for this node exists in the input yet.
  MissingData,
  
  // For nodes with children, if they are open or not.
  Open,

  COUNT
};

typedef Flags<NodeFlag> NodeFlags;

/* ============================================================================
 *  Arbitrary state that a Node can allocate.
 */
struct NodeState
{
  void* ptr = nullptr;

  template<typename T>
  T* as()
  {
    assert(ptr != nullptr);
    return (T*)ptr;
  }
};

/* ============================================================================
 */
struct Node
{
  String name = nil;

  Node* next = nullptr;
  Node* first_child = nullptr;
  Node* last_child = nullptr;

  SourceData* data = nullptr;

  NodeFlags flags = {};

  rtr::TypeId type = nil;

  NodeState state;

  b8 hasChildren() const
  {
    return first_child != nullptr;
  }

  b8 isOpen() const
  {
    return flags.test(NodeFlag::Open);
  }
};

/* ============================================================================
 */
struct NodeIterState
{
  Node* current;

  Node* operator ++ ()
  {
    current = current->next;
    return current;
  }

  bool operator != (const NodeIterState& rhs) const
  {
    return current != rhs.current;
  }

  Node* operator -> ()
  {
    return current;
  }

  Node& operator * ()
  {
    return *current;
  }
};

struct NodeIter
{
  Node* node;

  NodeIterState begin() 
  {
    return NodeIterState { node };
  }

  NodeIterState end()
  {
    return NodeIterState { nullptr };
  }
};

/* ----------------------------------------------------------------------------
 */
NodeIter eachChild(Node* node)
{
  return NodeIter { node->first_child };
}

/* ============================================================================
 */
struct Ctx
{
  SourceDataEditor* sde;

  mem::Bump* bump = nullptr;
};

/* ----------------------------------------------------------------------------
 *  Formats the given args and returns a String cached in the bump buffer.
 */
static String fmt(Ctx& self, auto&&... args)
{
  io::SmallBuffer<512> buf;
  io::formatv(&buf, args...);
  return String(buf).allocateCopy(self.bump);
}

/* ----------------------------------------------------------------------------
 */
static Node* addChild(
    Ctx& self, 
    String name, 
    Node* parent,
    SourceData* data,
    rtr::TypeId type)
{
  auto* child = self.bump->construct<Node>();

  child->name = name;
  child->data = data;
  child->type = type;

  if (parent->first_child == nullptr)
  {
    parent->first_child = child;
    parent->last_child = child;
  }
  else
  {
    parent->last_child->next = child;
    parent->last_child = child;
  }

  return child;
}

/* ----------------------------------------------------------------------------
 */
static Node* addChildAndSearchName(
    Ctx& self, 
    String name, 
    Node* parent,
    rtr::TypeId type)
{
  assert(parent->data != nullptr);

  Node* child = addChild(
    self, 
    name, 
    parent, 
    parent->data->findChildByName(name),
    type);

  if (child->data == nullptr)
  {
    // Expected data is missing (this happens with structs), 
    // so create a placeholder and mark node as missing.
    child->data = self.sde->default_data.allocateSourceData();
    child->data->name = name;
    child->flags.set(NodeFlag::MissingData);
  }

  return child;
}

/* ----------------------------------------------------------------------------
 */
static Node* addChildFromIdx(
    Ctx& self, 
    String name, 
    Node* parent,
    rtr::TypeId type,
    u32 idx)
{
  assert(parent->data != nullptr);

  SourceData* child_data = parent->data->findChildByIndex(idx);
  assert(child_data != nullptr);

  return addChild(
    self,
    name,
    parent,
    child_data,
    type);
}

/* ----------------------------------------------------------------------------
 */
template<typename T>
static T* allocNodeState(Ctx& self, Node* node)
{
  assert(node->state.ptr == nullptr);
  node->state.ptr = self.bump->construct<T>();
  return node->state.as<T>();
}

/* ============================================================================
 */
enum class DataPart
{
  Name,
  Type,
  Value
};

/* ----------------------------------------------------------------------------
 */
static inline String getPartString(SourceData* data, DataPart part)
{
  switch (part)
  {
  case DataPart::Name:
    return data->name;
  case DataPart::Type:
    return data->type;
  case DataPart::Value:
    return data->val.str;
  }
  return nil;
}

/* ============================================================================
 */
struct TextField
{
  ui::TextFieldState state;
  
  io::StaticBuffer<256> buffer;

  void init(SourceData* data, DataPart part)
  {
    state.edit.setBuffer(
    {
      .ptr = buffer.arr,
      .len = &buffer.len,
      .space = buffer.capacity(),
    });

    String init = getPartString(data, part);
    if (init.len > buffer.capacity())
    {
      @log.error(sdata, 
        "source data string is too long to store in a text field");
      return;
    }

    io::format(&buffer, init);
  }

  void put(
      ui::UI& ui, 
      ui::ItemId id,
      Rect bounds,
      DataPart part, 
      SourceData* data,
      const SourceDataEditorSkinDef& skin)
  {
    ui::TextFieldResult result = ui.putTextField(
      id,
      bounds,
      &state,
      skin.text_field);
    
    if (result.test(ui::TextFieldFlag::Commit))
    {
      println("commit");
    }
  }
};

$ -- * ------------------------------------------------------------------------

@[init_tree] av:funcgen(
  sde_initTree_,
  static void,
  Ctx& self,
  Node* node)

$ -- * ------------------------------------------------------------------------

@[put_inline] av:funcgen(
  sde_putInlineContent_,
  static void,
  SourceDataEditor& self,
  ui::UI& ui,
  Rect bounds,
  Node* node,
  const SourceDataEditorSkinDef& skin)

$ local inline_nodes = List {}

$ local function declareInline(node)
$   inline_nodes:push(node)
$   return put_inline.declare(node)
$ end

$ -- * ------------------------------------------------------------------------

$ av:previsit(ast.iro_builtins, function(type)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.stub(type)) 

  /* --------------------------------------------------------------------------
   */
  $(declareInline(type))
  {
    
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "iro::utf8::String", function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    allocNodeState<TextField>(self, node)->init(
      node->data,
      DataPart::Value);
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    node->state.as<TextField>()->put(
      ui,
      "string-field"_fid,
      bounds,
      DataPart::Value,
      node->data,
      skin);
  }
$ end)

$ -- * ------------------------------------------------------------------------

struct RectState
{
  TextField x;
  TextField y;
  TextField w;
  TextField h;
};

static void initRectTextField(
    Ctx& self, 
    Node* node,
    String name,
    TextField* field)
{
  SourceData* comp = node->data->findChildByName(name);
  if (comp == nullptr)
    comp = node->data->addNumberValue(self.sde->default_data, name, 0.f);
  
  field->init(comp, DataPart::Value);
}

$ av:visit(lookup "Rect", function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    auto* state = allocNodeState<RectState>(self, node);
    initRectTextField(self, node, "x"_str, &state->x);
    initRectTextField(self, node, "y"_str, &state->y);
    initRectTextField(self, node, "w"_str, &state->w);
    initRectTextField(self, node, "h"_str, &state->h);
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    auto* state = node->state.as<RectState>();

    Rect comp_bounds = {};
    comp_bounds.x = bounds.x;
    comp_bounds.y = bounds.y;
    comp_bounds.w = math::floor(bounds.w / 4.f);
    comp_bounds.h = bounds.h;

$   local function placeNameAndField(name)
    {
      f32 comp_offset = ui.putText(comp_bounds, "$(name)"_str, skin.text).x;
      Rect field_bounds = comp_bounds
        .contractedLeft(comp_offset)
        .contractedX(2.f);

      state->$(name).put(
        ui, 
        "rect-$(name)"_fid, 
        field_bounds,
        DataPart::Value,
        node->data->findChildByName("$(name)"_str),
        skin);

      comp_bounds.x += comp_bounds.w;
    }
$   end

    @placeNameAndField "x"
    @placeNameAndField "y"
    @placeNameAndField "w"
    @placeNameAndField "h"
  }

$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(ast.Enum, function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.stub(decl)) // no children, edited inline.
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "iro::Flags", function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.stub(decl))
$ end)

$ -- * ------------------------------------------------------------------------
  
$ av:visit(ast.Struct, function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
$ for field in decl:eachField() do
    {
      Node* child = addChildAndSearchName(
        self, 
        "$(field.name)"_str, 
        node,
        "$(field.type.qname)"_typeid);

      $(init_tree.call(field.type))(self, child);
    }
$ end
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "reflect::Array", function(decl)
$   local subtype = decl.args[1]
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    for (s32 i = 0; i < node->data->children.len; ++i)
    {
      Node* child = addChildFromIdx(
        self,
        fmt(self, '[', i, ']'),
        node,
        "$(subtype.qname)"_typeid,
        i);

      $(init_tree.call(subtype))(self, child);
    }
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "reflect::StringMap", function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:visit(lookup "reflect::TypedPtr", function(decl)
$   local subtype = decl.args[1]:desugar()
$   local subdecl = subtype.decl
$   for derived in subdecl:allDerived() do
$     av:handleDecl(derived)
$   end
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    switch (node->data->type.hash())
    {
$   for derived in subdecl:allDerived() do
    case "$(derived.type.qname)"_typeid_val:
      $(init_tree.call(derived))(self, node);
      break;
$   end
    }
  }

  /* --------------------------------------------------------------------------
   */
  $(declareInline(decl))
  {
    if (ui.beginDropDown("typed-ptr-dropdown"_fid,
          bounds,
          100.f,
          node->data->type,
          skin.dropdown))
    {
      Rect button_bounds = {};
      button_bounds.x = 0.f;
      button_bounds.y = 0.f;
      button_bounds.w = ui.getWidth();
      button_bounds.h = 14.f;

$   for derived in subdecl:allDerived() do
      if (ui.putButton("typed-ptr-select-$(derived.qname)"_fid,
            button_bounds,
            "$(derived.qname)"_str,
            skin.button))
      {
        println("select $(derived.qname)");
        ui.closePopup();        
      }
      button_bounds.y += button_bounds.h;
$   end

      ui.endDropDown();
    }
  }
$ end)

$ -- * ------------------------------------------------------------------------
$ -- Typedefs just passthrough to their subtype for now. Eventually though 
$ -- we should be checking for metadata applied to them that may alter 
$ -- their behavior in the editor.

$ av:visit(ast.TypedefDecl, function(decl)
  /* --------------------------------------------------------------------------
   */
  $(init_tree.declare(decl))
  {
    $(init_tree.call(decl.subtype))(self, node);
  }
$ end)

$ -- * ------------------------------------------------------------------------

$ av:begin(function(decl)
$   return decl.metadata.def ~= nil
$ end)

$ -- * ------------------------------------------------------------------------

$ av:eachVisited(function(decl)
$   if decl.user.has_inline then
$     print(decl)
$   end
$ end)

/* ----------------------------------------------------------------------------
 */
b8 SourceDataEditor::init()
{
  if (!node_allocator.init())
    return false;

  if (!default_data.init())
    return false;

  return true;
}

/* ----------------------------------------------------------------------------
 */
void SourceDataEditor::setSourceData(
    SourceData* sdata, 
    SourceDataFile* sfile, 
    rtr::TypeId type_id)
{
  this->sdata = sdata;
  this->sfile = sfile;
  this->type_id = type_id;

  node_allocator.clear();

  Node* root = node_allocator.construct<Node>();
  root->type = type_id;
  root->data = sdata;

  root_node = root;

  Ctx ctx;
  ctx.sde = this;
  ctx.bump = &node_allocator;

  switch (type_id.val)
  {
$ av:eachVisited(function(decl)
  case "$(decl.type.qname)"_typeid_val:
    $(init_tree.call(decl))(ctx, root);
    break;
$ end)
  }
}

/* ============================================================================
 */
struct PutParams
{
  u32 depth = 0;
  f32 y = 0.f;
  f32 max_name_extent = 0.f;
  u32 node_idx = 0;
};

/* ============================================================================
 */
struct PutResult
{
  f32 height = 0.f;
};

/* ----------------------------------------------------------------------------
 */
static void putInlineContent(
    SourceDataEditor& self,
    ui::UI& ui,
    Node& node,
    PutParams& params,
    const SourceDataEditorSkinDef& skin)
{
  Rect bounds = {};
  bounds.x = params.max_name_extent + skin.row.name_value_spacing;
  bounds.y = params.y;
  bounds.w = ui.getWidth() - bounds.x - skin.row.right_padding;
  bounds.h = skin.row.height;
  bounds.contractY(2.f);
  
  switch (node.type.val)
  {
$ for node in inline_nodes:each() do
$   local qname
$   if node:is(ast.Type) then
$     qname = node.qname
$   else
$     qname = node.type.qname
$   end
$   if node:is(ast.Decl) then
$     if node.typedefs then
$       for typedef in node.typedefs:each() do
  case "$(typedef.type.qname)"_typeid_val:
$       end
$     end
$   end
  case "$(qname)"_typeid_val:
    $(put_inline.call(node))(
      self, 
      ui, 
      bounds, 
      &node,
      skin);
    break;
$ end
  }
}

/* ----------------------------------------------------------------------------
 */
static inline String getNodeNamePrefix(Node& node)
{
  if (node.hasChildren())
    return node.isOpen()? "- "_str : "+ "_str;
  return nil;
}

/* ----------------------------------------------------------------------------
 */
static PutResult putNode(
    SourceDataEditor& self,
    ui::UI& ui,
    Node& node,
    PutParams& params,
    const SourceDataEditorSkinDef& skin)
{
  ui.pushId(ui.generateIdFromPointer(&node));
  defer { ui.popId(); };

  auto name_bounds = Rect::from(
    params.depth * skin.children_indent,
    params.y,
    999.f,
    skin.row.height);

  String prefix = getNodeNamePrefix(node);
  f32 prefix_offset = 0.f;
  if (notnil(prefix))
    name_bounds.x += ui.putText(name_bounds, prefix, skin.text).x;

  vec2f name_size = ui.putText(name_bounds, node.name, skin.text);

  putInlineContent(
    self,
    ui,
    node,
    params,
    skin);

  PutParams child_params = params;
  child_params.depth += 1;
  child_params.y += max(name_size.y, skin.row.height);

  for (Node& child : eachChild(&node))
  {
    PutResult result = putNode(self, ui, child, child_params, skin);
    child_params.y += max(result.height, skin.row.height);
  }

  PutResult result = {};
  result.height = child_params.y - params.y;

  return result;
}

/* ----------------------------------------------------------------------------
 */
static f32 computeNodeNameExtent(
    SourceDataEditor& self,
    ui::UI& ui,
    Node& node,
    u32 depth,
    const SourceDataEditorSkinDef& skin)
{
  auto name_bounds = Rect::from(0, 0, 999.f, 999.f);

  vec2f name_size = ui.measureText(name_bounds, node.name, skin.text);

  if (node.hasChildren())
  {
    String prefix = node.isOpen()? "- "_str : "+ "_str;
    name_size.x += ui.measureText(name_bounds, prefix, skin.text).x;
  }

  f32 name_extent = name_size.x + skin.children_indent * depth;

  for (Node& child : eachChild(&node))
  {
    f32 child_extent = computeNodeNameExtent(
      self,
      ui,
      child,
      depth + 1,
      skin);

    name_extent = max(name_extent, child_extent);
  }

  return name_extent;
}

/* ----------------------------------------------------------------------------
 */
void SourceDataEditor::put(
    UI& ui,
    Rect bounds,
    const SourceDataEditorSkinDef& skin)
{
  ZoneScopedN("SourceDataEditor::update");

  ui.beginScrollGroup("sde-scroll"_fid, bounds, skin.scroll_bar);

  if (root_node != nullptr)
  {
    auto* root = (Node*)root_node;

    f32 max_name_extent = 0.f;
    for (Node& child : eachChild(root))
    {
      f32 child_extent = computeNodeNameExtent(*this, ui, child, 0, skin);
      max_name_extent = max(child_extent, max_name_extent);
    }

    max_name_extent = max(max_name_extent, skin.row.min_name_width);

    ui.putQuad(Rect::from(0, 0, max_name_extent, 10.f), 0xff0000ff);

    PutParams params = {};
    params.depth = 0;
    params.y = 0.f;
    params.max_name_extent = max_name_extent;

    for (Node& child : eachChild(root))
    {
      PutResult result = putNode(*this, ui, child, params, skin);

      params.y += max(result.height, skin.row.height);
    }
  }

  ui.endScrollGroup(skin.scroll_bar);
}
