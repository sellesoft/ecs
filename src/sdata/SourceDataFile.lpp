$ local cmn = require "common"

@lpp.import "sdata/SourceDataFile.lh"
@lpp.import "sdata/SourceDataParser.lh"

#include "iro/fs/File.h"

@log.import

/* ----------------------------------------------------------------------------
 */
b8 SourceDataFile::init()
{
  if (!string_cache.init())
    return @log.error(sdata, "failed to init string cache\n");

  if (!data_pool.init())
    return @log.error(sdata, "failed to init data pool\n");

  if (!aux_data_list.init())
    return @log.error(sdata, "failed to init aux data list\n");

  return true;
}

/* ----------------------------------------------------------------------------
 */
void SourceDataFile::deinit()
{
  string_cache.deinit();
  
  for (SourceData& data : aux_data_list)
    data.destroy();

  if (returned_data != nullptr)
    returned_data->destroy();

  returned_data = nullptr;

  data_pool.deinit();
  aux_data_list.deinit();
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataFile::from(SourceDataFile* sfile, String path)
{
  using namespace iro;
  using namespace iro::fs;

  // Basic check that the provided sfile is not yet initialized.
  assert(isnil(sfile->data_pool) && 
        "SourceDataFile::from given an already initialized sfile");
  
  if (!sfile->init())
    return @log.error(sdata, 
      "failed to initialize source data file for opening "
      "from path '", path, "'\n");
  auto failsafe = deferWithCancel { sfile->deinit(); };

  File file = File::openForRead(path);
  if (isnil(file))
    return @log.error(sdata, 
      "failed to open source data file at path '", path, "'\n");
  defer { file.close(); };
  
  if (!parseSourceDataFile(sfile, &file, path))
    return @log.error(sdata, 
      "failed to parse source data file at path '", path, "'\n");

  failsafe.cancel();
  return true;
}

/* ----------------------------------------------------------------------------
 */
void SourceDataFile::dump(io::WStream* out)
{
  for (SourceData& aux : aux_data_list)
    aux.dump(out);

  if (returned_data != nullptr)
  {
    io::format(out, "return ");
    returned_data->dump(out);
  }
}

/* ----------------------------------------------------------------------------
 */
void SourceDataFile::dump()
{
  dump(fs::stdout());
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataFile::dumpToDisk(String path)
{
  auto file = fs::File::createForTruncatedWriting(path);
  if (isnil(file))
    return false;
  defer { file.close(); };

  dump(&file);
  return true;
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceDataFile::allocateSourceData()
{
  return data_pool.add();
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceDataFile::addAuxData()
{
  auto out = allocateSourceData();
  aux_data_list.pushTail(out);
  return out;
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceDataFile::addReturnData()
{
  assert(returned_data == nullptr);
  returned_data = allocateSourceData();
  return returned_data;
}

/* ----------------------------------------------------------------------------
 */
SourceData* SourceDataFile::findAuxData(String name)
{
  for (SourceData& aux : aux_data_list)
  {
    if (aux.name == name)
      return &aux;
  }

  return nullptr;
}

