/*
 *  UI system!
 */

$ local cmn = require "common"
$ local List = require "iro.List"

@lpp.import "ui/Skin.defs.lh"
@lpp.import "ui/TextEdit.lh"

@lpp.import "graphics/Buffer.lh"
@lpp.import "graphics/CompiledTexture.lh"
@lpp.import "graphics/Pipeline.lh"
@lpp.import "graphics/Shader.lh"
@lpp.import "graphics/TextureHandle.lh"
@lpp.import "graphics/Pipeline.resource.lh"

@lpp.import "input/InputState.lh"

@lpp.import "reflect/Linker.lh"

#include "iro/containers/StackArray.h"
#include "iro/containers/EnumArray.h"
#include "iro/memory/Bump.h"
#include "iro/memory/LinkedHeap.h"
#include "math/Rect.h"
#include "math/mat.h"
#include "Color.h"

namespace gfx
{
struct Vulkan;
struct Buffer;
struct RenderPass;
struct ResourceMgr;
}

struct InputMgr;
struct mat3x2;

namespace ui
{

struct UI;
struct TextEdit;
struct Group;

$$$
local focus_flags = List
{
  "Focused",
  "Hovered",

  "PrimaryDown",
  "PrimaryPressed",
  "PrimaryReleased",

  "SecondaryDown",
  "SecondaryPressed",
  "SecondaryReleased",

  "TertiaryDown",
  "TertiaryPressed",
  "TertiaryReleased",
}
$$$

/* ============================================================================
 */
enum class FocusFlag
{
$ for flag in focus_flags:each() do
  $(flag),
$ end

  COUNT
};
typedef Flags<FocusFlag> FocusFlags;

/* ============================================================================
 *  Helper type that wraps focus flags. May be expanded later to contain
 *  more information, but mostly writing ui::FocusFlag::PrimaryDown is 
 *  annoying.
 */
struct Focus
{
  FocusFlags flags;

$ for flag in focus_flags:each() do
$   local prefix = "is"
$   if flag:find "Pressed" or flag:find "Released" then
$     prefix = "was"
$   end
  b8 $(prefix)$(flag)() const 
  {
    return flags.test(FocusFlag::$(flag));
  }
$ end
};

/* ============================================================================
 */
struct ItemId
{
  u64 val = 0;

  bool operator == (const ItemId& rhs) const
  {
    return val == rhs.val;
  }

  DefineNilTrait(ItemId, {0}, x.val == 0);
};

/* ============================================================================
 */
struct CombinedItemId
{
  u64 val = 0;

  bool operator == (const CombinedItemId& rhs) const
  {
    return val == rhs.val;
  }

  DefineNilTrait(CombinedItemId, {0}, x.val == 0);
};

/* ============================================================================
 */
struct Item
{
  CombinedItemId id = {};
    
  // Id of the popup this was placed in.
  CombinedItemId parent_popup = {};
  Rect bounds = {};

  Item* next = nullptr;
};

/* ============================================================================
 */
struct Cmd
{
  Cmd* next;

  // The Group that was active when this Cmd was pushed.
  Group* group;

  virtual void execute(UI& ui, gfx::RenderPass& renderer) = 0;
};

/* ============================================================================
 */
struct TransformCmd : Cmd
{
  mat3x2* transform;

  void execute(UI& ui, gfx::RenderPass& renderer) override;
};

/* ============================================================================
 */
struct ScissorCmd : Cmd
{
  Rect bounds = {};

  void execute(UI& ui, gfx::RenderPass& renderer) override;
};

/* ============================================================================
 */
struct QuadDrawCmd : Cmd
{
  gfx::TextureHandle texture;
  Color color;
  Rect bounds;
  vec4f uv;

  void execute(UI& ui, gfx::RenderPass& renderer) override;
};

/* ============================================================================
 */
struct BorderDrawCmd : Cmd
{
  Rect bounds;
  Rect offsets;
  Color color;

  void execute(UI& ui, gfx::RenderPass& renderer) override;
};

/* ============================================================================
 */
struct LineDrawCmd : Cmd
{
  vec2f start;
  vec2f end;
  Color color;

  void execute(UI& ui, gfx::RenderPass& renderer) override;
};

/* ============================================================================
 */
enum class GroupScissor
{
  Self,
  Parent,
  None,
};

/* ============================================================================
 */
struct Group
{
  // This Group's local bounds.
  Rect bounds = {};

  // This group's scissor in screen space.
  Rect scissor = {};

  // Extent of things drawn within this Group (widgets as well as child 
  // Groups) relative to the group's screen position.
  Rect extents = {};

  mat3x2 transform = {};

  GroupScissor scissoring = GroupScissor::Self;

  Item* items = nullptr;

  Group* parent = nullptr;
  Group* next = nullptr;
};

/* ============================================================================
 */
struct CmdList
{
  Cmd* first = nullptr;
  Cmd* last = nullptr;

  CmdList* prev = nullptr;
};

/* ============================================================================
 *  TODO(sushi) it would be nice to eliminate this to cut down the amount of 
 *              layers to 2, but not sure how at the moment without sacrificing
 *              the idea of Layers being actual layers.
 */ 
struct Panel
{
  Item item = {}; // NOTE(sushi) this is largely unused I believe.
  
  Group* groups = nullptr;
  Group* current_group = nullptr;

  Panel* parent = nullptr;
  Panel* next = nullptr;

  CmdList cmd_list = {};
  CmdList* cmd_list_stack = nullptr;
};

/* ============================================================================
 */
enum class LayerFlag
{
  TopMost,
  TakeFocus,

  COUNT
};
typedef Flags<LayerFlag> LayerFlags;

/* ============================================================================
 */
struct Layer
{
  Panel* panels = nullptr;
  Panel* current_panel = nullptr;

  Layer* prev = nullptr;
  Layer* next = nullptr;

  void pushCmd(Cmd* cmd);
};

/* ============================================================================
 *  Flags that may be returned by putTextField() describing various things 
 *  that the user did.
 */
enum class TextFieldFlag
{
  // Set while this text field is focused.
  Focused,

  // Some text was changed.
  TextChanged,

  // The Cursor was moved. This may be set via the user pressing an arrow
  // key OR the cursor having moved because text was changed.
  CursorMoved,

  // User tried to insert some text, but the buffer was too small.
  BufferTooSmall,

  // Enter was pressed.
  Commit,

  COUNT
};

typedef Flags<TextFieldFlag> TextFieldResult;

/* ============================================================================
 *  State intended to be kept persistent by users of TextFields.
 */
struct TextFieldState
{
  // X offset of this field's text. Used to follow the cursor when its moved
  // outside of the visible text.
  f32 x_offset;

  // State tracking a buffer to edit as well as the cursor that moves through
  // the buffer.
  TextEdit edit;
};

/* ============================================================================
 */
struct ScrollBarState
{
  f32 scroll_value;
};

/* ============================================================================
 */
struct PersistentState
{
  CombinedItemId id;

  void* ptr;
  u64   size;

  u64 last_frame_touched;

  b8 isUsed() const
  {
    return notnil(id) && ptr != nullptr && size != 0;
  }
};

/* ============================================================================
 */
struct PersistentStateMgr
{
  enum
  {
    c_MaxStates = 256,
    c_HeapSize = unit::kilobytes(4)
  };

  void* heap_ptr;
  mem::LinkedHeap heap;

  PersistentState states[c_MaxStates];
  u32 num_states;

  b8 init(mem::Allocator* allocator);
  void deinit(mem::Allocator* allocator);

  struct GetResult
  {
    PersistentState* pstate;
    b8 just_created;
  };

  GetResult registerOrGetState(CombinedItemId id, u64 size, u64 frame_count);

  void unregisterState(u64 idx);

  void cleanOldStates(u64 frame_count);
};

/* ============================================================================
 */
enum class PopupFlag
{
  // Close popup when an input is made elsewhere.
  Dismissable,

  // Focus immediately upon opening.
  FocusOnOpen,
  
  COUNT
};
typedef Flags<PopupFlag> PopupFlags;

DefineFlagsOrOp(PopupFlags, PopupFlag);

/* ============================================================================
 */
struct UI
{
  enum
  {
    c_MaxVertices = 0xffff,
    c_MaxIndices = (c_MaxVertices / 4) * 6,
    c_PushConstantSize = 16 * sizeof(f32),
  };
 
  struct InitParams
  {
    gfx::Vulkan& vk;
    reflect::Linker& linker;
    Rect viewport;
    gfx::TextureHandle white_texture;
  };

  b8   init(InitParams& params);
  void deinit(gfx::Vulkan& vk);

  struct FrameParams
  {
    // The input state to be applied during this frame.
    InputState input;

    // The viewport drawn into this frame.
    Rect viewport;
  };

  void beginFrame(const FrameParams& params);
  void endFrame(InputState* consumed_input = nullptr);

  // TODO(sushi) remove.
  Rect frame_viewport;

  // NOTE(sushi) UI state is not cleared in endFrame but here, for now.
  //             I need to clean that up later but i want to be done with 
  //             renderer rework !
  void render(gfx::RenderPass& pass, Rect viewport);

  Rect getBounds() const 
  { 
    return Rect::from({0,0}, getCurrentGroup()->bounds.size());
  }

  f32 getWidth() const { return getCurrentGroup()->bounds.w; }
  f32 getHeight() const { return getCurrentGroup()->bounds.h; }

  void putQuad(Rect bounds, gfx::TextureHandle texture, vec4f uv, Color color);
  void putQuad(Rect bounds, gfx::TextureHandle texture, Color color);
  void putQuad(Rect bounds, Color color);

  Focus putFocusableBounds(ItemId id, Rect bounds)
    { return putFocusableBounds(getCombinedId(id), bounds); }
  Focus putFocusableBounds(CombinedItemId id, Rect bounds);

  // Pushes a layer and starts a new panel at the given bounds with the 
  // given id.
  void pushLayer(ItemId id, Rect bounds, LayerFlags flags);

  void pushLayer(
    ItemId id, 
    Rect bounds, 
    LayerFlags flags, 
    GroupScissor scissoring)
  {
    pushLayer(getCombinedId(id), bounds, flags, scissoring);
  }

  void pushLayer(
    CombinedItemId id, 
    Rect bounds, 
    LayerFlags flags, 
    GroupScissor scissoring);

  void popLayer();

  void beginCmdFrontInjection();
  void endCmdFrontInjection();

  void pushCmdList();
  void popCmdListToFront();
  void popCmdListToBack();

  // Begins a new panel.
  void beginPanel(ItemId id, Rect bounds);
  void beginPanel(ItemId id, Rect bounds, Panel* prev);

  void beginPanel(
    ItemId id, 
    Rect bounds, 
    Panel* prev, 
    GroupScissor scissoring)
  {
    beginPanel(getCombinedId(id), bounds, prev, scissoring, false);
  }

  void beginPanel(
    CombinedItemId id,
    Rect bounds,
    Panel* prev,
    GroupScissor scissoring,
    b8 take_focus);

  void endPanel();

  void beginGroup(Rect bounds, GroupScissor scissoring = GroupScissor::Self);
  void endGroup();

  void openPopup(ItemId id) { openPopup(getCombinedId(id)); }
  void openPopup(CombinedItemId id);

  void closePopup(ItemId id) { closePopup(getCombinedId(id)); }
  void closePopup(CombinedItemId id);
  void closePopup();

  b8 beginPopup(ItemId id, Rect bounds, PopupFlags flags = {})
  {
    return beginPopup(getCombinedId(id), bounds, flags);
  }

  b8 beginPopup(CombinedItemId id, Rect bounds, PopupFlags flags = {});
  void endPopup();

  b8 isPopupOpen(ItemId id) const { return isPopupOpen(getCombinedId(id)); }
  b8 isPopupOpen(CombinedItemId id) const;

  // Places a basic 'item', a decorated rect basically.
  void putItem(Rect bounds, const ItemSkin& skin);

  vec2f getLocalCursorPos() const;

  // Places undecorated text.
  // TODO(sushi) basic text functions that don't require a skin
  //             and use a default font (gohu, of course) stored on UI.
  vec2f putText(Rect bounds, String text, const TextSkin& skin);

  // Places text with a background and various other decor (eventually).
  void putTextItem(Rect bounds, String text, const TextItemSkin& skin);

  vec2f measureText(Rect bounds, String text, const TextSkin& skin);

  // Returns true if clicked.
  b8 putButton(
    ItemId id, 
    Rect bounds, 
    String text, 
    const ButtonSkin& skin);

  b8 putCheckbox(
    ItemId id,
    Rect bounds,
    b8* enabled,
    const CheckboxSkin& skin);

  // Places a text field that edits some text specified in the state.
  TextFieldResult putTextField(
    ItemId id,
    Rect bounds, 
    TextFieldState* state,
    const TextFieldSkin& skin);

  // Variant of the above which just takes a buffer of text to edit. The 
  // state of the text field is managed internally by UI. If the field goes
  // unused for too long its state will be cleared. To avoid this, use the 
  // above function with a TextFieldState stored elsewhere.
  TextFieldResult putTextField(
    ItemId id,
    Rect bounds,
    TextEdit::Buffer buffer,
    const TextFieldSkin& skin);

  b8 beginDropDown(
    ItemId id, 
    Rect bounds,
    f32 open_height,
    String selected_text,
    const DropDownSkin& skin);
  
  void endDropDown();

  void beginScrollGroup(ItemId id, Rect bounds, const ScrollBarSkin& skin);
  void endScrollGroup(const ScrollBarSkin& skin, b8 scroll_to_end = false);

  void pushGroupRenderState(Group* group);

  // Bump allocator for memory allocated throughout a UI frame.
  mem::Bump frame_allocator;

  Rect viewport = {};

  // Graphics stuff.
  gfx::Pipeline pipeline;
  gfx::PipelineLink l_pipeline;

  gfx::TextureHandle white_texture;

  gfx::Buffer vertex_buffer;
  gfx::Buffer index_buffer;

  // True when a UI frame is in progress.
  b8 in_frame = false;

  // How many times UI has begun and ended a frame.
  u64 frame_count = 0;

  // The input state of an update. Inputs may be consumed from this 
  // state by either UI or Items.
  InputState frame_input;

  // Because I'm tired of accessing `frame_input` everytime I need to check
  // if a mouse button was released globally, I'm adding these. HOWEVER I 
  // also think that if you need to check this (eg. something uses mouse
  // drag, so may be released on a UI Item other than what it started on)
  // you should use these in case we ever decide that what maps to 'Primary,'
  // 'Secondary,' etc. can be different than just mouse buttons.
  // Its also more explicit. Makes it look less like you forgot to check the
  // focus flags rather than raw input.
$ local function globalReleaseTest(x, y)
  b8 was$(x)ReleasedGlobally() const 
    { return frame_input.wasMouseButtonReleased(MouseButton::$(y)); }
$ end
  @globalReleaseTest(Primary, Left)
  @globalReleaseTest(Secondary, Right)
  @globalReleaseTest(Tertiary, Middle)

  vec2i draw_counts = {};
  
  enum class InternalPopupFlag
  {
    JustOpened,

    COUNT
  };
  typedef Flags<InternalPopupFlag> InternalPopupFlags;

  // Data relevant to an opened popup.
  struct PopupData
  {
    CombinedItemId id;
    PopupFlags flags;
    InternalPopupFlags internal_flags;

    void reset()
    {
      id = nil;
      flags.clear();
      internal_flags.clear();
    }
  };

  StackArray<PopupData, 16> open_popups;

  // Stack of popups that have been begun.
  StackArray<PopupData*, 16> popup_stack;

  PopupData* getOpenPopupData(CombinedItemId id);

  struct FocusState
  {
    Item focused;
    Item hovered;
    FocusFlags flags;
    // Cursor position in local space of the focused Item captured when it is
    // pressed.
    vec2f pressed_cursor_offset;
  };

  FocusState prev_focus_state;
  FocusState focus_state;
  FocusState next_focus_state;

  b8 isFocusedItem(ItemId id) const 
    { return isFocusedItem(getCombinedId(id)); }
  b8 isFocusedItem(CombinedItemId id) const 
    { return focus_state.focused.id == id; }

  b8 isHoveredItem(ItemId id) const
    { return isHoveredItem(getCombinedId(id)); }
  b8 isHoveredItem(CombinedItemId id) const
    { return focus_state.hovered.id == id; }

  Focus getFocus() const
    { return {focus_state.flags}; }

  void drawDebugRect(Rect rect, Color color = 0xff0000ff);
  void drawDebugBorder(Rect rect, Color color = 0xff0000ff);
  void drawDebugLine(vec2f start, vec2f end, Color color = 0xff0000ff);

  Cmd* debug_cmds = nullptr;

  // The initial Layer created on frame start.
  Layer* root_layer = nullptr;

  // The current layer being operated on this frame.
  Layer* current_layer = nullptr;

  PersistentStateMgr persistent_state_mgr;

  StackArray<CombinedItemId, 64> id_stack;
  CombinedItemId current_id = {};

  void pushId(ItemId id) { pushId(getCombinedId(id)); }
  void pushId(CombinedItemId id);
  void popId();

  template<typename T>
  b8 registerOrGetPersistentState(CombinedItemId id, T** out_state)
  {
    PersistentStateMgr::GetResult result = 
      persistent_state_mgr.registerOrGetState(id, sizeof(T), frame_count);

    if (result.pstate == nullptr)
      return false;

    *out_state = (T*)result.pstate->ptr;
    return result.just_created;
  }

  template<typename T>
  T* getPersistentState(CombinedItemId id)
  {
    PersistentStateMgr::GetResult result = 
      persistent_state_mgr.registerOrGetState(id, sizeof(T), frame_count);

    assert(result.pstate != nullptr && !result.just_created);

    return (T*)result.pstate->ptr;
  }

  template<typename T>
  b8 registerOrGetPersistentState(ItemId id, T** out_state)
  {
    return registerOrGetPersistentState(getCombinedId(id), out_state);
  }

  void pushConstantFromTransform(mat3x2 transform, gfx::RenderPass& pass);

  // Combines the given ids.
  CombinedItemId combineIds(ItemId a, ItemId b) const;
  CombinedItemId combineIds(CombinedItemId a, ItemId b) const;

  // Combines the given id with the id of the current panel.
  CombinedItemId getCombinedId(ItemId id) const;

  ItemId generateIdFromPointer(void* ptr) const
  {
    // TODO(sushi) prob want something more robust than this.
    return ItemId{(u64)ptr};
  }

  ItemId generateIdFromInteger(s64 i) const
  {
    return ItemId{ (u64)i };
  }

  Layer* getCurrentLayer() const { return current_layer; }
  Panel* getCurrentPanel() const { return getCurrentLayer()->current_panel; }
  Group* getCurrentGroup() const { return getCurrentPanel()->current_group; }

  void expandCurrentGroupExtents(Rect bounds)
  {
    getCurrentGroup()->extents.expandToContain(bounds);
  }
};

}

consteval ui::ItemId operator ""_fid(const char* c, size_t s)
{
  return ui::ItemId{operator ""_hashed(c,s)};
}




