$ local cmn = require "common"

@log.ger(test-asset-building, Info)

@@lpp.import "build/BuildSystem.lh"
@@lpp.import "graphics/Texture.defs.lh"
@@lpp.import "graphics/CompiledTexture.lh"
@@lpp.import "graphics/CompiledShader.lh"
@@lpp.import "graphics/Shader.defs.lh"
@@lpp.import "graphics/Font.lh"

#include "iro/fs/fs.h"

/* ----------------------------------------------------------------------------
 */
void rule_data_getPrereqs(
    build::Target* target,
    build::BuildSystem* build_system,
    build::TargetSet* prereqs,
    build::Result* result)
{
  // Data targets need some SourceData to build, which should have the same 
  // name and type, but without the .data extension.
  build::Target* source_target = build_system->findOrCreateTarget(
    target->name,
    target->type.removeSuffix(".data"_str),
    build::TargetKind::SourceData);

  // Note the source target as a prereq.
  prereqs->insert(source_target);
}

/* ----------------------------------------------------------------------------
 */
void rule_data_build(
    build::Target* target,
    build::BuildSystem* build_system,
    build::Result* result)
{
  // Get the target we are building from, it should already exist.
  build::Target* source_target = build_system->findTarget(
    target->name, 
    target->type.removeSuffix(".data"_str),
    build::TargetKind::SourceData);

  assert(source_target != nullptr);

  build::PathBuffer source_path_buffer;
  build::PathBuffer target_path_buffer;

  CompiledData* compiled = build_system->packAndCompileSourceDataAsset(
    source_target->formFullPath(&source_path_buffer),
    target->formFullPath(&target_path_buffer));

  if (compiled == nullptr)
  {
    result->setError("failed to compile source data"_str);
    return;
  }

  for (CompiledData::Ref& ref : compiled->refs.getSlice())
  {
    String def_links = rtr::getMetadataValue(ref.type, "links"_str);

    if (isnil(def_links))
      continue;

    String::Pair split = def_links.splitAtFirst(';');

    for (;;)
    {
      build::Target* links_target = build_system->findOrCreateTarget(
        ref.target.getString(),
        split.first,
        build::TargetKind::Unknown);

      target->links(links_target);

      if (isnil(split.second))
        break;

      split = split.second.splitAtFirst(';');
    }
  }
}

/* ----------------------------------------------------------------------------
 */
void rule_texture_compiled_getPrereqs(
    build::Target* target,
    build::BuildSystem* build_system,
    build::TargetSet* prereqs,
    build::Result* result)
{
  build::Target* data_target = build_system->findOrCreateTarget(
    target->name, 
    "texture.data"_str,
    build::TargetKind::CompiledData);

  prereqs->insert(data_target);

  if (data_target->existsAndIsUpToDate())
  {
    auto* compiled_def = build_system->loadAsCompiledData(data_target);
    if (compiled_def == nullptr)
    {
      result->setError("failed to load compiled TextureDef"_str);
      return;
    }

    auto* texture_def = compiled_def->getRootAs<gfx::TextureDef>();
    if (isnil(texture_def->name))
    {
      result->setError("TextureDef does not specify a source texture"_str);
      return;
    }

    String source_texture_name = fs::path::removeExtension(texture_def->name);
    String source_texture_type = fs::path::getExtension(texture_def->name);

    build::Target* source_texture_target = build_system->findOrCreateTarget(
      source_texture_name,
      source_texture_type,
      build::TargetKind::SourceAsset);

    prereqs->insert(source_texture_target);
  }
}

/* ----------------------------------------------------------------------------
 */
void rule_texture_compiled_build(
    build::Target* target,
    build::BuildSystem* build_system,
    build::Result* result)
{
  build::Target* data_target = build_system->findTarget(
    target->name,
    "texture.data"_str,
    build::TargetKind::CompiledData);

  build::PathBuffer data_path_buffer;
  build::PathBuffer target_path_buffer;

  b8 success = gfx::compileTexture(
    data_target->formFullPath(&data_path_buffer),
    target->formFullPath(&target_path_buffer));

  if (!success)
    result->setError();
}

/* ----------------------------------------------------------------------------
 */
void rule_font_compiled_getPrereqs(
    build::Target* target,
    build::BuildSystem* build_system,
    build::TargetSet* prereqs,
    build::Result* result)
{
  build::Target* data_target = build_system->findOrCreateTarget(
    target->name,
    "font.data"_str,
    build::TargetKind::CompiledData);

  prereqs->insert(data_target);

  if (data_target->existsAndIsUpToDate())
  {
    auto* compiled_def = build_system->loadAsCompiledData(data_target);
    if (compiled_def == nullptr)
    {
      result->setError("failed to load compiled FontDef"_str);
      return;
    }

    auto* font_def = compiled_def->getRootAs<gfx::FontDef>();

    if (isnil(font_def->name))
    {
      result->setError("FontDef does not specify a source font"_str);
      return;
    }
    
    // Parse the source font name.
    String source_font_name = fs::path::removeExtension(font_def->asset_path);
    String source_font_type = fs::path::getExtension(font_def->asset_path);

    build::Target* source_font_target = build_system->findOrCreateTarget(
      source_font_name,
      source_font_type,
      build::TargetKind::SourceAsset);

    prereqs->insert(source_font_target);
  }
}

/* ----------------------------------------------------------------------------
 */
void rule_font_compiled_build(
    build::Target* target,
    build::BuildSystem* build_system,
    build::Result* result)
{
  build::Target* data_target = build_system->findTarget(
    target->name,
    "font.data"_str,
    build::TargetKind::CompiledData);

  build::Target* texture_target = build_system->findTarget(
    target->name,
    "font.texture.compiled"_str,
    build::TargetKind::CompiledAsset);

  build::PathBuffer data_path_buffer;
  build::PathBuffer target_path_buffer;
  build::PathBuffer target_texture_path_buffer;
  
  b8 success = gfx::compileFont(
    data_target->formFullPath(&data_path_buffer),
    target->formFullPath(&target_path_buffer),
    texture_target->formFullPath(&target_texture_path_buffer));

  if (!success)
    result->setError();
}

/* ----------------------------------------------------------------------------
 */
void rule_shader_compiled_getPrereqs(
    build::Target* target,
    build::BuildSystem* build_system,
    build::TargetSet* prereqs,
    build::Result* result)
{
  build::Target* data_target = build_system->findOrCreateTarget(
    target->name, 
    "shader.data"_str,
    build::TargetKind::CompiledData);

  prereqs->insert(data_target);

  if (!data_target->existsAndIsUpToDate())
    return;

  auto* compiled_def = build_system->loadAsCompiledData(data_target);
  if (compiled_def == nullptr)
  {
    result->setError("failed to load compiled ShaderDef"_str);
    return;
  }

  auto* shader_def = compiled_def->getRootAs<gfx::ShaderDef>();

  if (isnil(shader_def->source))
  {
    result->setError("ShaderDef does not specify a source shader"_str);
    return;
  }


  String source_shader_name = fs::path::removeExtension(shader_def->source);
  String source_shader_type = fs::path::getExtension(shader_def->source);

  build::Target* source_shader_target = build_system->findOrCreateTarget(
    source_shader_name,
    source_shader_type,
    build::TargetKind::SourceAsset);

  prereqs->insert(source_shader_target);
}

/* ----------------------------------------------------------------------------
 */
void rule_shader_compiled_build(
    build::Target* target,
    build::BuildSystem* build_system,
    build::Result* result)
{
  build::Target* data_target = build_system->findTarget(
    target->name,
    "shader.data"_str,
    build::TargetKind::CompiledData);

  build::PathBuffer data_path_buffer;
  build::PathBuffer target_path_buffer;

  gfx::CompileShaderParams params = 
  {
    .input_path = data_target->formFullPath(&data_path_buffer),
    .output_path = target->formFullPath(&target_path_buffer),
  };

  if (!gfx::compileShader(params))
    result->setError();
}

b8 testAssetBuilding()
{
  build::Rule rules[] = 
  {
    // .data
    {
      .types = "data"_str,
      .interface = 
      {
        .getPrereqs = rule_data_getPrereqs,
        .build = rule_data_build,
      }
    },
    // .texture.compiled
    {
      .types = "texture.compiled"_str,
      .interface = 
      {
        .getPrereqs = rule_texture_compiled_getPrereqs,
        .build = rule_texture_compiled_build,
      }
    },
    // .font.compiled
    {
      .types = "font.compiled;font.texture.compiled"_str,
      .interface = 
      {
        .getPrereqs = rule_font_compiled_getPrereqs,
        .build = rule_font_compiled_build,
      }
    },
    // .shader.compiled
    {
      .types = "shader.compiled"_str,
      .interface = 
      {
        .getPrereqs = rule_shader_compiled_getPrereqs,
        .build = rule_shader_compiled_build,
      }
    },
  };

  build::PathBuffer cwd_buffer;
  cwd_buffer.len = fs::cwd(cwd_buffer.asBytesBuffer());
  if (cwd_buffer.len == 0)
    return ERROR("failed to get cwd\n");
  String cwd = String(cwd_buffer);

  build::PathBuffer compiled_dir_buffer;
  io::formatv(&compiled_dir_buffer,
    cwd, '/', "tests/asset-building/_data"_str);
  String compiled_dir = String(compiled_dir_buffer);

  build::BuildSystem::InitParams build_system_params = 
  {
    .source_mount = cwd,
    .compiled_mount = compiled_dir,
    .rules = makeSlice(rules),
  };

  build::BuildSystem build_system;
  if (!build_system.init(build_system_params))
    return false;
  defer { build_system.deinit(); };

  return build_system.buildAssetList(
    "tests/asset-building/test.asset_list"_str);
}

int main()
{
  iro::initializeDefaultLogging();
  return testAssetBuilding()? 0 : 1;
}
