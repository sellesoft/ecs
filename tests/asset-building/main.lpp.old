
$ local cmn = require "common"

@@lpp.import "Test.defs.lh"
@@lpp.import "reflect/RTR.lh"
@@lpp.import "asset/Packing.lh"
@@lpp.import "asset/CompiledData.lh"
@@lpp.import "sdata/SourceDataFile.lh"
@@lpp.import "build/Build.defs.lh"
@@lpp.import "graphics/Texture.defs.lh"
@@lpp.import "graphics/CompiledTexture.lh"
@@lpp.import "graphics/CompiledShader.lh"
@@lpp.import "graphics/Shader.defs.lh"
@@lpp.import "graphics/Font.lh"

#include "math/Rect.h"
#include "iro/fs/fs.h"
#include "iro/fs/File.h"
#include "iro/containers/LinkedPool.h"
#include "iro/Scanner.h"

@log.ger(test-asset-building, Info)

typedef io::StaticBuffer<512> PathBuffer;

using namespace build;

// Packs an asset list asset at the given path using the provided PackedData.
// The PackedData is initialized internally!
build::AssetList* packAssetList(String path, PackedData* packed)
{
  DEBUG("loading source data for asset list '", path, "'\n");

  SourceDataFile sfile;
  if (!SourceDataFile::from(&sfile, path))
    return ERROR("failed to load source data for asset list '", path, "'\n"),
           nullptr;
  defer { sfile.deinit(); };

  TRACE("got source data:\n");
  if (TEST_VERBOSITY(Trace))
    sfile.returned_data->dump();

  if (!packed->init())
    return 
      ERROR("failed to initialize PackedData for asset list '", path, "'\n"),
      nullptr;

  TRACE("packing asset list '", path, "'\n");
  PackParams pack_params = { packed };
  if (!packSourceDataFromType(*sfile.returned_data, pack_params))
    return ERROR("failed to pack asset list '", path, "'\n"), nullptr;

  if (packed->type != "build::AssetList"_typeid)
    return ERROR("packed asset list '", path, "' has wrong type\n"), nullptr;

  return packed->getDataAs<build::AssetList>();
}

/* ============================================================================
 */
struct Target;
struct Builder;
typedef AVL<Target> TargetSet;

struct Target
{
  // The asset name of this Target.
  String name;

  // The asset type of this Target, its extension.
  String type;

  // The mount of this Target, the directory it is expected to exist in 
  // or be created in.
  String mount;

  // Combined hash of name and type.
  u64 hash;

  TargetSet dependents;
  TargetSet prerequisites;
  TargetSet linked_targets;

  enum class State
  {
    Unknown,
    QueuedForBuild,
    UpToDate,
  };

  State state;

  TargetKind kind;
  
  // If this Target exists on disk. Cached after a call to cacheExistance.
  b8 exists;

  // If this target does exist, this is its last modified time.
  TimePoint modtime;

  static u64 getAVLKey(const Target& x) { return x.hash; }

  b8 init(String name, String type, String mount, TargetKind kind)
  {
    this->name = name;
    this->type = type;
    this->mount = mount;
    this->kind = kind;

    hash = combineHash(name.hash(), type.hash());

    if (!dependents.init())
      return ERROR("failed to init dependents\n");

    if (!prerequisites.init())
      return ERROR("failed to init prerequisites\n");

    if (!linked_targets.init())
      return ERROR("failed to init linked_targets\n");

    cacheExistance();

    state = State::Unknown;

    return true;
  }

  void deinit()
  {
    dependents.deinit();
    prerequisites.deinit();
    linked_targets.deinit();
  }

  void dependsOn(Target* prereq)
  {
    prerequisites.insert(prereq);
    prereq->dependents.insert(this);
  }

  void links(Target* linked)
  {
    linked_targets.insert(linked);
  }

  void cacheExistance()
  {
    PathBuffer path_buffer;
    String path = formPath(&path_buffer);

    exists = fs::path::exists(path);
    if (exists)
      modtime = fs::path::modtime(path);
  }

  b8 existsAndIsUpToDate() const
  {
    return exists && state == State::UpToDate;   
  }

  b8 isLeaf() const
  {
    return prerequisites.isEmpty();
  }

  b8 allPrereqsUpToDate() const
  {
    for (Target& prereq : prerequisites)
    {
      if (prereq.state != State::UpToDate)
        return false;
    }

    return true;
  }

  b8 isNewerThanAllPrerequisites() const
  {
    if (!exists)
      return false;

    for (Target& prereq : prerequisites)
    {
      if (!prereq.exists || prereq.modtime > modtime)
        return false;

      PathBuffer prereq_buffer;
    }

    return true;
  }

  String formPath(PathBuffer* out) 
  { 
    io::formatv(out, mount, '/', name, '.', type); 
    return String(*out);
  }

  String formPath(String prefix, PathBuffer* out)
  {
    io::formatv(out, prefix, '/');
    return formPath(out);
  }

  String formMetaPath(PathBuffer* out)
  {
    io::formatv(out, mount, '/', name, '.', type, ".meta"_str);
    return String(*out);
  }

  template<typename T>
  T* loadAsCompiledData(mem::Allocator* allocator)
  {
    PathBuffer path;
    CompiledData* compiled = CompiledData::load(
      formPath(&path),
      allocator);

    if (compiled == nullptr)
      return nullptr;

    compiled->fixPointers();

    return compiled->getRootAs<T>();
  }
};

/* ============================================================================
 */
struct StackTargetSet : TargetSet
{
  StackTargetSet()
  {
    TargetSet::init();
  }

  ~StackTargetSet()
  {
    TargetSet::deinit();
  }
};

/* ============================================================================
 */
struct BuildResult
{
  enum class Status
  {
    Success,
    Error,
  };

  Status status = Status::Success;
  String message = nil;

  void setError() { status = Status::Error; }
  void setError(String message) { setError(); this->message = message; }

  b8 wasSuccessful() const { return status == Status::Success; }
};

/* ============================================================================
 */
struct IBuildRule
{
  void (*getPrereqs)(
    Target* target, Builder* builder, TargetSet* prereqs, BuildResult* result);

  void (*build)(
    Target* target, Builder* builder, BuildResult* result);
};

/* ============================================================================
 */
struct Builder
{
  mem::LenientBump string_pool;

  typedef DLinkedPool<Target> TargetPool;
  typedef DList<Target> TargetList;

  TargetPool targets;
  TargetSet  target_set;
  TargetList target_queue;

  mem::LenientBump compiled_data_allocator;

  String source_dir;
  String build_dir;
  
  struct Rule
  {
    String type;
    Array<String> secondary_types;
    IBuildRule interface;
  };

  Array<Rule> build_rules;

  /* --------------------------------------------------------------------------
   */
  b8 init(String source_dir, String build_dir)
  {
    this->source_dir = source_dir;
    this->build_dir = build_dir;

    fs::mkdir(build_dir, true);

    if (!string_pool.init())
      return ERROR("failed to init string_pool\n");

    if (!targets.init())
      return ERROR("failed to init targets pool\n");

    if (!target_set.init())
      return ERROR("failed to init target_set\n");

    if (!target_queue.init())
      return ERROR("failed to init target_queue\n");

    if (!compiled_data_allocator.init())
      return ERROR("failed to init compiled_data_allocator\n");

    if (!build_rules.init())
      return ERROR("failed to init build_rules\n");

    return true;
  }

  /* --------------------------------------------------------------------------
   */
  void deinit()
  {
    string_pool.deinit();
    
    for (Target& target : targets)
      target.deinit();

    targets.deinit();
    target_set.deinit();
    target_queue.deinit();
    compiled_data_allocator.deinit();
      
    for (Rule& rule : build_rules)
    {
      if (notnil(rule.secondary_types))
        rule.secondary_types.destroy();
    }

    build_rules.destroy();
  }

  /* --------------------------------------------------------------------------
   */
  void registerRule(String type, const IBuildRule& interface)
  {
    Rule rule = {};

    // Parse the provided output types.
    String::Pair split = type.splitAtFirst(';');
    
    // Set the primary type to the first one specified.
    rule.type = split.first;

    if (notnil(split.second))
    {
      // If we found a secondary type, init the secondary array and parse
      // the rest.
      rule.secondary_types.init();
      for (;;)
      {
        split = split.second.splitAtFirst(';');
        rule.secondary_types.push(split.first);
        if (isnil(split.second))
          break;
      }
    }

    rule.interface = interface;

    build_rules.push(rule);
  }

  /* --------------------------------------------------------------------------
   */
  Target* getTarget(String name, String type, TargetKind kind)
  {
    if (Target* known = findKnownTarget(name, type))
    {
      assert(kind != TargetKind::Unknown || 
             known->kind != TargetKind::Unknown);

      if (kind == TargetKind::Unknown)
        kind = known->kind;

      if (known->kind == TargetKind::Unknown)
        known->kind = kind;

      assert(kind == known->kind);
      return known;
    }

    if (kind == TargetKind::Unknown)
    {
      if (type.endsWith(".compiled"_str))
        kind = TargetKind::CompiledAsset;
      else if (type.endsWith(".data"_str))
        kind = TargetKind::CompiledData;
    }

    assert(kind != TargetKind::Unknown);

    String mount;
    if (kind == TargetKind::CompiledData ||
        kind == TargetKind::CompiledAsset)
      mount = build_dir;
    else
      mount = source_dir;

    return newTarget(name, type, mount, kind);
  }

  /* --------------------------------------------------------------------------
   */
  template<typename T>
  T* loadAsCompiledData(Target* target)
  {
    assert(target && target->kind == TargetKind::CompiledData);
    return target->loadAsCompiledData<T>(&compiled_data_allocator);
  }

  /* --------------------------------------------------------------------------
   */
  b8 packAsset(String path, PackedData* packed)
  {
    DEBUG("packing source data at '", path, "'\n");

    SourceDataFile sfile;
    if (!SourceDataFile::from(&sfile, path))
      return ERROR("failed to load source data at '", path, "'\n");
    defer { sfile.deinit(); };

    TRACE("got source data:\n");
    if (TEST_VERBOSITY(Trace))
      sfile.returned_data->dump();

    if (!packed->init())
      return ERROR("failed to initialize PackedData for source data at '",
                   path, "'\n");

    PackParams pack_params = { packed };
    if (!packSourceDataFromType(*sfile.returned_data, pack_params))
      return ERROR("failed to pack source data at '", path, "'\n");

    return true;
  }

  /* --------------------------------------------------------------------------
   */
  CompiledData* compilePackedAsset(
      const PackedData& packed, 
      String output_path)
  {
    DEBUG("compiling packed data to '", output_path, "'\n");

    CompiledData::CompileParams compile_params = 
    {
      .type = packed.type,
      .dataptr = packed.data.ptr,
      .output_path = output_path,
    };

    if (!CompiledData::compile(compile_params))
      return ERROR("failed to compile packed data to '", output_path, "'\n"),
             nullptr;

    return CompiledData::load(output_path, &compiled_data_allocator);
  }

  /* --------------------------------------------------------------------------
   */
  CompiledData* packAndCompileSourceDataAsset(
      String input_path,
      String output_path)
  {
    PackedData packed;
    if (!packAsset(input_path, &packed))
      return nullptr;
    defer { packed.deinit(); };

    CompiledData* compiled = compilePackedAsset(packed, output_path);
    if (compiled == nullptr)
      return nullptr;

    compiled->fixPointers();
    return compiled;
  }

  /* --------------------------------------------------------------------------
   */
  String formOutputPath(PathBuffer* buffer, String target_name)
  {
    // Build output path.
    io::formatv(buffer, build_dir, "/", target_name);

    // Get null-terminated destination dir so we may create it.
    PathBuffer dest_dir;
    fs::path::removeBasename(String(*buffer)).nullTerminate(&dest_dir);

    fs::mkdir(String(dest_dir), true);

    return String(*buffer);
  }

  /* --------------------------------------------------------------------------
   */
  void loadTargetMetadata(Target* target)
  {
    PathBuffer meta_path_buffer;
    String meta_path = target->formMetaPath(&meta_path_buffer);

    if (!fs::path::exists(meta_path))
      return;

    PackedData packed_metadata;
    if (!packAsset(meta_path, &packed_metadata))
      return;
    defer { packed_metadata.deinit(); };

    auto* metadata = packed_metadata.getDataAs<build::TargetMetadata>();

    // rtr::prettyPrint(*metadata);

    for (TargetInfo& dep : metadata->prereqs)
    {
      // TODO(sushi) need to avoid all of these string copies when 
      //             merging into actual code. We should probably just 
      //             always output the compiled version of the meta 
      //             stuff and just optionally dump the source data 
      //             to disk for debugging.
      Target* dep_target = getTarget(
        dep.name.allocateCopy(&string_pool), 
        dep.type.allocateCopy(&string_pool), 
        dep.kind);
      target->dependsOn(dep_target);
      loadTargetMetadata(dep_target);
    }

    for (TargetInfo& linked : metadata->linked_targets)
    {
      Target* linked_target = getTarget(
        linked.name.allocateCopy(&string_pool), 
        linked.type.allocateCopy(&string_pool), 
        linked.kind);
      target->links(linked_target);
      loadTargetMetadata(linked_target);
    }
  }

  /* --------------------------------------------------------------------------
   */
  Target* newTarget(
      String name, 
      String type, 
      String mount,
      TargetKind kind)
  {
    INFO("new target ", name, '.', type, '\n');

    Target* target = targets.pushHead()->data;
    
    if (!target->init(name, type, mount, kind))
      return ERROR("failed to initialize new Target '", name, "' of type '",
                   type, "'\n"),
             nullptr;

    target_set.insert(target);
    loadTargetMetadata(target);

    return target;
  }

  /* --------------------------------------------------------------------------
   */
  void addTargetInfo(Target* target, SourceData* data, SourceDataFile* file)
  {
    SourceData* info = data->addObject(*file, nil, "build::TargetInfo"_str);

    PathBuffer path_buffer;
    info->addStringValue(*file, "name"_str, target->name);
    info->addStringValue(*file, "type"_str, target->type);
    info->addStringValue(
      *file, "kind"_str, rtr::getEnumElementName(target->kind));
  }

  /* --------------------------------------------------------------------------
   */
  void writeTargetMetaFile(Target* target)
  {
    SourceDataFile mfile;
    if (!mfile.init())
      return;
    defer { mfile.deinit(); };

    SourceData* data = mfile.addReturnData();

    data->setObject(nil);
    data->type = "build::TargetMetadata"_str;

    SourceData* prereqs = data->addObject(
      mfile, "prereqs"_str, "build::TargetInfoList"_str);

    SourceData* linked_targets = data->addObject(
      mfile, "linked_targets"_str, "build::TargetInfoList"_str);

    for (Target& prereq : target->prerequisites)
      addTargetInfo(&prereq, prereqs, &mfile);

    for (Target& linked : target->linked_targets)
      addTargetInfo(&linked, linked_targets, &mfile);

    PathBuffer meta_path;
    target->formPath(&meta_path);
    io::format(&meta_path, ".meta"_str);

    mfile.dumpToDisk(String(meta_path));
  }

  /* --------------------------------------------------------------------------
   */
  b8 buildTargets()
  {
    for (;;)
    {
      queueTargets();

      if (target_queue.isEmpty())
      {
        INFO("no more queued targets\n");
        break;
      }

      while (!target_queue.isEmpty())
      {
        Target* next = target_queue.popHead();

        b8 is_secondary;
        Rule* rule = findRuleForTarget(next, &is_secondary);

        // We should have had a rule for this target for us to know we can 
        // queue it for building.
        assert(rule != nullptr);

        INFO("building ", next->name, '.', next->type, '\n');

        PathBuffer target_path_buffer;
        String target_path = next->formPath(&target_path_buffer);

        PathBuffer target_path_dir;
        fs::path::removeBasename(target_path)
        .nullTerminate(&target_path_dir);

        fs::mkdir(String(target_path_dir), true);

        BuildResult result;
        rule->interface.build(next, this, &result);

        if (result.wasSuccessful())
        {
          // If success is reported, assume the next is now up to date.
          DEBUG("built ", next->name, '.', next->type, '\n');
          next->state = Target::State::UpToDate;
          next->cacheExistance();

          writeTargetMetaFile(next);
        }
      }
    }

    return true;
  }

  /* --------------------------------------------------------------------------
   */
  Target* findKnownTarget(String name, String type)
  {
    return target_set.find(combineHash(name.hash(), type.hash()));
  }

  /* --------------------------------------------------------------------------
   */
  void findLeaves(SList<Target>* leaves)
  {
    for (Target& target : target_set)
    {
      if (target.state == Target::State::QueuedForBuild)
        continue;

      // We don't need to build targets that are already up to date.
      if (target.state == Target::State::UpToDate)
        continue;

      // If the target still has out of date prereqs we can't build it yet.
      if (!target.allPrereqsUpToDate())
        continue;

      leaves->push(&target);
    }
  }

  /* --------------------------------------------------------------------------
   */
  Target* getOrCreateCompiledDataSourceTarget(Target* compiled)
  {
    String source_name = compiled->name.removePrefix(build_dir);
    String source_type = compiled->type.removeSuffix(".data"_str);

    if (Target* known = findKnownTarget(source_name, source_type))
      return known;

    return newTarget(
      source_name, source_type, source_dir, TargetKind::SourceData);
  }

  /* --------------------------------------------------------------------------
   */
  Rule* findRuleForTarget(Target* target, b8* out_is_secondary)
  {
    Rule* best_rule = nullptr;
    String best_type = nil;
    b8 best_is_secondary = false;

    auto takeRule = [&](Rule* rule, String type, b8 is_secondary)
    {
      best_rule = rule;
      best_type = type;
      best_is_secondary = is_secondary;
    };

    for (Rule& rule : build_rules)
    {
      if (target->type == rule.type)
      {
        // Exact type matches are taken immediately.
        takeRule(&rule, rule.type, false);
        break;
      }
      else if (target->type.endsWith(rule.type))
      {
        // If the target's type ends with this rule's type, 
        // take it as best if the match is longer than that of the 
        // current best rule.
        if (rule.type.len > best_type.len)
          takeRule(&rule, rule.type, false);
      }

      // Check the secondary output types of this rule as well, if any were 
      // specified.
      if (notnil(rule.secondary_types))
      {
        b8 exact_secondary = false;
        for (String secondary : rule.secondary_types)
        {
          if (target->type == secondary)
          {
            // Again, exact secondary matches are taken immediately.
            // Really wish C++ had labeled breaking.
            exact_secondary = true;
            takeRule(&rule, secondary, true);
            break;
          }
          else if (target->type.endsWith(secondary))
          {
            if (secondary.len > best_type.len)
              takeRule(&rule, secondary, true);
          }
        }
      }
    }

    *out_is_secondary = best_is_secondary;
    return best_rule;
  }

  /* --------------------------------------------------------------------------
   */
  b8 queueTargets()
  {
    for (;;)
    {
      ScopedSList<Target> leaves;
      findLeaves(&leaves);

      if (leaves.isEmpty())
        break;

      for (auto& leaf : leaves)
      {
        PathBuffer path_buffer;
        DEBUG("leaf: ", leaf.formPath(&path_buffer), '\n');

        b8 is_secondary;
        if (Rule* rule = findRuleForTarget(&leaf, &is_secondary))
        {
          BuildResult result;
          StackTargetSet rule_prereqs;

          rule->interface.getPrereqs(&leaf, this, &rule_prereqs, &result);
        
          // Mark the prereqs of this target based on what the rule 
          // told us.
          for (auto& prereq : rule_prereqs)
            leaf.dependsOn(&prereq);

          // Check if all the prereqs for this target are up to date. If 
          // so, we can build it.
          if (leaf.allPrereqsUpToDate())
          {
            // TODO(sushi) it is likely a bad assumption to just set the 
            //             target as up-to-date when we find that its rule
            //             is for a secondary target. Once this is pulled into
            //             main, we need to do something else.
            if (!leaf.isNewerThanAllPrerequisites() && !is_secondary)
            {
              PathBuffer queued_path;
              DEBUG("adding '", leaf.formPath(&queued_path), "' to queue\n");
              target_queue.pushTail(&leaf);
              leaf.state = Target::State::QueuedForBuild;
            }
            else
              leaf.state = Target::State::UpToDate;
          }
        }
        else 
        {
          if (!leaf.exists)
          {
            // If we don't have a rule to build this target and it 
            // doesn't exist, then we don't know what to do.
            PathBuffer non_existant_target;
            ERROR("no rule provided for non-existant build target '", 
                  leaf.formPath(&non_existant_target), "'\n");
            return false;
          }
          else
          {
            // Otherwise, consider this target up-to-date, and to be used
            // to build other targets next time around.
            leaf.state = Target::State::UpToDate;
          }
        }
      }
    }

    return true;
  }

  /* --------------------------------------------------------------------------
   *  Create a target based on the given path. This is primarily to discern
   *  between CompiledData and CompiledAssets.
   */
  Target* createTargetFromAssetPath(String path)
  {
    String name = fs::path::removeExtension(path);
    String type = fs::path::getExtension(path);

    Target* result = nullptr;
    if (type.endsWith(".data"_str))
    {
      // This must be some CompiledData.
      result = newTarget(
        name, type, build_dir, TargetKind::CompiledData);
    }
    else if (type.endsWith(".compiled"_str))
    {
      // This must be some CompiledAsset.
      result = newTarget(
        name, type, build_dir, TargetKind::CompiledAsset);
    }

    assert(result != nullptr);
    return result;
  }

  /* --------------------------------------------------------------------------
   */
  b8 buildAssetList(String path)  
  {
    PackedData packed;
    build::AssetList* asset_list = packAssetList(
        "tests/asset-building/test.asset_list"_str, &packed);
    defer { packed.deinit(); };

    if (asset_list == nullptr)
      return ERROR("failed to pack asset list '", path, "'\n");

    for (const auto& asset : *asset_list)
    {
      String target_path = asset.nullTerminate(&string_pool);
      Target* target = createTargetFromAssetPath(target_path);
      INFO("asset list target: ", target->name, '\n');
    }

    return buildTargets();
  }
};

b8 testAssetBuilding()
{
  PathBuffer cwd_buffer;
  cwd_buffer.len = fs::cwd(cwd_buffer.asBytesBuffer());
  if (cwd_buffer.len == 0)
    return ERROR("failed to get cwd\n");
  String cwd = String(cwd_buffer);

  PathBuffer compiled_dir_buffer;
  io::formatv(&compiled_dir_buffer, 
    cwd, '/', "tests/asset-building/_data"_str);
  String compiled_dir = String(compiled_dir_buffer);

  Builder builder;
  if (!builder.init(cwd, compiled_dir))
    return false;
  defer { builder.deinit(); };

  builder.registerRule("data"_str, 
    {
      .getPrereqs = [](
          Target* target, 
          Builder* builder, 
          TargetSet* prereqs,
          BuildResult* result)
      {
        // Data targets need some SourceData to build, which should be named 
        // without the .data extension.
        Target* source_target = builder->getTarget(
          target->name,
          target->type.removeSuffix(".data"_str), 
          TargetKind::SourceData);

        // Note the source target as a prereq.
        prereqs->insert(source_target);
      },

      .build = [](Target* target, Builder* builder, BuildResult* result)
      {
        Target* source_target = builder->getTarget(
          target->name,
          target->type.removeSuffix(".data"_str), 
          TargetKind::SourceData);

        PathBuffer source_path_buffer;
        PathBuffer target_path_buffer;

        CompiledData* compiled = 
          builder->packAndCompileSourceDataAsset(
            source_target->formPath(&source_path_buffer),
            target->formPath(&target_path_buffer));

        for (CompiledData::Ref& ref : compiled->refs.getSlice())
        {
          String def_links = rtr::getMetadataValue(ref.type, "links"_str);
          
          if (notnil(def_links))
          {
            String::Pair split = def_links.splitAtFirst(';');
            for (;;)
            {
              Target* links_target = builder->getTarget(
                ref.target.getString(),
                split.first,
                TargetKind::Unknown);

              target->links(links_target);

              if (isnil(split.second))
                break;

              split = split.second.splitAtFirst(';');
            }
          }
        }
      },
    });

  builder.registerRule("texture.compiled"_str, 
    {
      .getPrereqs = [](
          Target* target, 
          Builder* builder, 
          TargetSet* prereqs,
          BuildResult* result)
      {
        // Compiled textures need some compiled SourceData to understand 
        // what texture to build and how. Ask the build system for the data
        // target that should be CompiledData and has extension 'texture.data'.
        Target* data_target = builder->getTarget(
            target->name, 
            "texture.data"_str, 
            TargetKind::CompiledData);
      
        // Note the data target as a prereq.
        prereqs->insert(data_target);
        
        // If the data target exists and is up to date, load it and get 
        // the texture that we want to compile. Otherwise, the builder should
        // realize that the prereq does not exist and will try to build it 
        // for us to try this again later.
        if (data_target->existsAndIsUpToDate())
        {
          auto* texture_def = 
            builder->loadAsCompiledData<gfx::TextureDef>(data_target);
          if (texture_def == nullptr)
          {
            result->setError("failed to load compiled texture def\n"_str);
            return;
          }

          if (isnil(texture_def->name))
          {
            result->setError(
              "texture def does not specify a source texture\n"_str);
            return;
          }

          // Parse the source texture name.
          String source_texture_name = 
            fs::path::removeExtension(texture_def->name);
          String source_texture_type = 
            fs::path::getExtension(texture_def->name);

          // Get or create the source texture target and mark it as a 
          // prerequisite SourceAsset.
          Target* source_texture_target = builder->getTarget(
            source_texture_name, 
            source_texture_type, 
            TargetKind::SourceAsset);

          prereqs->insert(source_texture_target);
        }
      },

      .build = [](Target* target, Builder* builder, BuildResult* result)
      {
        Target* data_target = 
          builder->findKnownTarget(target->name, "texture.data"_str);

        PathBuffer data_path_buffer;
        PathBuffer target_path_buffer;
        
        // TODO(sushi) compilation functions could take the BuildResult.
        b8 success = 
          gfx::compileTexture(
            data_target->formPath(&data_path_buffer),
            target->formPath(&target_path_buffer));

        if (!success)
          result->setError();
      },
    });

  builder.registerRule("font.compiled;font.texture.compiled"_str,
    {
      .getPrereqs = [](
          Target* target, 
          Builder* builder, 
          TargetSet* prereqs,
          BuildResult* result)
      {
        Target* data_target = builder->getTarget(
          target->name,
          "font.data"_str,
          TargetKind::CompiledData);

        prereqs->insert(data_target);

        if (data_target->existsAndIsUpToDate())
        {
          auto* font_def = 
            builder->loadAsCompiledData<gfx::FontDef>(data_target);
          if (font_def == nullptr)
          {
            result->setError("failed to load compiled font def\n"_str);
            return;
          }

          if (isnil(font_def->name))
          {
            result->setError(
              "font def does not specify a source font\n"_str);
            return;
          }

          // Parse the source font name.
          String source_font_name = 
            fs::path::removeExtension(font_def->asset_path);
          String source_font_type = 
            fs::path::getExtension(font_def->asset_path);

          // Get or create the source font target and mark it as a 
          // prerequisite SourceAsset.
          Target* source_font_target = builder->getTarget(
            source_font_name, 
            source_font_type, 
            TargetKind::SourceAsset);

          prereqs->insert(source_font_target);
        }
      },

      .build = [](Target* target, Builder* builder, BuildResult* result)
      {
        Target* data_target = 
          builder->findKnownTarget(target->name, "font.data"_str);

        PathBuffer data_path_buffer;
        PathBuffer target_path_buffer;
        PathBuffer target_texture_path_buffer;
        io::formatv(
          &target_texture_path_buffer, 
          target->mount, '/', target->name, '.', 
          "font.texture.compiled"_str);
        
        // TODO(sushi) compilation functions could take the BuildResult.
        b8 success = 
          gfx::compileFont(
            data_target->formPath(&data_path_buffer),
            target->formPath(&target_path_buffer),
            String(target_texture_path_buffer));

        if (!success)
          result->setError();
      }
    });

  builder.registerRule("shader.compiled"_str,
    {
      .getPrereqs = [](
          Target* target, 
          Builder* builder, 
          TargetSet* prereqs,
          BuildResult* result) 
      {
        Target* data_target = builder->getTarget(
          target->name,
          "shader.data"_str,
          TargetKind::CompiledData);
        
        prereqs->insert(data_target);

        if (data_target->existsAndIsUpToDate())
        {
          auto* shader_def = 
            builder->loadAsCompiledData<gfx::ShaderDef>(data_target);

          if (shader_def == nullptr)
          {
            result->setError("failed to load compiled shader def\n"_str);
            return;
          }

          if (isnil(shader_def->source))
          {
            result->setError(
              "shader def does not specify a source shader\n"_str);
            return;
          }

          String source_shader_name =
            fs::path::removeExtension(shader_def->source);
          String source_shader_type =
            fs::path::getExtension(shader_def->source);

          // Get or create the source shader target and mark it as a 
          // prerequisite SourceAsset.
          Target* source_shader_target = builder->getTarget(
            source_shader_name, 
            source_shader_type, 
            TargetKind::SourceAsset);

          prereqs->insert(source_shader_target);
        }
      },
      .build = [](Target* target, Builder* builder, BuildResult* result) 
      {
        Target* data_target = 
          builder->findKnownTarget(target->name, "shader.data"_str);

        PathBuffer data_path_buffer;
        PathBuffer target_path_buffer;
        
        gfx::CompileShaderParams params = 
        {
          .input_path = data_target->formPath(&data_path_buffer),
          .output_path = target->formPath(&target_path_buffer),
        };

        // TODO(sushi) compilation functions could take the BuildResult.
        b8 success = gfx::compileShader(params);

        if (!success)
          result->setError();
      },
    });

  if (!builder.buildAssetList("tests/asset-builder/test.asset_list"_str))
    return false;

  return true;
}

int main()
{
  iro::initializeDefaultLogging();
  return testAssetBuilding()? 0 : 1;
}
