/*
 *  Template file that generates the categories header, which contains 
 *  declarations of each category, as well as the functions which log through
 *  them.
 *  
 *  This file is generated by tools/loggen/category_decls.lpp.
 */

$ local lpp = require "lpp"
$ local conf = require "core.logging.conf"
$ local def = require "tools.loggen.gather"
$ local categories = def._get_categories().list

// Since this file is not apart of the normal src/ compilation, we still 
// need to use include guards.
#ifndef __loggen_category_decls_h
#define __loggen_category_decls_h

@lpp.import "core/logging/core.lh"

#include "iro/fs/fs.h"

namespace logging
{

// Even with all this lpp stuff, we still write out a macro call instead of 
// just writing the expression directly. The main reason is that it avoids 
// a warning from clang on the ', true' expression at the end being unused.
// However, this also results in cleaner and easier to look at code, both
// where it is output and in logging/log.lua.
#define __ECS_LOG_MACRO(cat, verb, ...) \
  (::logging::Verbosity::verb >= ::logging::cat_##cat.verbosity && \
  (::logging::through_cat_##cat(::logging::Verbosity::verb, __VA_ARGS__), \
  true))

#define __ECS_LOG_MACRO_TRUE(cat, verb, ...) \
  (__ECS_LOG_MACRO(cat, verb, __VA_ARGS__), true)

#define __ECS_LOG_MACRO_FALSE(cat, verb, ...) \
  ((__ECS_LOG_MACRO(cat, verb, __VA_ARGS__)), false)

$ for cat in categories:each() do

extern Category cat_$(cat.name);

template<typename... Args>
void through_cat_$(cat.name)(Verbosity v, Args... args)
{
  assert(v >= cat_$(cat.name).verbosity && 
    "Verbosity of category $(cat.name) was not checked externally");

  iro::io::formatv(iro::fs::stdout(), args...);
}

$ end
}

#endif
