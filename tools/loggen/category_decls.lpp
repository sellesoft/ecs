/*
 *  Template file that generates the categories header, which contains 
 *  declarations of each category, as well as the functions which log through
 *  them.
 *  
 *  This file is generated by tools/loggen/category_decls.lpp.
 *
 *  TODO(sushi) actual entry api and separated desintations. Important once 
 *              I get to setting the console back up.
 */

$ local lpp = require "lpp"
$ local conf = require "core.logging.conf"
$ local def = require "tools.loggen.gather"
$ local categories = def._get_categories().list
$ local List = require "iro.List"

// Since this file is not apart of the normal src/ compilation, we still 
// need to use include guards.
#ifndef __loggen_category_decls_h
#define __loggen_category_decls_h

@lpp.import "core/logging/core.lh"

#include "iro/fs/fs.h"
#include "iro/StringFuncs.h"

namespace logging
{

// Even with all this lpp stuff, we still write out a macro call instead of 
// just writing the expression directly. The main reason is that it avoids 
// a warning from clang on the ', true' expression at the end being unused.
// However, this also results in cleaner and easier to look at code, both
// where it is output and in logging/log.lua.
#define __ECS_LOG_MACRO(chan, cat, verb, ...) \
  (::logging::Verbosity::verb >= ::logging::cat_##cat.verbosity && \
  (::logging::through_cat_##cat(chan, ::logging::Verbosity::verb, __VA_ARGS__), \
  true))

#define __ECS_LOG_MACRO_TRUE(chan, cat, verb, ...) \
  (__ECS_LOG_MACRO(chan, cat, verb, __VA_ARGS__), true)

#define __ECS_LOG_MACRO_FALSE(chan, cat, verb, ...) \
  ((__ECS_LOG_MACRO(chan, cat, verb, __VA_ARGS__)), false)

/* ----------------------------------------------------------------------------
 */
static inline s64 writeVerbosity(iro::io::WStream* out, Verbosity v)
{
  using namespace iro;

$ local function case(v, c)
  case Verbosity::$(v):
    return iro::io::formatv(out, 
      tcolor::$(c), "$(v:lower())"_str, tcolor::reset, ": ");
    break;
$ end

  switch (v)
  {
  @case(Trace,  blue)
  @case(Debug,  green)
  @case(Info,   cyan)
  @case(Notice, magenta)
  @case(Warn,   yellow)
  @case(Error,  red)
  @case(Fatal,  red)
  }

  return 0;
}

/* ----------------------------------------------------------------------------
 */
static inline s64 writePrefix(
    iro::io::WStream* out, 
    Verbosity v, 
    Category& cat)
{
  s64 sum = writeVerbosity(out, v);
  sum += iro::io::formatv(out, tcolor::gray, cat.name, tcolor::reset, ": ");
  return sum;
}

/* ============================================================================
 *  TODO(sushi) get rid of this eventually and just extract text into a buffer
 *              to scan. Kinda sucks, but would more easily support stuff I'd
 *              like, like word splitting, breaking lines at 80 columns, etc.
 *              This just gets the basic verbosity and category name stuff 
 *              working again with color like it was in iro.
 */
struct Interceptor : iro::io::WStream
{
  Category& cat;
  Verbosity v;

  Interceptor(Category& cat, Verbosity v) : cat(cat), v(v) {}

  s64 write(u8* ptr, u64 len) override
  {
    s64 sum = 0;

    using namespace iro;

    u64 prefixlen = 0;
    u64 linelen = 0;
    for (s32 i = 0; i < len; ++i)
    {
      if (cat.need_prefix)
      {
        prefixlen = writePrefix(fs::stdout(), v, cat);
        cat.need_prefix = false;
      }

      if (ptr[i] == '\n')
      {
        fs::stdout()->write(ptr + i - linelen, linelen + 1);
        cat.need_prefix = true;
        linelen = 0;
      }
      else
      {
        linelen += 1;
      }
    }

    if (linelen)
      fs::stdout()->write(ptr + len - linelen, linelen);

    return len;
  }
};

$ for cat in categories:each() do

extern Category cat_$(cat.name);

/* ----------------------------------------------------------------------------
 */
template<typename... Args>
void through_cat_$(cat.name)(Channel* chan, Verbosity v, Args... args)
{
  using namespace iro;

  chan->log(&cat_$(cat.name), v, args...);
}

$ end
}

#endif
